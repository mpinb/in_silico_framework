/*****************************************************
*Template for genetic algorithm in NEURON

*This template defines the function to be evaluated
*and all necessary parts thereof.
*In main usage this is where the model is created.

*Author: Shaul Druckmann, Hebrew U, May 2006
*
*Modified by: Etay Hay, Hebrew University of Jerusalem, 2011
*****************************************************/

begintemplate OrganismEvaluator
	objref target_vec,stim1,neg_stim,target_file,voltage_vec,apc
	objref spike_vector,v_graph,apc_vector,sec_r
	objref mean_matrix,std_matrix,mean_file,deviation_file
	objref current_vector,tvec
	objref channel_inject_list, channel_type_list, channel_subset_list, channel_distribution_parameter_list
	objref cvode
	objref insertion_list,stimulus_type_list,stimulus_amplitude_list
	objref variable_suffix_list, variable_subset_list,variable_parameter_list
	objref param_vector,par_vector, distribution_type_vector
	objref variable_to_channel_vector, sim_volt_list, sim_time_list
	objref gacell, feature_name_list
	objref svec,stvec
	objref ev,mc,pc
	objref raw_error_matrix_list, stimulus_feature_name_list, stimulus_feature_type_list, org_list
	objref tag_vec,receive_vec,pass_genome_vector,take_vec
	objref ps, calculator, pop, sol
	objref feature_mean_list, feature_std_list
	strdef s_1,s_2,s_3,s_4,s_5,final_string
	strdef ccellsection, csuffix, cparameter,cmd

  //added by Etay
  objref sl,srefdend,ns,ns2,ns3,syn1,con1,stim2
  objref srefdend2,srefdend3,sec_r2,voltage_vec2,syn2,con2,syn3,con3
  double siteVec[2]
  strdef BACyn, bAPyn
  //objref sim_volt_list2,sim_volt_list3
  objref vList, sec_r3
  
  //public pass_sim_volt2, pass_sim_volt3
  //end of chunk added by Etay

	public s_1,s_2,s_3,s_4,s_5,distrib_type,par_vector
	public target_vec,sec_r
	public value,voltage_vec, base_value
	public create_environment,silly_error,evaluate_genome
	public strange,test,prepare_organism,stim1
 	public calculate
	public pass_variable_to_channel_vector
	public evaluate_genome_split, evaluate_genome_save_traces, clear_trace_lists
	public pass_sim_volt, pass_sim_time, gacell, finalize_fitness
	public autoref, evaluate_population // , setup_error_structure
	public set_pop, set_trace_save, setup_configuration


	proc init(/*Calculator object, config object*/)	{
		save_trace = 0

		cvode = new CVode()
		calculator = $o1
		gacell = $o2
		mc = $o3
		pc = $o4

    // added by Etay for BAC
    sl = new List()
    // end of chunk added by Etay
    
		tvec = new Vector()
		use_density = 0

		apc_vector = new Vector()
		spike_vector = new Vector()
		sim_volt_list = new List()
		//sim_volt_list2 = new List()
    //sim_volt_list3 = new List()
    sim_time_list = new List()

		create_framework($o2)

		param_vector = new Vector(4)

    access gacell.soma

		setup_configuration(mc)
	}

	proc setup_configuration(/*mc*/)	{
		set_config_parameters($o1)
		setup_error_structure($o1)
		setup_evaluation_objects($o1)
	}


	proc set_pop()	{pop = $o1}

	/*****************************************************************
	// Procedure that creates autorference that is necessary for the
	// parallel submission of organism evaluation (see evaluate ppulation)
	/****************************************************************/

	proc autoref()	{ev = $o1}

	/*****************************************************************
	// Procedure that defines objects for organism evaluation
	/****************************************************************/

	proc setup_evaluation_objects()	{
		pass_genome_vector = new Vector()
		take_vec = new Vector()
		tag_vec = new Vector()
		receive_vec = new Vector()
		org_list = new List()

		$o1.get_feature_statistics_list(feature_mean_list,feature_std_list)

		sol = $o1.get_sol()
		distribution_type_vector = $o1.get_channel_distribution_type_vector()
		channel_distribution_parameter_list = $o1.get_channel_distribution_parameter_list()
		variable_to_channel_vector = $o1.get_variable_to_channel_vector()
	}

	/*****************************************************************
	// Procedure that updates parameters from the GA configuration
	/****************************************************************/

	proc set_config_parameters()	{
		//print "set config parameters called"
		pop_size =  $o1.get_numerical_parameter("PopulationSize")
		objective_num = $o1.get_objective_num()
		stim_num = $o1.get_stimulus_num()
		p_cross = $o1.get_numerical_parameter("PCross")
		max_generation = $o1.get_numerical_parameter("MaxGeneration")
		penalty = $o1.get_numerical_parameter("RejectPenalty")
		regen_frac = $o1.get_numerical_parameter("RegenerationFraction")
	}

	/*****************************************************************
	// Procedure that defines the matrices that will absorb the raw
	// error values (basically all the extracted features before
	// summation into the objectives)
	/****************************************************************/

	proc setup_error_structure()	{local i localobj mat
		raw_error_matrix_list = new List()
		$o1.get_stimulus_feature_lists(stimulus_feature_name_list, stimulus_feature_type_list)
		for i=0, stimulus_feature_name_list.count-1	{
			mat = new Matrix(pop_size,stimulus_feature_name_list.o(i).count)
			raw_error_matrix_list.append(mat.c)
		}
	}

	//proc clear_list()	{org_list.remove_all()}

	/*****************************************************************
	// Procedure that evaluates a population as defined by a list of
	// organisms.
	/****************************************************************/

	proc evaluate_population()	{local si, oi, wsi, woi, j, count
		org_list = $o1
		for i=0, raw_error_matrix_list.count-1	{raw_error_matrix_list.o(i).resize(org_list.count,raw_error_matrix_list.o(i).ncol)}
		for si = 0, stim_num-1	{
			for oi=0, org_list.count-1	{
				pass_genome_vector = org_list.o(oi).pass_genome()
				pc.submit(ev, "parallel_evaluate",pass_genome_vector,oi, si)
// 				parallel_evaluate(pass_genome_vector,oi, si)
			}
		}

		while (id = pc.working) {
			pc.take(id)
			take_vec = pc.upkvec()
			size = take_vec.size()
			woi = take_vec.x[size-2]
			wsi = take_vec.x[size-1]

			take_vec.remove(size-1)
			take_vec.remove(size-2)

			raw_error_matrix_list.o(wsi).setrow(woi,take_vec.c)
		}

		finalize_fitness(raw_error_matrix_list,org_list)
	}

	proc silence_stim()	{
		svec.play_remove()
		neg_stim.amp = 0
		stim1.amp = 0
 		if (0==strcmp(bAPyn,"y")) {
      stim2.amp = 0.0
    }
 		if (0==strcmp(BACyn,"y")) {
      stim2.amp = 0.0
      syn1.imax = 0.0
    }
 		svec = new Vector(0)
		stvec = new Vector(0)
	}
	/*****************************************************************
	// Procedure that wraps the evaluation of a single stimulus
	// on a single organism
	/****************************************************************/

	func parallel_evaluate(/*organism genome, organsim index, stimulus index*/)	{local id,value,index,stim_ind
		index = $2
		stim_ind = $3

		id = hoc_ac_
		tag_vec.resize(0)

		receive_vec = evaluate_genome_split($o1.c,calculator,save_trace,stim_ind)

		value = receive_vec.sum

		tag_vec.append(receive_vec)

		tag_vec.append(index)
		tag_vec.append(stim_ind)

		pc.post(id,tag_vec)
		return value
	}

	/*****************************************************************
	/* Function that evaluates a single stimulus step on a single organism
	*****************************************************************/

	obfunc evaluate_genome_split(/*organism genome, ref to calculator object, save trace flag, stim step index*/)	{local i,j,k,n,val,rep_num,check_one,check_two,cur_stim,ts,tdur,amps,ampe,tstop localobj assign_vec, pass_vec, stim_vec
		//print "Started genome evaluation"
		assign_vec = $o1
		cur_stim = $4
		pass_vec = new Vector()
		stim_vec = new Vector(2)
		val = 0

		new_inject_set_parameters(assign_vec,mc)
// 		print "Back in: evaluate_genome_split()"
		i = 0
		j = cur_stim
// 		i=0/0
		// Etay: minimum spike number, to be passed to distance_calculator for tracecheck
    minspikenum = 2
		
// 	print "Determining stimulus"
    if (strcmp(sol.o(cur_stim).get_type().s,"SquarePulse") == 0)	{
		print "Stimulus: SquarePulse"
      access gacell.soma

			sprint(cmd,"tstop = %d",sol.o(cur_stim).get_numerical_parameter("SimLength"))
      execute(cmd)
			tstop = sol.o(cur_stim).get_numerical_parameter("SimLength")
			define_step_stimulus(sol.o(cur_stim).get_numerical_parameter("Amplitude")+sol.o(cur_stim).get_numerical_parameter("HypAmp"),sol.o(cur_stim).get_numerical_parameter("Delay"),sol.o(cur_stim).get_numerical_parameter("Duration"),tstop)
			svec.play(&stim1.amp,stvec,1)
			neg_stim.dur = tstop
			n = sol.o(cur_stim).get_numerical_parameter("HypAmp")
			neg_stim.amp = -n
			stim_vec.x[0] = sol.o(cur_stim).get_numerical_parameter("Delay")
			stim_vec.x[1] = sol.o(cur_stim).get_numerical_parameter("Duration")

      vList = new List()
  		vList.append(new Vector())
  		sec_r = new SectionRef()
  		sec_r	{
  			cvode.active(1)
  			cvode.record(&v(0.5),vList.o[0],tvec,0)
  			execute("using_cvode_=1")
  			apc = new APCount(0.5)
   			apc.record(apc_vector)
	  		apc.thresh = -30
  		}
		}

		if (strcmp(sol.o(cur_stim).get_type().s,"Ramp") == 0)	{
      vList = new List()
			//ADDED ARTIFICIALLY 700 msec to ramp to allow it to stabilize
			//print "Ramp"
			execute("tstop = 3000")
			tstop = 3000
			define_ramp_stimulus(sol.o(cur_stim).get_numerical_parameter("Amplitude"))
			svec.play(&stim1.amp,stvec,1)
			neg_stim.dur = tstop
			n = sol.o(cur_stim).get_numerical_parameter("HypAmp")
			neg_stim.amp = -n
			//print "neg stim duration is ", neg_stim.dur, " amp is ", neg_stim.amp
			stim_vec.x[0] = 700
			stim_vec.x[1] = 2000
		}

    // Etay code begins  
    bAPyn = "n"
    if(strcmp(sol.o(cur_stim).get_type().s,"bAP") == 0)	{
			execute("tstop = 600")
			tstop = 600
			access gacell.soma

      vList = new List()
  		sec_r = new SectionRef()
  		vList.append(new Vector())

  		sec_r2 = new SectionRef()
  		vList.append(new Vector())

  		sec_r3 = new SectionRef()
  		vList.append(new Vector())

			sec_r	{
			  stim2 = new IClamp(0.5)
			  stim2.del = 295
			  stim2.amp = sol.o(cur_stim).get_numerical_parameter("SomaStepAmp")
			  stim2.dur = 5
			}
			stim_vec.x[0] = 295
			stim_vec.x[1] = 5

  		sec_r	{
  			cvode.active(1)
  			cvode.record(&v(0.5),vList.o[0],tvec,0)
  			execute("using_cvode_=1")
  			apc = new APCount(0.5)
   			apc.record(apc_vector)
	  		apc.thresh = -30
  		}
 
      bAPyn = "y"
      
      minspikenum = 1

      sl = gacell.locateSites("apic",sol.o(cur_stim).get_numerical_parameter("RecSite1Distance"))
      maxdiam = 0
      for(i1=0;i1<sl.count();i1+=1){
        dd = gacell.apic[sl.o[i1].x[0]].diam
        if (dd > maxdiam) {
          j1 = i1
          maxdiam = dd 
        }
      }

      siteVec[0] = sl.o[j1].x[0]
      siteVec[1] = sl.o[j1].x[1]

      access gacell.apic[siteVec[0]]
  		sec_r2	{
  			cvode.active(1)
  			cvode.record(&v(siteVec[1]),vList.o[1],tvec,0)
  			execute("using_cvode_=1")
  		}
      access gacell.soma

      sl = gacell.locateSites("apic",sol.o(cur_stim).get_numerical_parameter("RecSite2Distance"))
      maxdiam = 0
      for(i1=0;i1<sl.count();i1+=1){
        dd = gacell.apic[sl.o[i1].x[0]].diam
        if (dd > maxdiam) {
          j1 = i1
          maxdiam = dd 
        }
      }

      siteVec[0] = sl.o[j1].x[0]
      siteVec[1] = sl.o[j1].x[1]

      access gacell.apic[siteVec[0]]
  		sec_r3	{
  			cvode.active(1)
  			cvode.record(&v(siteVec[1]),vList.o[2],tvec,0)
  			execute("using_cvode_=1")
  		}

      access gacell.soma
    }

    BACyn = "n"
    if(strcmp(sol.o(cur_stim).get_type().s,"BAC") == 0)	{
      vList = new List()

  		sec_r = new SectionRef()
  		vList.append(new Vector())

  		sec_r2 = new SectionRef()
  		vList.append(new Vector())

			execute("tstop = 600")
			tstop = 600
			access gacell.soma
			sec_r	{
			  stim2 = new IClamp(0.5)
			  stim2.del = 295
			  stim2.amp = sol.o(cur_stim).get_numerical_parameter("SomaStepAmp")
			  stim2.dur = 5
			}
			stim_vec.x[0] = 295
			stim_vec.x[1] = 45

  		sec_r	{
  			cvode.active(1)
  			cvode.record(&v(0.5),vList.o[0],tvec,0)
  			execute("using_cvode_=1")
  			apc = new APCount(0.5)
   			apc.record(apc_vector)
	  		apc.thresh = -30
  		}
 
      sl = gacell.locateSites("apic",sol.o(cur_stim).get_numerical_parameter("RecSiteDistance"))

      maxdiam = 0
      for(i1=0;i1<sl.count();i1+=1){
        dd = gacell.apic[sl.o[i1].x[0]].diam
        if (dd > maxdiam) {
          j1 = i1
          maxdiam = dd 
        }
      }
  
      siteVec[0] = sl.o[j1].x[0]
      siteVec[1] = sl.o[j1].x[1]

      access gacell.apic[siteVec[0]]
      gacell.apic[siteVec[0]] srefdend = new SectionRef()

      srefdend {
        syn1 = new epsp(siteVec[1])
        syn1.tau0 = sol.o(cur_stim).get_numerical_parameter("RiseTimeConstant")       
        syn1.tau1 = sol.o(cur_stim).get_numerical_parameter("DecayTimeConstant")   
        syn1.onset = 300  
        syn1.imax = sol.o(cur_stim).get_numerical_parameter("ApicStimIMax")
      }
      access gacell.soma  

      BACyn = "y"

      sl = gacell.locateSites("apic",sol.o(cur_stim).get_numerical_parameter("RecSiteDistance"))
      maxdiam = 0
      for(i1=0;i1<sl.count();i1+=1){
        dd = gacell.apic[sl.o[i1].x[0]].diam
        if (dd > maxdiam) {
          j1 = i1
          maxdiam = dd 
        }
      }

      siteVec[0] = sl.o[j1].x[0]
      siteVec[1] = sl.o[j1].x[1]

      access gacell.apic[siteVec[0]]

  		sec_r2	{
  			cvode.active(1)
  			cvode.record(&v(siteVec[1]),vList.o[1],tvec,0)
  			execute("using_cvode_=1")
  		}
      access gacell.soma
    }

    //end of chunk added by Etay
    //added by RE so Ca2+ reversal potential
    //matches channel dynamics
    celsius=34
    //end added by RE
    execute("init()")
		execute("run()")
        print "Ran stimulus ", sol.o(cur_stim).get_type().s
		pass_vec = $o2.get_organism_stimulus_error(feature_mean_list.o(cur_stim),feature_std_list.o(cur_stim),tvec,vList,apc_vector,stim1,penalty,use_density,cur_stim, stimulus_feature_type_list.o(cur_stim),stim_vec,minspikenum)
        print "pass_vec: ", pass_vec.c
		if ($3 == 1)	{
			sim_time_list.append(tvec.c)
			sim_volt_list.append(new List())
      for(i1=0;i1<vList.count();i1+=1){
        sim_volt_list.o[sim_volt_list.count()-1].append(vList.o[i1].c)
      }
		}

		silence_stim()

		return pass_vec.c
	}


	/*****************************************************************
	// This function is meant to transform for all organisms the raw
	// error matrices that contain the error of each extracted feature
	// in each stimulus to the values of the actual objectives
	*****************************************************************/

	proc finalize_fitness()	{local i,j,k,ii,w localobj sum_vec, mat, l, featurevec
    mat = new Matrix($o2.count,objective_num)
		for i =0, objective_num-1	{
      l = mc.get_objective_string_parameter_list(i)
			for j=0, stimulus_feature_name_list.count-1	{
				for k=0, stimulus_feature_name_list.o(j).count-1	{
					for ii=0, l.count-1	{
						if (strcmp(stimulus_feature_name_list.o(j).o(k).s, l.o(ii).s)==0)	{
							w = mc.get_feature_weight(l.o(ii).s)
							
							featurevec = $o1.o(j).getcol(k).mul(w)
							
							for i3 = 0, $o2.count-1 {
						    if (mat.x[i3][i] < featurevec.x[i3]) {
						      mat.x[i3][i] = featurevec.x[i3]
						    }
						  }
              
						}
					}
				}
			}
		  		
    }

		for i =0, $o2.count-1	{$o2.o(i).set_organism_fitness_vec(mat.getrow(i))}
	}

	proc define_step_stimulus(/*Step amp*/)	{
			tf = $4
			svec.resize(0)
			stvec.resize(0)
			ts = $2
			tdur = $3
			amp = $1
			svec.append(0)
			stvec.append(ts)
			svec.append(amp)
			stvec.append(ts)
			svec.append(amp)
			stvec.append(ts+tdur)
			svec.append(0)
			stvec.append(ts+tdur)
			svec.append(0)
			stvec.append(tf)
			stim1.del = 0
			stim1.dur = tf
	}

	proc define_ramp_stimulus(/*Ramp peak*/)	{
			tf = 3000
			svec.resize(0)
			stvec.resize(0)
			ts = 700
			tdur = 2000
			amps = 0
			ampe = $1
			svec.append(0)
			stvec.append(ts)
			svec.append(amps)
			stvec.append(ts)
			svec.append(ampe)
			stvec.append(ts+tdur)
			svec.append(0)
			stvec.append(ts+tdur)
			stim1.del = 0
			stim1.dur = tf
	}

	/*****************************************************************
	/* Function that does a simple transformation on the error matrix
	/* The error matrix is a (stim numxfeature num) matrix.
	/* The following transformations are implemented
	/* 0 - sum by columns i.e. sum seperately each feature over stimuli
	/* 1 - sum by rows i.e. sum seperately each stimuli over features
	*****************************************************************/

	obfunc old_finalize_fitness(/*Full error matrix, transformation type*/)	{local i,j localobj final_error_vec

		if ($2 == 0)	{
			final_error_vec = new Vector($o1.ncol)
			for (i=0;i<$o1.ncol;i=i+1)	{final_error_vec.x[i] = $o1.getcol(i).sum}
		}
		if ($2 == 1)	{
			final_error_vec = new Vector($o1.nrow)
			for (i=0;i<$o1.nrow;i=i+1)	{final_error_vec.x[i] = $o1.getrow(i).sum}
		}
		/*print "got matrix "
		$o1.printf()
		print "returned error vec"
		final_error_vec.printf()*/

		return final_error_vec
	}

	proc set_trace_save()	{save_trace = $1}

	proc new_inject_set_parameters(/*Parameter vector,config object*/)	{local value,cross localobj assign_vec
		assign_vec = $o1
		cross = 0
		gacell.hardcode_biophys()

		for (i=0;i<$o2.get_pol().count;i=i+1)	{
			cross = variable_to_channel_vector.x[i]
			distrib_type = distribution_type_vector.x[cross]
			param_vector = channel_distribution_parameter_list.o(cross)
			value = assign_vec.x[i]

			csuffix =  $o2.get_pol().o(i).get_string_parameter("ChannelSuffix").s
			ccellsection =  $o2.get_pol().o(i).get_string_parameter("CellSection").s
			cparameter =  $o2.get_pol().o(i).get_parameter_name.s
			distribution_calc(ccellsection,cparameter,csuffix,value,param_vector,distrib_type)
		}
// 		print "Done: new_inject_set_parameters()"
	}

	proc distribution_calc()	{local dist
		if (strcmp("all",$s1) == 0)     {$s1 = ""}
		if (strcmp("none",$s3) != 0)	{
			sprint(s_1,"%s_%s",$s2,$s3)
		} else	{
		  sprint(s_1,"%s",$s2)
    }
		base_value = $4
		par_vector = $o5
		gacell.distribute_channels($s1,s_1,$6,$o5.x[0],$o5.x[1],$o5.x[2],$o5.x[3],base_value)
	}

	func calculate()	{local value
		if ($1==0)	{value = $o2.x[0] + $3*$o2.x[1]}
		if ($1==1) {value = $o2.x[0] + ($o2.x[1]/(1+exp(($3-$o2.x[2])/$o2.x[3])))}
		return value
	}

	proc create_framework()	{
		exp_dt = 0.25
		set_stim()
		insert_mechanisms(mc.get_insertion_list)
	}

	obfunc pass_variable_to_channel_vector() {return variable_to_channel_vector}

	proc set_stim()	{
		svec = new Vector()
		stvec = new Vector()
		sec_r	{
			stim1 = new IClamp(0.5)
			neg_stim = new IClamp(0.5)
			neg_stim.del = 0
		}
	}

	proc insert_mechanisms()	{local i
		for (i=0;i<$o1.count;i=i+1)	{execute($o1.o(i).s)}
	}

	proc clear_trace_lists()	{
		sim_volt_list.remove_all()
		sim_time_list.remove_all()
//		sim_volt_list2.remove_all()
//		sim_volt_list3.remove_all()
	}

	obfunc pass_sim_volt()	{return sim_volt_list}
//	obfunc pass_sim_volt2()	{return sim_volt_list2}
//	obfunc pass_sim_volt3()	{return sim_volt_list3}
	obfunc pass_sim_time()	{return sim_time_list}

endtemplate OrganismEvaluator
