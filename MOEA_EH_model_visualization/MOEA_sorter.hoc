begintemplate ParetoSorter
	
	objref mat,pc,ps, front_list,dom_ind_vec,take_vec
	public set_fronts,new_set_fronts,parallel_set_fronts,set_mat_row,print_mat,get_mat,set_mat_size,set_mat
	public evaluate_single_dominance,mat,receive_mat,p,new_evaluate_fitness_matrix
	public nested_parallel_set_fronts, mat2vec, parallel_evaluate_single_dominance, autoref	
	public rank_solutions

	proc init()	{	
		orgn = 1
		objn = 1
		min_error = 1e6
		stim_num = 1

		pc = $o1
		
		mat = new Matrix(1,1)
		front_list = new List()
	}
	
	proc autoref()	{ps = $o1}
	proc p()	{print "Hello"}
	proc set_mat()	{mat = $o1}
	proc set_mat_size()	{mat.resize($1,$2)}
	proc set_mat_row()	{mat.setrow($1,$o2)}
	proc print_mat()	{mat.printf}
	obfunc get_mat()	{return mat}
	
	proc receive_mat()	{local i,orgn,objn localobj vec
		//print "receive mat in sorter evoked"
		orgn = $2
		objn=$3
		vec = new Vector(orgn)
		mat.resize($2,$3)
		for (i=0;i<orgn;i=i+1)	{
			mat.setrow(i,$o1.c(i*objn,((i+1)*objn)-1))
			vec.x[i] = mat.getrow(i).sum
		}
		min_error = vec.min
		//print "min error is ", min_error
		pc.post("check")
		//print "\n posted \n"
		//mat.printf()
	}
	
	/************ 
	// Function that ranks the solutions of a given objective matrix for domination.
	// Returns a vector that contains the number of solutions that dominate each solution 
	************/

	//obfunc rank_solutions(/*Objective matrix*/)	{local i, orgn, objn localobj rvec, trvec, take_vec
        	//print "Started solution ranking"	
		/*orgn = $o1.nrow
        	objn = $o1.ncol
		
		rvec = new Vector(orgn)
		trvec = mat2vec($o1)
		take_vec = new Vector()
		
		for i=0, orgn-1	{pc.submit(ps,"rank_single_solution",trvec,orgn,objn,i)}
		
		while (id = pc.working) {
			pc.take(id)
			take_vec = pc.upkvec()
			rvec.x[take_vec.x[0]] = take_vec.x[1]
		}
		return rvec 
	}*/
	
	/************ 
	// Function that ranks a single solution within a given objective matrix
	// passed as a vector in terms of domination
	************/
	
	func rank_single_solution()	{local i,id,r,orgn,objn localobj gvec,pvec,mat
		id = hoc_ac_
		gvec = new Vector(2)	
		////// Perform Calculation
		orgn = $2
		objn = $3

		mat = new Matrix(orgn,objn)

		for (i=0;i<orgn;i=i+1)	{
			mat.setrow(i,$o1.c(i*objn,((i+1)*objn)-1))
		}
		
		r = rank_domination(mat,$4)
		///////
		gvec.x[0] = $4
		gvec.x[1] = r
			
		pc.post(id,gvec)
		return r
	}
	
	/************ 
	// Function that ranks a single solution within a given objective matrix
	************/
	
	func rank_domination()	{local r,i,ind localobj vec
		//$o1.printf()
		r = 0
		vec = $o1.getrow($2)
		//print "Number of rows is ", $o1.nrow
		for (i=0; i<$o1.nrow;i=i+1)	{
			//print "i is ", i
			if ($o1.getrow(i).sub(vec).max < 0 )	{r=r+1}
		}
		//print "Solution ", $2, " was dominated by ", r, " solutions"
		return r
	}
	
	obfunc nested_parallel_set_fronts()    {local i,j,par_cut,orgn,objn,a localobj rem_vec,ind_vec,trvec
        	par_cut = 40 //Number of organisms left to switch to single sorting
        	front_list.remove_all()
		stim_num = $2
		//print "In sorter Stim_num is ", stim_num
		if ($2==1)	{
        		single_objective_evaluate_fitness_matrix($o1)
        		return front_list
        	}
        	
        	//par_cut = 150
        	orgn = $o1.nrow
        	objn = $o1.ncol
        	//print "Transforming mat to vec"
        	trvec = mat2vec($o1)
        	//print "Transfering to slaves"
        	//pc.context(ps,"mat.resize()",orgn,objn)
        	//pc.context(ps,"set_mat_size",orgn,objn)
        	//proc set_context()    {ps.receive_mat($o1,$2,$3)}
        	a = pc.time
		//*****HOW DO I REPLACE THIS CALL
        	pc.context(ps,"receive_mat",trvec,orgn,objn)
        	//*****
		receive_mat(trvec,orgn,objn)
        	for i=0, pc.nhost-2 {
			pc.take("check")
			//print "got back"
		}
		
		//print "Nhost is ", pc.nhost
  
        	//print "Transfered"
        	//print "Transferal of context took ", pc.time - a
        	
        	ind_vec = new Vector($o1.nrow())
        	ind_vec.indgen()
        	j = 0
        	a = pc.time
		while (ind_vec.size>0)  {
                	if (ind_vec.size>par_cut)       {
                		rem_vec = parallel_evaluate_single_front(ind_vec)
                	}       else    {
                		rem_vec = parallel_evaluate_single_front(ind_vec)
                        	//rem_vec = new_evaluate_fitness_matrix(mat,ind_vec)
                	}
                	//print "Vector returned from parallel evaluate is"
                	//rem_vec.printf()
                	for (i=0;i<rem_vec.size();i=i+1)        {ind_vec.remove(ind_vec.indwhere("==",rem_vec.x[i]))}
                	//print "Ind vec after removal is "
                	//ind_vec.printf()
                	front_list.append(rem_vec.c)
                	j = j + 1
                	if (j>$o1.nrow) {
                        	print "reached pop size number of fronts"
                        	break
                	}
        	}

        	print "Calculation of fronts took ", pc.time-a
        	//print "Front list count is ", front_list.count
       		//print "Exited parallel set fronts successfuly"

        	return front_list
	}
	
	// Function to sort population if there is only a single objective
	// No point in doing pareto fronts then...
	
	proc single_objective_evaluate_fitness_matrix()	{local i,orgn localobj vec, svec
		orgn = $o1.nrow
		vec = new Vector(orgn)
		svec = new Vector()
		for i=0, orgn-1	{
			vec.x[i]=$o1.getrow(i).sum() //Sum isnt necessary but just in case
		}
		svec = vec.sortindex()
		front_list.append(svec.c(0,int(orgn/2)))
		front_list.append(svec.c(int(orgn/2)+1))
	}
	
	obfunc parallel_evaluate_single_front()	{local i localobj ind_vec
		//print "Started parallel evaluate single front"
		ind_vec = $o1.c
		dom_ind_vec = new Vector()
		set_flag = 0
		for (i=0;i<ind_vec.size;i=i+1)	{pc.submit(ps,"parallel_evaluate_single_dominance",ind_vec,i,stim_num)}
		while (id = pc.working) {
			pc.take(id)
			take_vec = pc.upkvec()
			
			if (take_vec.x[1] == 0)	{dom_ind_vec.append(ind_vec.x[take_vec.x[0]])}
		}
		dom_ind_vec = dom_ind_vec.sort
		//print "dom vec is"
		//dom_ind_vec.printf
		return dom_ind_vec.c
	}
	
	func parallel_evaluate_single_dominance()	{local f,dom_flag localobj tag_vec
		f = pc.time
		stim_num = $3
		//print "Started parallel evaluate single dominance in sorter"
		//print "started evaluation in comp ", pc.id, "on org ", $2
		tag_vec = new Vector(2)
		id = hoc_ac_
		dom_flag = evaluate_single_dominance($o1,$2)
		//print "dom flag is ", dom_flag
		tag_vec.x[0] = $2
		tag_vec.x[1] = dom_flag
		
		pc.post(id,tag_vec)
		g = g + (pc.time-f)
		return dom_flag
	}
	
	func evaluate_single_dominance()	{local dom_flag,j
		//print "started evaluate in sorter"
		//print "matrix row number is ", mat.nrow
		for (j=0;j<$o1.size;j=j+1)	{
				answer = check_restricted_dominance(mat.getrow($o1.x[j]),mat.getrow($o1.x[$2]))
				if (answer == 1)	{return 1}
			}
		return 0
	}
	
	obfunc mat2vec()        {local i,orgn,objn localobj avec
        	orgn = $o1.nrow
        	objn = $o1.ncol
        	avec = new Vector(orgn*objn)
        	for (i=0;i<orgn;i=i+1)  {
                	avec.copy($o1.getrow(i),objn*i)
        	}
        	//avec.printf
        	//print "Mat transformed"
        	return avec
	}


	obfunc parallel_set_fronts()	{local i,j localobj rem_vec,ind_vec,front_list
		front_list = new List()
		ind_vec = new Vector(mat.nrow())
		ind_vec.indgen()
		j = 0
		while (ind_vec.size>0)	{
			rem_vec = parallel_evaluate_fitness_matrix(ind_vec)
			//print "Vector returned from new evaluate is"
			//rem_vec.printf()
			for (i=0;i<rem_vec.size();i=i+1)	{ind_vec.remove(ind_vec.indwhere("==",rem_vec.x[i]))}
			//print "Ind vec after removal is "
			//ind_vec.printf()
			front_list.append(rem_vec.c)
			j = j + 1
			if (j>mat.nrow)	{
				print "reached pop size number of fronts"
				break
			}
		}
	return front_list
	}
	

	/*obfunc new_set_fronts()	{local i,j localobj rem_vec,ind_vec,front_list
		front_list = new List()
		ind_vec = new Vector($o1.nrow())
		ind_vec.indgen()
		j = 0
		while (ind_vec.size>0)	{
			rem_vec = new_evaluate_fitness_matrix($o1,ind_vec)
			//print "Vector returned from new evaluate is"
			//rem_vec.printf()
			for (i=0;i<rem_vec.size();i=i+1)	{ind_vec.remove(ind_vec.indwhere("==",rem_vec.x[i]))}
			//print "Ind vec after removal is "
			//ind_vec.printf()
			front_list.append(rem_vec.c)
			j = j + 1
			if (j>$o1.nrow)	{
				print "reached pop size number of fronts"
				break
			}
		}
	return front_list
	}*/
	
	/*obfunc new_evaluate_fitness_matrix()	{local i,j,answer,dom_flag,set_flag localobj dom_ind_vec,fit_mat,ind_vec
		fit_mat = $o1
		ind_vec = $o2.c
		//print "evaluated matrix is"
		//fit_mat.printf("%-6.6g ")
		dom_ind_vec = new Vector()
		set_flag = 0

		for (i=0;i<ind_vec.size;i=i+1)	{
			dom_flag = 0
			for (j=0;j<ind_vec.size;j=j+1)	{
				answer = check_dominance(fit_mat.getrow(ind_vec.x[j]),fit_mat.getrow(ind_vec.x[i]))
				//answer = check_weak_dominance(fit_mat.getrow(j),fit_mat.getrow(i))
				//answer = check_restricted_dominance(fit_mat.getrow(j),fit_mat.getrow(i))
				if (answer == 1)	{
					//print i," is dominated by ", j
					dom_flag = 1
					break
				}
			}
			if (dom_flag == 0)	{dom_ind_vec.append(ind_vec.x[i])}
		}
		//print "undominated indices are"
		//dom_ind_vec.printf()
		if (dom_ind_vec.size == 0)	{
			print "zero size front was found"
			fit_mat.printf()
		}
		return dom_ind_vec
	}*/
	
	obfunc set_fronts()	{local i,j localobj temp_mat,rem_vec,ind_vec,temp_vec,front_list
		temp_mat = new Matrix()
		front_list = new List()
		ind_vec = new Vector($o1.nrow())
		ind_vec.indgen()
		j = 0

		while (ind_vec.size>0)	{
			//temp_mat = new Matrix(ind_vec.size,$2)
			temp_mat.resize(ind_vec.size,$2)
			for (i=0;i<ind_vec.size;i=i+1)	{temp_mat.setrow(i, $o1.getrow(ind_vec.x[i]))}
			//print "temp_mat is"
			//temp_mat.printf()
			//ind_vec.indgen()
			temp_vec = evaluate_fitness_matrix(temp_mat)
			rem_vec = new Vector(temp_vec.size)
			for (i=0;i<temp_vec.size();i=i+1)	{rem_vec.x[i] = ind_vec.x[temp_vec.x[i]]}
			//print "Indeces of front ", j, " are:"
			//rem_vec.printf()
			for (i=0;i<temp_vec.size();i=i+1)	{ind_vec.remove(ind_vec.indwhere("==", rem_vec.x[i]))}
	//		print "ind_vec is"
	//		ind_vec.printf()
			front_list.append(rem_vec.c)
			j = j + 1
			if (j>$o1.nrow)	{
				print "reached pop size number of fronts"
				break
			}
		}
	return front_list
	}

	/*obfunc evaluate_fitness_matrix()	{local i,j,answer,dom_flag,set_flag localobj dom_ind_vec,fit_mat
		fit_mat = $o1
		//print "evaluated matrix is"
		//fit_mat.printf("%-6.6g ")
		dom_ind_vec = new Vector()
		set_flag = 0

		for (i=0;i<fit_mat.nrow();i=i+1)	{
			dom_flag = 0
			for (j=0;j<fit_mat.nrow();j=j+1)	{
				answer = check_dominance(fit_mat.getrow(j),fit_mat.getrow(i))
				//answer = check_weak_dominance(fit_mat.getrow(j),fit_mat.getrow(i))
				//answer = check_restricted_dominance(fit_mat.getrow(j),fit_mat.getrow(i))
				if (answer == 1)	{
					//print i," is dominated by ", j
					dom_flag = 1
					break
				}
			}
			if (dom_flag == 0)	{dom_ind_vec.append(i)}
		}
		//print "undominated indices are"
		//dom_ind_vec.printf()
		if (dom_ind_vec.size == 0)	{
			print "zero size front was found"
			fit_mat.printf()
		}
		return dom_ind_vec
	}*/
	
	func check_dominance()	{local i,j,answer
		answer = 0
		better = 0
		for (i=0;i<$o1.size();i=i+1)	{
			if ($o2.x[i]<$o1.x[i])	{return 0}	else	{if($o2.x[i]>$o1.x[i])	{better = 1}}
		}
		if (better == 1)	{answer = 1}
		return answer
	}

	func check_weak_dominance()	{local i,j,answer,worse
		answer = 0
		better = 0
		worse = 0
		for (i=0;i<$o1.size();i=i+1)	{
			if ($o2.x[i]<$o1.x[i]) {worse = 1}	else	{if($o2.x[i]>$o1.x[i])	{better = 1}}
		}
		if (better == 1 && worse == 0)        {answer = 1}
		if ($o1.sum<(2*min_error) && $o2.sum>(2*min_error))	{
			if (answer == 0)	{
				/*print "answer is ", answer
				print "better is ", better
				print "worse is ", worse
				print "Only weakly dominated"
				print "Vector one"
				$o1.printf()
				print "Vector two"
				$o2.printf()*/
			}
			answer = 1
		}
		return answer
	}
	
	func check_restricted_dominance()	{local i,j,answer,worse,bound
		answer = 0
		better = 0
		worse = 0
		bound = 4*stim_num
		
		for (i=0;i<$o1.size();i=i+1)	{
			if ($o2.x[i]<$o1.x[i]) {worse = 1}	else	{if($o2.x[i]>$o1.x[i])	{better = 1}}
		}
		if (better == 1 && worse == 0)        {answer = 1}
		if ($o1.sum<(2*min_error) && $o2.sum>(2*min_error))	{
			if (answer == 0)	{num_weak = num_weak + 1}
			answer = 1
		}
		if (($o1.indwhere(">",bound) == -1) && ($o2.indwhere(">",bound) != -1) && ($o1.sum<(2*min_error)))	{
			if (answer == 0)	{num_restricted = num_restricted + 1}
			answer = 1
		}
		return answer
	}
	
endtemplate ParetoSorter

