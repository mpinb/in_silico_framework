/*****************************************************
*Template for genetic algorithm in NEURON
*Author: Shaul Druckmann, Hebrew U, May 2006
*
*Modified by: Etay Hay, Hebrew University of Jerusalem, 2011
*****************************************************/

begintemplate Population
	objref org_list,fitness_vector,cross_vector
	objref breeding_vector,share_vector,elite_vector,pop_ran
	objref evolution_vector, genome_matrix, breed_matrix
	objref fitness_matrix, front_list,front_share_list,fitness_span_matrix
	objref parent_genome_matrix, parent_fitness_matrix
	objref offspring_genome_matrix, offspring_fitness_matrix
	objref joint_genome_matrix, joint_fitness_matrix, org_genome_matrix
	objref elite_fitness_matrix,elite_genome_matrix
	objref pass_genome_vector, take_vec
	objref tag_vec,receive_vec
	objref ps, calculator
	objref pc, pop, evaluator, mc
	objref raw_error_matrix_list, stimulus_feature_list
	
	strdef pop_file_name

	public org_list,cross_vector//fitness_vector
	public append_org,mutate_population,print_pop, print_error
	public select_cross_over,even_select,cross_population
	public print_fitness,evaluate_population,clear_list//set_fitness_vector,
	public breed_parent_population,breed_parent_population_by_front,evolve_population
	public pass_maximal_fitness,pass_maximal_fitness_index
	public pass_minimal_fitness,pass_minimal_fitness_index
	public print_elite_vector,print_population_count
	public load_population_from_file, load_error_from_file
	public fitness_matrix, breed_matrix, permutate_population
	public combine_joint_population, sum_breed_parent_population_by_front
	public sum_combine_joint_population, replicate_population
	public new_combine_joint_population, ps, update_matrices
	public joint_genome_matrix,joint_fitness_matrix,parallel_combine_joint_population
	public auto_ref, evaluate_population, setup_error_structure
	public get_org_list, rank_combine_joint_population
	public update_parent_selection, front_combine_joint_population
	public set_full_elite, assign_population
	proc init()	{
		
		sprint(pop_file_name,"%s/%s/pop_dump.txt",$s1,$s2)
		genome_matrix = $o3
		pc = $o4
		evaluator = $o5
		calculator = $o6
		mc = $o7
		
		pop_size =  mc.get_numerical_parameter("PopulationSize")
		objective_num = mc.get_objective_num()
		stim_num = mc.get_stimulus_num()
		p_cross = mc.get_numerical_parameter("PCross")
		max_generation = mc.get_numerical_parameter("MaxGeneration")
		regen_frac = mc.get_numerical_parameter("RegenerationFraction")
		
		min_error = 1e6
		
		pop_ran = new Random(mc.get_numerical_parameter("BaseSeed"))
		org_list = new List()
		front_list = new List()
		front_share_list = new List()

		fitness_matrix = new Matrix(pop_size,objective_num)
		parent_fitness_matrix = new Matrix(pop_size,objective_num)
		parent_genome_matrix = new Matrix(pop_size,genome_matrix.nrow)
		offspring_fitness_matrix = new Matrix(pop_size,objective_num)
		offspring_genome_matrix = new Matrix(pop_size,genome_matrix.nrow)
		org_genome_matrix = new Matrix(pop_size,genome_matrix.nrow)
		fitness_span_matrix = new Matrix(objective_num,2)
		breed_matrix = new Matrix(pop_size,genome_matrix.nrow)
		joint_fitness_matrix = new Matrix(pop_size*2,objective_num)
		joint_genome_matrix = new Matrix(pop_size*2,genome_matrix.nrow)
		elite_fitness_matrix = new Matrix(objective_num + 1,objective_num)
		elite_genome_matrix = new Matrix(objective_num + 1,genome_matrix.nrow)

		for (i=0;i<objective_num;i=i+1)	{
			fitness_span_matrix.x[i][1] = 20
		}

		fitness_vector = new Vector(pop_size)
		cross_vector = new Vector()
		breeding_vector = new Vector(pop_size)
		share_vector = new Vector(pop_size)
		evolution_vector = new Vector(pop_size)
		elite_vector = new Vector(objective_num+1)
		pass_genome_vector = new Vector()
		take_vec = new Vector()
		tag_vec = new Vector()
		receive_vec = new Vector()
		q = int(pop_size/10)
		if (q == 0)	{q=1}

		phenotype_sigma_share = 0.5/(q^(1/genome_matrix.nrow))
		objective_sigma_share = 0.5/(q^(1/fitness_span_matrix.nrow))
	}
	

	/*****************************************************
	*Function that creates a vector of the organisms that were
	*bread and will be the basis for the population of the next generation
	*Input:
	*Output:
	*****************************************************/

	proc breed_parent_population()	{local i, generation
		generation = $1
		//print "began breeding parent population"
		set_fitness_matrix()
		set_org_genome_matrix()
		//print "fitness matrix is "
		//fitness_matrix.printf("%f ")
		print "calculating parent Pareto fronts"
		front_list = set_fronts(fitness_matrix,objective_num)
		for (i=0;i<front_list.count;i=i+1)	{
			//print "front is"
			//front_list.o(i).printf()
			front_share_list.append(calculate_pheno_share_vector(front_list.o(i), org_genome_matrix))
		}
		set_front_breeding_vector()
		set_stochastic_remainder_roulette_breeding_vector(evolution_vector)
		front_list.remove_all()
		front_share_list.remove_all()

		for (i=0;i<pop_size;i=i+1)	{
			parent_genome_matrix.setrow(i,org_list.o(i).pass_genome())
		}
		for (i=0;i<pop_size;i=i+1)	{
			parent_fitness_matrix.setrow(i,org_list.o(i).pass_fitness_vec())
		}

		//print "parent genome matrix is "
		//parent_genome_matrix.printf("%f ")
		//print "parent fitness matrix is "
		//parent_fitness_matrix.printf("%f ")

		for (i=0;i<pop_size;i=i+1)	{
			breed_matrix.setrow(i,org_list.o(breeding_vector.x[i]).pass_genome())
		}
		//dump_population()
		for (i=0;i<pop_size;i=i+1)	{
			org_list.o(i).set_genome(breed_matrix.getrow(i))
		}
		evolve_population(generation)
	}

	proc replicate_population()	{local i,generation
		generation = $1
		//update_parent_selection()
		//set_full_elite()
		
		//breeding_vector = rank_tournament($o2)
		evolve_population(generation)
		//if ($1>20)	{print "BREEDING"	set_offspring(breeding_vector)}
		//insert_elite()
	}

	proc update_offspring_matrix()	{local i
		for (i=0;i<pop_size;i=i+1)	{
			offspring_genome_matrix.setrow(i,org_list.o(i).pass_genome())
			offspring_fitness_matrix.setrow(i,org_list.o(i).pass_fitness_vec())
		}
		//print "offspring fitness matrix"
		//offspring_fitness_matrix.printf()
	}
	
	proc update_parent_selection()	{local i
		for (i=0;i<pop_size;i=i+1)	{
			parent_genome_matrix.setrow(i,org_list.o(i).pass_genome().c)
			parent_fitness_matrix.setrow(i,org_list.o(i).pass_fitness_vec().c)
		}
		//print "offspring fitness matrix"
		//offspring_fitness_matrix.printf()
	}
	
	proc update_matrices()		{local i,j
		for (i=0;i<pop_size;i=i+1)	{
			joint_genome_matrix.setrow(i,parent_genome_matrix.getrow(i).c)
			joint_fitness_matrix.setrow(i,parent_fitness_matrix.getrow(i).c)
		}
		for (i=pop_size;i<(pop_size*2);i=i+1)	{
			j = i - pop_size
			joint_genome_matrix.setrow(i,org_list.o(j).pass_genome().c)
			joint_fitness_matrix.setrow(i,org_list.o(j).pass_fitness_vec().c)
		}

		//print "Joint matrices updated"
		//joint_fitness_matrix.printf()
	}

	obfunc rank_tournament()	{local i,b,va,vb localobj bv
		bv = new Vector(pop_size)
		for i=0,pop_size-1	{
			va = $o1.x[i]
			pop_ran.discunif(0,pop_size-1)
			b = pop_ran.repick()
			vb = $o1.x[b] 
			if (va<=vb) {bv.x[i] = i} else {bv.x[i] = b}
		}
		//print "Breeding Vector is"
		//bv.printf()
		return bv
	}
	
	proc set_offspring()	{local i
		for i=0, $o1.size-1	{
			org_list.o(i).set_genome(parent_genome_matrix.getrow($o1.x[i]).c)
			org_list.o(i).set_organism_fitness_vec(parent_fitness_matrix.getrow($o1.x[i]).c)
			if (i==pop_size)	{return}
		}
		
	}
	proc combine_joint_population()	{local i,j,k,r,ind,max_front,cur_front,s localobj spread_vec,sort_vec
		sort_vec = new Vector()
		spread_vec = new Vector()

		/*print "Calculating parent and children fronts"

		for (i=0;i<pop_size;i=i+1)	{
			joint_genome_matrix.setrow(i,parent_genome_matrix.getrow(i))
			joint_fitness_matrix.setrow(i,parent_fitness_matrix.getrow(i))
		}
		for (i=pop_size;i<(pop_size*2);i=i+1)	{
		j = i - pop_size
			joint_genome_matrix.setrow(i,org_list.o(j).pass_genome())
			joint_fitness_matrix.setrow(i,org_list.o(j).pass_fitness_vec())
		}

		front_list = set_fronts(joint_fitness_matrix,objective_num)

		print "joint fronts calculated"*/

		//for (i=0;i<front_list.count;i=i+1)	{
		//	print "front number ", i, "has a size of ", front_list.o(i).size
		//	//front_list.o(i).printf()
		//}

		update_fronts()

		i = 0
		max_front = -1

		while (i<pop_size) {
			max_front = max_front + 1
			i = i + front_list.o(max_front).size()
		}

		print "Parent and children max front with replication is ", max_front
		ind = 0
		k = 0
		//print "K IS ", k
		while (k<max_front) {
			//print "in front ", k, " The errors were "
			for (i=0;i<(front_list.o(k).size());i=i+1)	{
				j = front_list.o(k).x[i]
				//joint_fitness_matrix.getrow(j).printf()
				org_list.o(ind).set_genome(joint_genome_matrix.getrow(j))
				ind = ind + 1
			}
			//print "GOING FRONT BY FRONT"
			k = k + 1
			//print "in front ", k, "ind was ", ind
		}
		//print "Before entering last front we are at front ", k, "Max front is ", max_front

		cur_front = max_front
		while (ind<pop_size) {
			if (cur_front<front_list.count)	{
				//print "entering last fronts"
				ind = assign_last_front(front_list.o(cur_front),joint_genome_matrix,cur_front,ind)
				cur_front = cur_front + 1
				//print "in front ", cur_front, "ind is ", ind
				if (cur_front >= front_list.count)	{
					print "REACHED CAPACITY"
					cur_front = 0
				}
			}
		}

		print  "last front assigned was ", cur_front
		insert_elite()

		front_list.remove_all()
		front_share_list.remove_all()
	}

	proc new_combine_joint_population()	{local i,j,k,r,ind,max_front,cur_front,s,rep  localobj spread_vec,sort_vec,max_front_vec,rep_vec,clean_vec,temp_vec

		num_weak = 0
		num_restricted = 0
		
		sort_vec = new Vector()
		spread_vec = new Vector()
		
		update_fronts()
		
		rep_vec = new Vector(front_list.count)
		rep_vec.fill(1)
		//CHANGED TO ELIMINATE REPETITION
		//ind = 0
		ind = front_list.o(0).size*2
		k = 0
		//if  (front_list.o(0).size < (pop_size/4))	{
		while (ind<(pop_size/2))	{
			rep_vec.x[k] = 2
			ind = ind + front_list.o(k+1).size*2
			k = k + 1
		}
			print "final doubled front was ", k
		//}
		//if (rep_vec.size>1)	{rep_vec.x[1] = 2}

		ind = 0
		k = 0

		while (ind<pop_size) {
			if (k<front_list.count)	{
				rep = 0
				clean_vec = clean_front(front_list.o(k),joint_genome_matrix)
				sort_vec.resize(clean_vec.size)
				sort_vec.indgen()
				for (rep=0;rep<rep_vec.x[k];rep=rep+1)	{
					if ((ind+(front_list.o(k).size*rep_vec.x[k]))>pop_size)	{
						//temp_vec = calculate_front_share_vector(clean_vec,joint_fitness_matrix)
						temp_vec = calculate_pheno_share_vector(clean_vec,joint_genome_matrix)
						sort_vec = temp_vec.sortindex
						/*print "clean vec size was ", clean_vec.size
						clean_vec.printf()
						print "sort vec size was", sort_vec.size
						sort_vec.printf()
						print "temp_vec was"
						temp_vec.printf()*/
					}
					for (i=0;i<clean_vec.size;i=i+1)	{
						//j = clean_vec.x[i]
						j = clean_vec.x[sort_vec.x[i]]
						org_list.o(ind).set_genome(joint_genome_matrix.getrow(j))
						org_list.o(ind).set_organism_fitness_vec(joint_fitness_matrix.getrow(j))
						ind = ind + 1
						if (ind >= pop_size)	{break}
					}
					if (ind >= pop_size)	{break}
				}
				k = k + 1
				if (ind >= pop_size)	{break}
			}
		}

		print "last front that was reached was ", k
		print "number of dominations by weak dom is ", num_weak
		print "number of dominations by restricted dom is ", num_restricted
		/*update_parent_selection()

		insert_elite()*/

		insert_elite()
		update_parent_selection()

		front_list.remove_all()
		front_share_list.remove_all()
	}
	
	obfunc rank_combine_joint_population(/*Ranking vector*/)	{local i,j,u localobj rvec,ivec, dvec,uvec, vec
		rvec = $o1.c
		//print "rvec should be"
		//rvec.printf()
		vec = new Vector(rvec.size)
		vec.indgen()
		dvec = rvec.indvwhere("==",0)
		uvec = get_unique(dvec)
		print "Number of unique undominated solutions is ", uvec.size
		print "Undominated solutions:"
		dvec.printf()
		print "Unique undominated solutions:"
		uvec.printf()
		for i=0, dvec.size-1	{
			j = vec.indwhere("==",dvec.x[i])
			//print "j was ", j, "looking for ",dvec.x[i]
			vec.remove(j)
		}
		/*vec = new Vector(pop_size)
		vec.indgen
		calculate_crowding_distance(vec, joint_fitness_matrix.c*/
		assign_first_front(uvec)
		rvec = full_sort_ranks($o1.c)
		if (uvec.size<pop_size)	{assign_subsequent_fronts(uvec.size,rvec)}

		//set_full_elite()
		//insert_elite()
		//update_parent_selection()

		//front_list.remove_all()
		//front_share_list.remove_all()
		return rvec
	}	
	
	obfunc front_combine_joint_population(/*front list*/)	{local i,j,k localobj vec, cvec, ovec, svec,nvec,avec
		vec = new Vector(joint_genome_matrix.nrow())
		vec.indgen
		cvec = calculate_crowding_distance(vec, joint_fitness_matrix.c) //CHANGE 8.2
		//cvec = calculate_crowding_distance(vec, joint_genome_matrix.c)
		svec = cvec.c.sub(cvec.max).abs.sortindex
		//print "Sorted crowding distance is "
		//svec.printf()
		i = 0
		ovec = new Vector(pop_size)
		while (i<pop_size-1)	{
			for j=0, $o1.count-1	{
				if (j==0)	{
					
				}
				vec = get_unique($o1.o(j))
				//print "front ", j, " has ", vec.size, " unique elements"
				if (j==0)	{print vec.size, " unique solutions in first front"}
				if (i+vec.size<=pop_size)	{
					for k=0, vec.size-1	{
						//print "assigned to org num ", i, " org ", vec.x[k], "from front ", j
						ovec.x[i] = vec.x[k]
						i = i + 1
					} 
				}	else	{
					rn = pop_size-i
					nvec = new Vector()
					nvec.index(cvec,vec)
					//print "full vec is "
					//vec.printf()
					//print "Relevant crowding distances are "
					//nvec.printf()
					avec = new Vector()
					avec = nvec.c.sub(nvec.max).abs.sortindex
					nvec.index(vec,avec)
					//print "Sorted by crowding organisms are:"
					//avec.printf()
					//print "Or:"
					//nvec.printf()
					//print "Crowding vec is "
					//cvec.printf()
					for k=0, rn-1	{
						//print "index is ", i, " and there are ", rn, "solutions left"
						//print "assigned to org num ", i, " org ", vec.x[k], "from front ", j
						ovec.x[i] = vec.x[k]
						i = i + 1
					}
					break
				}
			if (i>=pop_size)	{break}
			}
		}
		
		return ovec
	}
	
	obfunc calculate_crowding_distance(/*Organism indeces, Organism source matrix*/) {local i,j,a,bi,ceili,span localobj mat, cvec, fvec, svec,smat
		ceil = 1e3
		//$o1.printf()
		cvec = new Vector($o1.size)
		fvec = new Vector($o1.size)
		mat = new Matrix($o1.size,$o2.ncol)
		for i=0, $o1.size-1	{mat.setrow(i, $o2.getrow($o1.x[i]))}
		//print "IN CROWDING"
		//mat.printf()
		for i=0, $o2.ncol-1	{
			//svec = mat.getcol(i).sub(mat.getcol(i).max).abs.sortindex
			svec = mat.getcol(i).sortindex
			//svec.printf("%g ")
			a = mat.x[svec.x[0]][i]
			b = mat.x[svec.x[svec.size-1]][i]
			span = b-a
			// etay: added to avoid division by 0
			  if (span == 0) {span = 0.0001} 
			// end etay
			cvec.x[svec.x[0]] = cvec.x[svec.x[0]] + ceil
			//print "min has ", cvec.x[svec.x[0]]
			cvec.x[svec.x[svec.size-1]] = cvec.x[svec.x[svec.size-1]] + ceil
			//print "max has ", cvec.x[svec.x[svec.size-1]]
			//print "Max should be ", b, " Min should be ", a
			//print "Max index is ", svec.x[svec.size-1], " Min index is ", svec.x[0]
			for j=1, svec.size-2	{
				//print "for ", j, " index is = ", svec.x[j], "before was ",cvec.x[svec.x[j]]
				d = mat.x[svec.x[j+1]][i]-mat.x[svec.x[j-1]][i]
				d = d/span
				//print "d is ", d
				cvec.x[svec.x[j]] = cvec.x[svec.x[j]] + d	
			}
			//print "crowding vec in objective ", i, " is"
			//cvec.printf()
		}
		//print "crowding vec is"
		//cvec.printf()
		return cvec
	}
	
	obfunc get_unique(/*Undominated Vector*/)	{local i,j,u localobj dvec,uvec,vec
		dvec = $o1
		uvec = new Vector()
		vec = new Vector()
		u = 0
		if (dvec.size == 1)	{uvec.append(dvec.x[0])} else	{
			for i=0, dvec.size-2	{
				u = 0
				vec = joint_fitness_matrix.getrow(dvec.x[i])
				for j=i+1, dvec.size-1	{
					if (vec.eq(joint_fitness_matrix.getrow(dvec.x[j])) == 1)	{
						u = 1
						break
					}
				}
				if (u == 0)	{uvec.append(dvec.x[i])}
			}
		uvec.append(dvec.x[i])
		}
		return uvec
	}
	
	proc assign_population()	{local i
		if ($o1.size == pop_size)	{
		for i=0,$o1.size-1	{
			org_list.o(i).set_genome(joint_genome_matrix.getrow($o1.x[i]))
			org_list.o(i).set_organism_fitness_vec(joint_fitness_matrix.getrow($o1.x[i]))
			if (i==pop_size)	{break}
		}
		insert_elite()
		update_parent_selection()
		} else	{print "ASSIGN POPULATION CALLED WITHOUT FULL NUMBER"}
	}
	
	
	proc assign_first_front()	{local i
		for (i=0;i<$o1.size;i=i+1)	{
			org_list.o(i).set_genome(joint_genome_matrix.getrow($o1.x[i]))
			org_list.o(i).set_organism_fitness_vec(joint_fitness_matrix.getrow($o1.x[i]))
			if (i==pop_size)	{return}
		}
	}

	obfunc full_sort_ranks()	{local i localobj ivec, rvec, cvec
		ivec = $o1.c.sortindex()
		rvec = new Vector($o1.size)
		cvec = new Vector($o1.size)
		//print "Sorted rank is"
		//ivec.printf()
		for j=0, rvec.size()-1	{rvec.x[j] = ivec.indwhere("==", j)}
		for j=0, rvec.size()-1	{cvec.x[j] = rvec.indwhere("==", j)}
		return cvec
	}
	
	proc assign_subsequent_fronts()	{local i,j,ind,s localobj cvec, rvec
		i = $1
		cvec = new Vector($o2.size)
		if (i>= pop_size)	{return} //Double check
		rvec = $o2.c
		s = rvec.sum
		rvec.sub(pop_size).abs.div(rvec.sum)
		//print "Sum is ", rvec.sum
		//rvec.printf()
		for j=0, rvec.size-1	{cvec.x[j] = rvec.sum(0,j)}
		rvec = roulette(pop_size-$1,cvec.c)
		for j=0, rvec.size-1	{
			//print "Assigning organism ", i+j
			ind = rvec.x[j]
			org_list.o(i+j).set_genome(joint_genome_matrix.getrow(ind))
			org_list.o(i+j).set_organism_fitness_vec(joint_fitness_matrix.getrow(ind))
			
		}
	}
	
	proc assign_multiple_fronts()	{local i,j,ind
		if ($o1.size==1)	{
			print "Size 1 front"
			org_list.o(0).set_genome(joint_genome_matrix.getrow($o1.x[0]))
			org_list.o(0).set_organism_fitness_vec(joint_fitness_matrix.getrow($o1.x[0]))
		} else	{
		for i=0, $o1.size-1	{
			print "setting solution ", i, " in multiple assign to organism ", $o1.x[i]
			org_list.o(i).set_genome(joint_genome_matrix.getrow($o1.x[i]))
			org_list.o(i).set_organism_fitness_vec(joint_fitness_matrix.getrow($o1.x[i]))
		}
		i = $o1.size
		j = 0
		while (i<pop_size)	{
			if (j<$o2.size-1)	{
				org_list.o(i).set_genome(joint_genome_matrix.getrow($o2.x[j]))
				org_list.o(i).set_organism_fitness_vec(joint_fitness_matrix.getrow($o2.x[j]))
			} else {
				print "reservoir"
				ind = ind - $o2.size()
				org_list.o(i).set_genome(joint_genome_matrix.getrow($o2.x[j]))
				org_list.o(i).set_organism_fitness_vec(joint_fitness_matrix.getrow($o2.x[j]))
			}

			j = j + 1
			i = i + 1
			print "leftover index is ", j, " i is ", i," out of ", $o2.size
		}
		}
	}


	obfunc roulette(/*Normalized vector*/)	{local i,j,ind,num,total,flip localobj rvec
		rvec = new Vector($1)
		pop_ran.uniform(0,1)
		for i=0, $1-1	{
			flip = pop_ran.repick()
			rvec.x[i] = $o2.indwhere(">=",flip)
		}
		return rvec
	}

	proc parallel_combine_joint_population()	{local i,j,k,r,ind,max_front,cur_front,s,rep,x  localobj spread_vec,sort_vec,max_front_vec,rep_vec,clean_vec,temp_vec,front_list,tr_vec
		x = startsw()
		front_list = $o1
		
		num_weak = 0
		num_restricted = 0
		
		sort_vec = new Vector()
		spread_vec = new Vector()
		tr_vec = new Vector()

		//update_fronts()
		
		rep_vec = new Vector(front_list.count)
		rep_vec.fill(1)
		//CHANGED TO ELIMINATE REPETITION
		//ind = 0
		ind = front_list.o(0).size*2
		k = 0
		//if  (front_list.o(0).size < (pop_size/4))	{
		/*while (ind<(pop_size/2))	{
			rep_vec.x[k] = 2
			ind = ind + front_list.o(k+1).size*2
			k = k + 1
		}
			print "final doubled front was ", k
		//}
		//if (rep_vec.size>1)	{rep_vec.x[1] = 2}
		*/
		ind = 0
		k = 0

		while (ind<pop_size) {
			if (k<front_list.count)	{
				rep = 0
				clean_vec = clean_front(front_list.o(k),joint_genome_matrix)
				sort_vec.resize(clean_vec.size)
				sort_vec.indgen()
				//if (sort_vec.size>1)	{sort_vec = rvec(sort_vec.size)}
				//REPLACE INDEX VECTOR BY RANDOM PERMUTATION
				sort_vec = permute_vec(sort_vec.size)
				for (rep=0;rep<rep_vec.x[k];rep=rep+1)	{
					//if ((ind+(front_list.o(k).size*rep_vec.x[k]))>pop_size)	{sort_vec = rvec(sort_vec.size)}
					
					//if ((ind+(front_list.o(k).size*rep_vec.x[k]))>pop_size)	{
						//temp_vec = calculate_front_share_vector(clean_vec,joint_fitness_matrix)
						//temp_vec = calculate_pheno_share_vector(clean_vec,joint_genome_matrix)
						//sort_vec = temp_vec.sortindex
						/*print "clean vec size was ", clean_vec.size
						clean_vec.printf()
						print "sort vec size was", sort_vec.size
						sort_vec.printf()
						print "temp_vec was"
						temp_vec.printf()*/
					//}
					
					for (i=0;i<clean_vec.size;i=i+1)	{
						//j = clean_vec.x[i]
						j = clean_vec.x[sort_vec.x[i]]
						org_list.o(ind).set_genome(joint_genome_matrix.getrow(j))
						org_list.o(ind).set_organism_fitness_vec(joint_fitness_matrix.getrow(j))
						ind = ind + 1
						if (ind >= pop_size)	{break}
					}
					if (ind >= pop_size)	{break}
				}
				k = k + 1
				if (ind >= pop_size)	{break}
			}
		}
		print "last index was ", ind
		print "last front that was reached was ", k
		print "number of dominations by weak dom is ", num_weak
		print "number of dominations by restricted dom is ", num_restricted
		/*update_parent_selection()

		insert_elite()*/

		insert_elite()
		update_parent_selection()

		front_list.remove_all()
		front_share_list.remove_all()
		print "Creating next generation took ", startsw() - x
	}
	
	obfunc permute_vec()   {local i,length localobj per_vec,ro
		if ($1==0)	{
			per_vec = new Vector()
			return vec
		}
		per_vec = new Vector(1)
		length = $1
		ro = new Random()
		for (i=1;i<length;i=i+1)        {
			ro.discunif(0,i)
			per_vec.insrt(ro.repick,i)
		}
		//print "per_vec is "
		//per_vec.printf
		//print "requested length was ", $1, " actual is ", per_vec.size
		return per_vec
	}
	
	proc update_fronts()		{local i,j
		print "Calculating parent and children fronts"

		for (i=0;i<pop_size;i=i+1)	{
			joint_genome_matrix.setrow(i,parent_genome_matrix.getrow(i))
			joint_fitness_matrix.setrow(i,parent_fitness_matrix.getrow(i))
		}
		for (i=pop_size;i<(pop_size*2);i=i+1)	{
			j = i - pop_size
			joint_genome_matrix.setrow(i,org_list.o(j).pass_genome())
			joint_fitness_matrix.setrow(i,org_list.o(j).pass_fitness_vec())
		}

		front_list = set_fronts(joint_fitness_matrix,objective_num)

		print "joint fronts calculated"
	}
	

 	func assign_last_front()	{local i,j,k,s,t,ind,cur_front localobj max_front_vec
		cur_front = $3
		//print "in front number ", cur_front
		ind = $4
		//print "there are ", (pop_size-ind), " organisms left to assign"
		//print "there are ", $o1.size, " organisms in this front"
		max_front_vec = clean_front($o1,$o2)
		s = max_front_vec.size
		t = ind
		for (j=0;j<max_front_vec.size;j=j+1)	{
			if (ind>=pop_size){break}
			//print "j is ", j
			k = max_front_vec.x[j]
			//print "k is ", k
			org_list.o(ind).set_genome($o2.getrow(k))
			//print "org assigned through last front"
			ind = ind + 1
		}
		//print (ind-t), " organisms were assigned through last front"
		return ind
	}

	obfunc clean_front()	{local i,j,a,b,ind localobj front_vec,rem_vec,pass_vec
		if ($o1.size == 0)	{
			print "zero size front vec went in"
			//return $o1
			return new Vector(1)
		}
		//print "front vec that went in"
		//$o1.printf()
		//print "front vec that went in was of size ", $o1.size
		front_vec = $o1.c
		rem_vec = new Vector()
		//print "printing front"
		//for (i=0;i<front_vec.size();i=i+1)	{$o2.getrow(front_vec.x[i]).printf()}
		//print "front printed"
		/*for (i=0;i<front_vec.size();i=i+1)	{
			a = front_vec.x[i]
			//print "a is ", a
			for (j=0;j<front_vec.size();j=j+1)	{
				b = front_vec.x[j]
				//print "b is ", b
				if (a != b)	{
					if	($o2.getrow(a).eq($o2.getrow(b)) && (rem_vec.contains(b) == 0))	{rem_vec.append(b)}
				}
			}
		}*/

		for (i=0;i<front_vec.size();i=i+1)	{
			a = front_vec.x[i]
			//print "a is ", a
			for (j=i;j<front_vec.size();j=j+1)	{
				b = front_vec.x[j]
				//print "b is ", b
				if (a != b)	{
					if	($o2.getrow(a).eq($o2.getrow(b)) && (rem_vec.contains(b) == 0))	{rem_vec.append(b)}
				}
			}
		}

		for (i=0;i<rem_vec.size();i=i+1)	{
			ind = front_vec.indwhere("==", rem_vec.x[i])
			front_vec.remove(ind)
		}
		//print "removed ", rem_vec.size, " organisms final number of organisms is ", front_vec.size()
		if (front_vec.size == 0)	{
			//print "removed all organisms from front"
			front_vec.append($o1.x[0])
		}
		//print "clean front vec is "
		//front_vec.printf()
		//print "of size ", front_vec.size
		return front_vec
	}

	proc breed_parent_population_by_front()	{local i, generation localobj front_share_vec, sort_vec,max_front_vec

		front_share_vec = new Vector()
		generation = $1
		//print "began breeding parent population"
		set_fitness_matrix()
		set_org_genome_matrix()
		//print "fitness matrix is "
		//fitness_matrix.printf("%f ")
		print "calculating parent Pareto fronts"
		front_list = set_fronts(fitness_matrix,objective_num)
		//print "joint fronts calculated"

		for (i=0;i<pop_size;i=i+1)	{
			parent_genome_matrix.setrow(i,org_list.o(i).pass_genome())
		}
		for (i=0;i<pop_size;i=i+1)	{
			parent_fitness_matrix.setrow(i,org_list.o(i).pass_fitness_vec())
		}

		//set_full_elite()

		i = 0
		max_front = -1

		while (i<pop_size) {
			max_front = max_front + 1
			i = i + front_list.o(max_front).size()
		}

		print "Parent max_front is ", max_front
		ind = 0
		k = 0
		evolution_vector.fill(0)
		//print "K IS ", k
		while (k<max_front) {
			for (i=0;i<(front_list.o(k).size);i=i+1)	{
				j = front_list.o(k).x[i]
				org_list.o(ind).set_genome(parent_genome_matrix.getrow(j))
				//evolution_vector.x[ind] = j
				ind = ind + 1
			}
			k = k + 1
		}

		if (k<front_list.count)	{
			//spread_vec = calculate_pheno_share_vector(front_list.o(max_front),joint_genome_matrix)
			front_share_vec = calculate_front_share_vector(front_list.o(max_front),parent_genome_matrix)
			//print "front share vec is"
			//front_share_vec.printf()
			sort_vec = front_share_vec.sortindex()
			//print "share vec is "
			//spread_vec.printf
			//print "sort vec is "
			//sort_vec.printf
			i = 0
			while (ind<pop_size) {
				//j = sort_vec.x[(s-1)-i]
				j = sort_vec.x[i]
				org_list.o(ind).set_genome(parent_genome_matrix.getrow(j))
				ind = ind + 1
				i = i + 1
			}
		}

		evolve_population(generation)
	}

	proc sum_breed_parent_population_by_front()	{local i,j,k,r,generation localobj front_share_vec, sort_vec, sum_vec
		front_share_vec = new Vector()
		generation = $1
		//print "began breeding parent population"
		set_fitness_matrix()
		set_org_genome_matrix()
		//print "fitness matrix is "
		//fitness_matrix.printf()
		//print "calculating parent Pareto fronts"
		front_list = set_fronts(fitness_matrix,objective_num)
		//print "joint fronts calculated"

		for (i=0;i<pop_size;i=i+1)	{
			parent_genome_matrix.setrow(i,org_list.o(i).pass_genome())
		}
		for (i=0;i<pop_size;i=i+1)	{
			parent_fitness_matrix.setrow(i,org_list.o(i).pass_fitness_vec())
		}

		//set_full_elite()

		i = 0
		max_front = -1

		while (i<pop_size) {
			max_front = max_front + 1
			i = i + front_list.o(max_front).size()
		}

		print "Parent max_front is ", max_front
		ind = 0
		k = 0
		evolution_vector.fill(0)
		//print "K IS ", k
		while (k<max_front) {
			for (i=0;i<(front_list.o(k).size);i=i+1)	{
				j = front_list.o(k).x[i]
				org_list.o(ind).set_genome(parent_genome_matrix.getrow(j))
				//evolution_vector.x[ind] = j
				ind = ind + 1
			}
			k = k + 1
		}

		if (k<front_list.count)	{
			sum_vec = new Vector(parent_fitness_matrix.nrow)
			for (r = 0;r<parent_fitness_matrix.nrow;r=r+1)	{
				sum_vec.x[r] = parent_fitness_matrix.getrow(r).sum
			}
			sort_vec = sum_vec.sortindex()
			i = 0
			while (ind<pop_size) {
				//j = sort_vec.x[(s-1)-i]
				j = sort_vec.x[i]
				org_list.o(ind).set_genome(parent_genome_matrix.getrow(j))
				ind = ind + 1
				i = i + 1
			}
		}

		evolve_population(generation)
	}



	proc sum_combine_joint_population()	{local i,j,k,ind,max_front,s,r localobj spread_vec,sort_vec,sum_vec
		sort_vec = new Vector()
		spread_vec = new Vector()
		print "Calculating parent and children fronts"

		for (i=0;i<pop_size;i=i+1)	{
			joint_genome_matrix.setrow(i,parent_genome_matrix.getrow(i))
			joint_fitness_matrix.setrow(i,parent_fitness_matrix.getrow(i))
		}
		for (i=pop_size;i<(pop_size*2);i=i+1)	{
		j = i - pop_size
			joint_genome_matrix.setrow(i,org_list.o(j).pass_genome())
			joint_fitness_matrix.setrow(i,org_list.o(j).pass_fitness_vec())
		}

		front_list = set_fronts(joint_fitness_matrix,objective_num)

		print "Joint fronts calculated"

		i = 0
		max_front = -1

		while (i<pop_size) {
			max_front = max_front + 1
			i = i + front_list.o(max_front).size()
		}

		print "Parent and children max_front is ", max_front
		ind = 0
		k = 0
		//print "K IS ", k
		while (k<max_front) {
			for (i=0;i<(front_list.o(k).size());i=i+1)	{
				j = front_list.o(k).x[i]
				org_list.o(ind).set_genome(joint_genome_matrix.getrow(j))
				ind = ind + 1
			}
			//print "GOING FRONT BY FRONT"
			k = k + 1
		}

		//print "ind of indeces in max front is ", ind

		if (k<front_list.count)	{
			sum_vec = new Vector(parent_fitness_matrix.nrow)
			for (r = 0;r<parent_fitness_matrix.nrow;r=r+1)	{
				sum_vec.x[r] = parent_fitness_matrix.getrow(r).sum
			}
			sort_vec = sum_vec.sortindex()
			//print "sum vec is "
			//sum_vec.printf()
			i = 0
			while (ind<pop_size) {
				//j = sort_vec.x[(s-1)-i]
				j = sort_vec.x[i]
				org_list.o(ind).set_genome(joint_genome_matrix.getrow(j))
				ind = ind + 1
				i = i + 1
			}
		}

		insert_elite()

		front_list.remove_all()
		front_share_list.remove_all()
	}

	/*****************************************************
	*Function that implements evolutionary operations on the
	*basis provided by the breed population function
	*Input:
	*Output:
	*****************************************************/

	proc evolve_population()	{local i
		select_cross_over()
		if (cross_vector.size()>0)	{perform_cross_over(genome_matrix,2)}
		non_uniform_mutate_population(genome_matrix,$1)
		//uniform_mutate_population(genome_matrix)
		//org_list.o(0).set_genome(elite_vector)
//		print "after evolve population pop is"
//		print_pop()
		introduce_migration()
	}

	proc introduce_migration()	{local i,j
		//print "migrating"
		pop_ran.discunif(0,pop_size-1)
		for (i=0;i<((regen_frac*pop_size)-1);i=i+1)	{
			//j = pop_ran.repick()
			j = pop_size-1-i
			org_list.o(j).create_random(genome_matrix)
		}
	}

	proc set_full_elite(/*Fitness matrix, Genome matrix*/)	{local i,j,min_org localobj sort_vec,sum_vec
		//Individual objective elite
		sum_vec = new Vector($o1.nrow)
		//print "Fitness matrix for verification is "
		//fitness_matrix.printf()
		for (i=0;i<$o1.ncol;i=i+1)	{
			min_org = $o1.getcol(i).sortindex.x[0]
			elite_vector.x[i] = min_org
			//print "min org is ", min_org
		}
		for (i=0;i<$o1.nrow;i=i+1)	{
			sum_vec.x[i] = $o1.getrow(i).sum
		}
		min_org = sum_vec.sortindex.x[0]
		min_error = $o1.getrow(min_org).sum
		print "Minimum error in this generation is ", min_error
		elite_vector.x[elite_vector.size-1] = min_org
		set_elite_matrices(elite_vector,$o1,$o2)
		//elite_vector.printf()
	}

	proc set_elite_matrices(/*Elite vector, Fitness matrix, Genome matrix*/)	{local i
		for (i=0;i<$o1.size;i=i+1)	{
			elite_fitness_matrix.setrow(i,$o2.getrow(elite_vector.x[i]).c)
			elite_genome_matrix.setrow(i,$o3.getrow(elite_vector.x[i]).c)
		}
	}

	proc insert_elite()	{local i,j
		//print "population before inserting elite is "
		//for (i=0;i<pop_size;i=i+1)	{org_list.o(i).pass_genome().printf()}
		for (i=0;i<elite_vector.size;i=i+1){
			j = pop_size-1-i
			//print "j is ", j
			//org_list.o(j).set_genome(parent_genome_matrix.getrow(elite_vector.x[i]))
			//org_list.o(j).set_organism_fitness_vec(parent_fitness_matrix.getrow(elite_vector.x[i]))
			org_list.o(j).set_genome(elite_genome_matrix.getrow(i))
			org_list.o(j).set_organism_fitness_vec(elite_fitness_matrix.getrow(i))
			//print "inserting following organism"
			//parent_genome_matrix.getrow(elite_vector.x[i]).printf()
		}
		//print "population after inserting elite is "
		//for (i=0;i<pop_size;i=i+1)	{org_list.o(i).pass_genome().printf()}
	}

	/******
	** procedure that given a value vector returns a vector of indexes
	** of organisms selected for breeding through roullete wheel sampling
	**/

	proc set_stochastic_remainder_roulette_breeding_vector()	{local i,j,ind,num,total,flip localobj temp_vec,cumulative_vec,temp_fitness_vec
		temp_vec = $o1.c
		//print "vector to be used for fitness is "
		//temp_vec.printf
		cumulative_vec = new Vector(pop_size)
		total = temp_vec.sum()
		temp_vec.div(total)
		for (i=0;i<pop_size;i=i+1)	{
			cumulative_vec.x[i] = temp_vec.sum(0,i)
		}
		ind = -1
		temp_vec.mul(pop_size)
		temp_vec.floor
		//print "proportionate size is"
		//temp_vec.printf()
		for (i=0;i<pop_size;i=i+1)	{
			for (j=0;j<temp_vec.x[i];j=j+1)	{
				ind = ind + 1
				//print "ind is ", ind, "i is ", i
				breeding_vector.x[ind]=i
			}
		}
		pop_ran.uniform(0,1)
		for (i=ind + 1;i<pop_size;i=i+1)	{
			flip = pop_ran.repick()
			breeding_vector.x[i] = cumulative_vec.indwhere(">=",flip)
		}
		//print "done setting breeding vector"
		//print "breeding vector is"
		//breeding_vector.printf()
	}

	proc set_roulette_breeding_vector()	{local i,max,min,total,flip localobj temp_vec,cumulative_vec,temp_fitness_vec
		temp_vec = $o1.c
		//print "vector to be used for fitness is "
		//temp_vec.printf
		cumulative_vec = new Vector(pop_size)
		//total = temp_vec.sum()
		//temp_vec.div(total)
		//QUICK FIX//
		max = temp_vec.max()
		//min = temp_vec.min()
		temp_vec = temp_vec.sub(max).abs
		//temp_vec.add(1/pop_size)
		//print "readjusted temp_vec is "
		//temp_vec.printf
		total = temp_vec.sum()
		temp_vec.div(total)
		//print "final temp_vec is "
		//temp_vec.printf
		for (i=0;i<pop_size;i=i+1)	{
			cumulative_vec.x[i] = temp_vec.sum(0,i)
		}
		//print "cumulative vec is"
		//cumulative_vec.printf()
		pop_ran.uniform(0,1)
		for (i=0;i<pop_size;i=i+1)	{
			flip = pop_ran.repick()
			breeding_vector.x[i] = cumulative_vec.indwhere(">=",flip)
		}
		print "done setting breeding vector"
		//print "breeding vector is"
		//breeding_vector.printf()
	}

	/******
	** procedure that given a fitness vector returns a vector of indexes
	** of organisms selected for breeding through tournament selection
	** Input: 1. Fitness vector
	** Output: None. Automaticaly sets breeding vector
	**/

	proc set_simple_tournament_breeding_vector()	{local i,x,y,z localobj temp_vec,vec_one,vec_two
		temp_vec = new Vector(pop_size)
		temp_vec.fill(0)
		vec_one = new Vector(pop_size)
		vec_two = new Vector(pop_size)
		vec_one.indgen()
		vec_two.indgen()
		breeding_vector.fill(0)
//		print "fitness vector is"
//		fitness_vector.printf()
		for (i=0;i<pop_size;i=i+1)	{
			pop_ran.discunif(0,pop_size-i-1)
			x = pop_ran.repick()
//			print "x selected", x
			y = vec_one.x[x]
			temp_vec.x[y] = temp_vec.x[y] + 1
//			print "first index is ",y," value is", fitness_vector.x[y]
			vec_one.remove(x)
			x = pop_ran.repick()
//			print "x selected", x
			z = vec_two.x[x]
			temp_vec.x[z] = temp_vec.x[z] + 1
			vec_two.remove(x)
//			print "second index is ",z," value is", fitness_vector.x[z]
			if ($o1.x[y]<$o1.x[x])	{
				breeding_vector.x[i] = y
			} else {breeding_vector.x[i] = z}
//			print "breeding_vector is"
//			breeding_vector.printf()
		}
//		print "counter vector is"
//		temp_vec.printf()
	}

	proc uniform_mutate_population()	{local i localobj temp_org
//		print "old population is"
//		print_pop()
		for (i=0;i<pop_size;i=i+1)	{
			//org_list.o(i).set_genome(org_list.o(i).mutate_org($o1))
			org_list.o(i).uniform_mutate_org($o1)
		}
//		print "new population is"
//		print_pop()
	}

	proc non_uniform_mutate_population()	{local i,generation localobj temp_org
//		print "old population is"
//		print_pop()
//		print "max_generation is", max_generation
		generation = $2
//		print "generation is", generation
		for (i=0;i<pop_size/2;i=i+1)	{
			org_list.o(i).non_uniform_mutate_org($o1,generation,max_generation)
			//org_list.o(i+1).non_uniform_mutate_org($o1,generation,max_generation)
			org_list.o(i+1).non_uniform_single_mutate_org($o1,generation,max_generation)
		}
//		print "new population is"
//		print_pop()
	}

	proc print_pop()	{local i
		for (i=0;i<pop_size;i=i+1)	{
//			print "printing organism no ",i
			org_list.o(i).org_genome.printf()
		}
//		print "pop printed"
	}

	proc print_error()	{local i
		for (i=0;i<pop_size;i=i+1)	{
//			print "printing organism no ",i
			org_list.o(i).pass_fitness_vec.printf("%f ")
			printf("\n")
		}
//		print "pop printed"
	}

	proc print_fitness()	{fitness_vector.printf()}

	proc append_org()	{
		org_list.append($o1)
	}

	proc set_fitness_vector()	{local i
		for (i=0;i<pop_size;i=i+1)	{
			fitness_vector.x[i] = org_list.o(i).pass_fitness()
		}
	}

	proc set_fitness_matrix()	{local i
		for (i=0;i<pop_size;i=i+1)	{
			fitness_matrix.setrow(i, org_list.o(i).pass_fitness_vec())
		}
	}

	proc set_org_genome_matrix()	{local i
		for (i=0;i<pop_size;i=i+1)	{
			org_genome_matrix.setrow(i, org_list.o(i).pass_genome())
		}
	}

	/******
	** Function that selects pairs for cross over from population
	**/

	proc select_cross_over()	{local i,x,y,z,s_size
//		print "began selecting cross_over"
		if (cross_vector.size()>0) {cross_vector.remove(0,cross_vector.size()-1)}
		pop_ran.uniform(0,1)
		for (i=0;i<pop_size;i=i+1)	{
			x = pop_ran.repick()
			if (x<p_cross)	{cross_vector.append(i)}
		}
//		print "after first pass cross vector is"
//		cross_vector.printf()
		s_size = cross_vector.size()
		if (s_size/2 != int((s_size)/2))	{even_selection()}
//		print "cross_over selected final selection vec is"
//		cross_vector.printf()
	}

	/******
	** Function that turns selection vector even
	**/

	proc even_selection()	{local x,y,z,s_size
//		print "starting even selection with a vector of"
//		cross_vector.printf()
//		print "now need to even it out"
		pop_ran.uniform(0,1)
		s_size = cross_vector.size()
		while (s_size/2 != int((s_size)/2))	{
			y = pop_ran.repick()
//			print y
			if (y>0.5)	{
				pop_ran.discunif(0,s_size-1)
				x = pop_ran.repick()
	//			print "in remove x is", x
				cross_vector.remove(x)
			} else	{
				pop_ran.discunif(0,pop_size-1)
				z = 0
				while (z != -1)	{
					x = pop_ran.repick()
//					print "in even selection x is",x
					z = cross_vector.indwhere("==",x)
//					print "in even selection z is ",z
				}
				cross_vector.append(x)
			}
		s_size = cross_vector.size()
//		print "s_size is ",s_size
		}
	}

	/******
	** Function that implements cross over
	** Cross type 0 naive cross over
	** Cross type 1 random cross over
	** Cross type 2 simulated binary  cross over
	**/

	proc perform_cross_over(/*Matix, cross type*/)	{local i,s_size localobj temp_mat
		s_size = cross_vector.size()
		temp_mat = new Matrix(2,org_list.o(0).org_genome_size)
		for (i=0;i<(s_size/2);i=i+1)	{
//			print "the indexes of the two vectors to cross", cross_vector.x[i], cross_vector.x[s_size-1-i]
			if ($2 == 0)	{
				temp_mat = naive_cross_over(org_list.o(cross_vector.x[i]).pass_genome(),org_list.o(cross_vector.x[(s_size-1-i)]).pass_genome)
			}
			if ($2 == 1)	{
				temp_mat = random_cross_over(org_list.o(cross_vector.x[i]).pass_genome(),org_list.o(cross_vector.x[(s_size-1-i)]).pass_genome)
			}
			if ($2 == 2)	{
				temp_mat = sim_binary_cross_over(org_list.o(cross_vector.x[i]).pass_genome(),org_list.o(cross_vector.x[(s_size-1-i)]).pass_genome,$o1)
			}
			
			org_list.o(cross_vector.x[i]).set_genome(temp_mat.getrow(0))
			org_list.o(cross_vector.x[(s_size-1-i)]).set_genome(temp_mat.getrow(1))
		}
	}

	/******
	** Function that calculates naive cross over
	**/

	obfunc naive_cross_over()	{local i,g_size,cross_point localobj temp_mat//,temp_vec_one,temp_vec_two
		g_size = org_list.o(0).org_genome_size
		temp_mat = new Matrix(2,g_size)
		pop_ran.discunif(0,g_size-1)
		cross_point = pop_ran.repick()
//		print "cross point is", cross_point
		for (i=0;i<cross_point;i=i+1)	{
			temp_mat.x[0][i] = $o1.x[i]
			temp_mat.x[1][i] = $o2.x[i]
		}
		for (i=cross_point;i<g_size;i=i+1)	{
			temp_mat.x[0][i] = $o2.x[i]
			temp_mat.x[1][i] = $o1.x[i]
		}
		return temp_mat
	}

	/******
	** Function that calculates random cross over
	**/

	obfunc random_cross_over()	{local i,j,g_size,cnum localobj temp_mat//,temp_vec_one,temp_vec_two
		//print "Called random cross over"
		g_size = org_list.o(0).org_genome_size
		temp_mat = new Matrix(2,g_size)
		temp_mat.setrow(0,$o1.c)
		temp_mat.setrow(1,$o2.c)
		pop_ran.discunif(0,g_size-1)
		cnum = pop_ran.repick()
		for i=0,cnum-1	{
			j = pop_ran.repick()
			temp_mat.x[0][j] = $o2.x[j]
			temp_mat.x[1][j] = $o1.x[j]
		}
		return temp_mat
	}
	
	/******
	** Function that calculates simulated binary cross over
	**/

	obfunc sim_binary_cross_over()	{local i,x,g_size,eta,beta_q,min,max localobj temp_mat,g_mat
		g_size = org_list.o(0).org_genome_size
		g_mat = $o3
		eta = 2
		temp_mat = new Matrix(2,g_size)
	//	beta_vec = new Vector(g_size)
		pop_ran.uniform(0,1)
		for (i=0;i<g_size;i=i+1)	{
			min = g_mat.x[i][0]
			max = g_mat.x[i][1]
			x = pop_ran.repick()
			if (x<=0.5)	{
				beta_q = (2*x)^(1/(eta+1))
			}	else	{
				beta_q = (1/(2*(1-x)))^(1/(eta+1))
			}
			temp_mat.x[0][i] = 0.5*((1+beta_q)*$o1.x[i] + (1-beta_q)*$o2.x[i])
			temp_mat.x[1][i] = 0.5*((1-beta_q)*$o1.x[i] + (1+beta_q)*$o2.x[i])
			if (temp_mat.x[0][i] < min)	{temp_mat.x[0][i] = min}
			if (temp_mat.x[1][i] < min)	{temp_mat.x[1][i] = min}
			if (temp_mat.x[0][i] > max)	{temp_mat.x[0][i] = max}
			if (temp_mat.x[1][i] > max)	{temp_mat.x[1][i] = max}
		}
		return temp_mat
	}

	proc set_front_breeding_vector()	{local i,j,min,delta,front_min,next_base,org_index
		//print "began set front breeding vector"
		delta = 1e-3
		for (i=0;i<front_list.o(0).size;i=i+1)	{
			org_index = front_list.o(0).x[i]
			evolution_vector.x[org_index] = pop_size/(front_share_list.o(0).x[i])
		}
		min = pop_size/front_share_list.o(0).max
		//print "evolution vector is"
		//evolution_vector.printf()

		if (front_list.count == 1)	{return}

		for (i=1;i<front_list.count;i=i+1)	{
			front_min = 1e6
			for (j=0;j<front_list.o(i).size;j=j+1)	{
				//print "j is ",j
				org_index = front_list.o(i).x[j]
				//print "org_index is ", org_index
				//print "front share list object is"
				//front_share_list.o(i).printf()
				evolution_vector.x[org_index] = (min - delta)/(front_share_list.o(i).x[j])
			}
			//print "arrived at middle"
			for (j=0;j<front_list.o(i).size;j=j+1)	{
				org_index = front_list.o(i).x[j]
				if (evolution_vector.x[org_index] < front_min)	{front_min = evolution_vector.x[org_index]}
			}
			min = front_min
		}
		//print "final evolution vector is"
		//evolution_vector.printf()
	}

	proc calculate_phenotype_share_vector()	{local i,j localobj share_vec
		share_vector.fill(0)
		for (i=0;i<pop_size;i=i+1)	{
			for (j=0;j<pop_size;j=j+1)	{
				share_vector.x[i] = share_vector.x[i] + calculate_share(org_list.o(i).pass_genome,org_list.o(j).pass_genome,genome_matrix,phenotype_sigma_share)
			}
		}
		//print "share vector is"
		//share_vector.printf()
	}

	obfunc calculate_pheno_share_vector()	{local i,j,size localobj share_vec
		size = $o1.size
		share_vec = new Vector(size)
		for (i=0;i<size;i=i+1)	{
			//org_list.o($o1.x[i]).pass_genome.printf()
			for (j=0;j<size;j=j+1)	{
				//share_vec.x[i] = share_vec.x[i] + calculate_share(org_list.o($o1.x[i]).pass_genome,org_list.o($o1.x[j]).pass_genome,genome_matrix,phenotype_sigma_share)
				share_vec.x[i] = share_vec.x[i] + calculate_share($o2.getrow($o1.x[i]), $o2.getrow($o1.x[j]),genome_matrix,phenotype_sigma_share)
			}
		}
		//share_vec.add(1e-6)
		//print "share vector is"
		//share_vec.printf()
		return share_vec
	}

	obfunc calculate_front_share_vector()	{local i,j,size localobj share_vec
		size = $o1.size
		share_vec = new Vector(size)
		for (i=0;i<size;i=i+1)	{
			for (j=0;j<size;j=j+1)	{
				share_vec.x[i] = share_vec.x[i] + calculate_share($o2.getrow($o1.x[i]),$o2.getrow($o1.x[j]),fitness_span_matrix,objective_sigma_share)
			}
		}
		//print "share vector is"
		//share_vec.printf()
		return share_vec
	}

	func calculate_share()	{local i,share,pass
		share = 0
		pass = calculate_distance($o1,$o2,$o3)
		//print "pass is ", pass
		if (pass<$4)	{share = share + 1 - (pass/$4)}
		//return pass
		return share

	}

	/************************************************************
	* Function that calculates distance between two organisms.
	* Inputs:
	*	1.First organism genome.
	*	2.Second organism genome.
	*	3.Span matrix.
	* Output: Distance
	*************************************************************/

	func calculate_distance()	{local i,g_size,distance,span
		distance = 0
		g_size = $o1.size
		for (i=0;i<$o1.size;i=i+1)	{
			span = $o3.x[i][1]-$o3.x[i][0]
			distance = distance + ((($o1.x[i]-$o2.x[i])/span)^2)
		}
		distance = distance^(1/2)
		//distance = distance/(2*q^(1/g_size))
		//print "distance is",distance
		return distance
	}

	/*proc set_single_elite()	{local i,min
		min = fitness_vector.min()
		i = fitness_vector.indwhere("==",min)
		elite_vector = org_list.o(i).pass_genome()
//		fitness_vector.printf()
//		elite_vector.printf()
	}*/

	proc print_population_count()	{local i
		print "population count is"
		i =  org_list.count()
		print i
	}

	/*proc print_elite_vector()	{
		print "elite vector is"
		elite_vector.printf()
	}*/

	proc divide_fitness_by_share()	{local i
		fitness_vector.div(share_vector)
	}

	proc multiply_fitness_by_share()	{local i
		fitness_vector.mul(share_vector)
	}

	obfunc evaluate_fitness_matrix()	{local i,j,answer,dom_flag,set_flag localobj dom_ind_vec,fit_mat
		fit_mat = $o1
		//print "evaluated matrix is"
		//fit_mat.printf("%-6.6g ")
		dom_ind_vec = new Vector()
		set_flag = 0

		for (i=0;i<fit_mat.nrow();i=i+1)	{
			dom_flag = 0
			for (j=0;j<fit_mat.nrow();j=j+1)	{
				//answer = check_dominance(fit_mat.getrow(j),fit_mat.getrow(i))
				//answer = check_weak_dominance(fit_mat.getrow(j),fit_mat.getrow(i))
				answer = check_restricted_dominance(fit_mat.getrow(j),fit_mat.getrow(i))
				if (answer == 1)	{
					//print i," is dominated by ", j
					dom_flag = 1
					break
				}
			}
			if (dom_flag == 0)	{dom_ind_vec.append(i)}
		}
	//print "undominated indices are"
	//dom_ind_vec.printf()
	if (dom_ind_vec.size == 0)	{
		print "zero size front was found"
		fit_mat.printf()
	}
	return dom_ind_vec
}

	func check_dominance()	{local i,j,answer
		answer = 0
		better = 0
		for (i=0;i<$o1.size();i=i+1)	{
			if ($o2.x[i]<$o1.x[i])	{return 0}	else	{if($o2.x[i]>$o1.x[i])	{better = 1}}
		}
		if (better == 1)	{answer = 1}
		return answer
	}

	func check_weak_dominance()	{local i,j,answer,worse
		answer = 0
		better = 0
		worse = 0
		for (i=0;i<$o1.size();i=i+1)	{
			if ($o2.x[i]<$o1.x[i]) {worse = 1}	else	{if($o2.x[i]>$o1.x[i])	{better = 1}}
		}
		if (better == 1 && worse == 0)        {answer = 1}
		if ($o1.sum<(2*min_error) && $o2.sum>(2*min_error))	{
			if (answer == 0)	{
				/*print "answer is ", answer
				print "better is ", better
				print "worse is ", worse
				print "Only weakly dominated"
				print "Vector one"
				$o1.printf()
				print "Vector two"
				$o2.printf()*/
			}
			answer = 1
		}
		return answer
	}
	
	func check_restricted_dominance()	{local i,j,answer,worse,bound
		answer = 0
		better = 0
		worse = 0
		bound = 9
		for (i=0;i<$o1.size();i=i+1)	{
			if ($o2.x[i]<$o1.x[i]) {worse = 1}	else	{if($o2.x[i]>$o1.x[i])	{better = 1}}
		}
		if (better == 1 && worse == 0)        {answer = 1}
		if ($o1.sum<(2*min_error) && $o2.sum>(2*min_error))	{
			if (answer == 0)	{num_weak = num_weak + 1}
			answer = 1
		}
		if (($o1.indwhere(">",bound) == -1) && ($o2.indwhere(">",bound) != -1) && ($o1.sum<(2*min_error)))	{
			if (answer == 0)	{num_restricted = num_restricted + 1}
			answer = 1
		}
		return answer
	}

//temp_vec = evaluate_fitness_matrix()
//print "ind_vec before is "
//ind_vec.printf()

	obfunc set_fronts()	{local i,j localobj temp_mat,rem_vec,ind_vec,temp_vec,front_list
		temp_mat = new Matrix()
		front_list = new List()
		ind_vec = new Vector($o1.nrow())
		ind_vec.indgen()
		j = 0

		while (ind_vec.size>0)	{
			//temp_mat = new Matrix(ind_vec.size,$2)
			temp_mat.resize(ind_vec.size,$2)
			for (i=0;i<ind_vec.size;i=i+1)	{temp_mat.setrow(i, $o1.getrow(ind_vec.x[i]))}
			//print "temp_mat is"
			//temp_mat.printf()
			//ind_vec.indgen()
			temp_vec = evaluate_fitness_matrix(temp_mat)
			rem_vec = new Vector(temp_vec.size)
			for (i=0;i<temp_vec.size();i=i+1)	{rem_vec.x[i] = ind_vec.x[temp_vec.x[i]]}
			//print "Indeces of front ", j, " are:"
			//rem_vec.printf()
			for (i=0;i<temp_vec.size();i=i+1)	{ind_vec.remove(ind_vec.indwhere("==", rem_vec.x[i]))}
	//		print "ind_vec is"
	//		ind_vec.printf()
			front_list.append(rem_vec.c)
			j = j + 1
			if (j>pop_size)	{
				print "reached pop size number of fronts"
				break
			}
		}
	return front_list
	}

	func calculate_front_sharing()	{localobj share_vec
		share_vec = new Vector($o1.size())
		return share_vec
	}

	func pass_maximal_fitness()	{return fitness_vector.max()}
	func pass_maximal_fitness_index()	{return fitness_vector.indwhere("==",fitness_vector.max())}

	func pass_minimal_fitness()	{return fitness_vector.min()}
	func pass_minimal_fitness_index()	{return fitness_vector.indwhere("==",fitness_vector.min())}

	proc load_population_from_file()	{local i localobj tmp_file
		print "called load population"
		print $s1
		tmp_file = new File($s1)
		tmp_file.ropen
		print "breed matrix rows ",breed_matrix.nrow
		print "breed matrix columns ", breed_matrix.ncol
		breed_matrix.scanf(tmp_file)
		tmp_file.close
		for (i=0;i<breed_matrix.nrow;i=i+1)	{
			org_list.o(i).set_genome(breed_matrix.getrow(i))
		}

		print "population loaded from file"
	}

	proc load_error_from_file()	{local i localobj tmp_file
		print "called load error"
		tmp_file = new File($s1)
		tmp_file.ropen
		fitness_matrix.scanf(tmp_file)
		tmp_file.close
		for (i=0;i<breed_matrix.nrow;i=i+1)	{
			org_list.o(i).set_organism_fitness_vec(fitness_matrix.getrow(i))
		}
		print "error matrix loaded from file"
	}


	proc dump_population()	{localobj tmp_file
		tmp_file = new File(pop_file_name)
		tmp_file.wopen
		breed_matrix.fprint(tmp_file)
		tmp_file.close
	}

	obfunc permutate_population()	{local i localobj r, per_vec, per_mat, exp_mat
		per_mat = breed_matrix.c
		exp_mat = fitness_matrix.c
		//for (i=0;i<exp_mat.nrow;i=i+1)	{
			//print i
			//org_list.o(i).pass_fitness_vec().printf()
			//exp_mat.setrow(i,org_list.o(i).pass_fitness_vec())
		//}
		per_vec = new Vector(pop_size)
		r = new Random()
		r.discunif(0,pop_size-1)
		per_vec.setrand(r)
		print "per_vec is "
		per_vec.printf()
		for (i=0;i<per_mat.nrow();i=i+1)	{
			breed_matrix.setrow(i,per_mat.getrow(per_vec.x[i]))
		}
		for (i=0;i<breed_matrix.nrow;i=i+1)	{
			org_list.o(i).set_genome(breed_matrix.getrow(i))
		}
		for (i=0;i<per_mat.nrow();i=i+1)	{
			exp_mat.setrow(i,org_list.o(per_vec.x[i]).pass_fitness_vec())
		}
		print "expected error in next generation ", ($1 + 1)
		exp_mat.printf("%f ")
		return exp_mat
	}

	obfunc get_org_list()	{return org_list}
endtemplate Population

/*Comments:
Set parsing to load span matrix
*/
