begintemplate BAC_run5_bin_sort_4_index_418_0
public init, import_morphology, biophys, geom_nseg, hardcode_biophys
public delete_axon
public locateSites, getLongestBranch, distribute_channels

public soma, dend, apic, axon, getAbsSecIndex
public all, somatic, apical, axonal, basal, nSecSoma, nSecApical, nSecBasal, nSecAxonal, nSecAll, nSecAxonalOrig

objref all, somatic, apical, axonal, basal, this

strdef tstr

proc init() {
	all = new SectionList()
	somatic = new SectionList()
	basal = new SectionList()
	apical = new SectionList()
	axonal = new SectionList()
	forall delete_section()
}

create soma[1], dend[1], apic[1], axon[1], myelin[1]

proc import_morphology() { local special86
// 	all = new SectionList()
// 	somatic = new SectionList()
// 	basal = new SectionList()
// 	apical = new SectionList()
// 	axonal = new SectionList()
// 	forall delete_section()
	
// 	printf("Trying to import morphology file...\n")
	import_morphology_file($s1)
//	soma psection()
// 	printf("Done; setting up SectionLists...\n")
	
    soma all.append()
    forsec "dend" all.append()
    forsec "apic" all.append()
    
    soma somatic.append()
    forsec "dend" basal.append()
    forsec "apic" apical.append()
	
	special86 = 1
	if(special86) {
		print "/*---------------------------------------------------------------------------*/"
		print "/* Special case 86_L5_CDK20041214:                                           */"
		print "/* Scale diameter of apical dendrites 0-32 by 2.5 (RE)                       */"
		print "/* Otherwise, apical trunk is too thin (<2mu) to allow coupling between      */"
		print "/* somatic Na+ and apical Ca2+ spiking zones                                 */"
		print "/*---------------------------------------------------------------------------*/"

		for i = 0, 32 {
			access apic[i]
			for j = 0, n3d()-1 {
				oldDiam = diam3d(j)
				newDiam = 2.5*oldDiam
				pt3dchange(j, newDiam)
	// 			print "Changing diameter from ", oldDiam, " to ", diam3d(j)
			}
		}
	}
}

proc geom() {
  forsec all {  L = 100  diam = 1  }
}
external lambda_f
proc geom_nseg() {local nSec, L1, L2, D1, D2, nSeg1, nSeg2
// 	printf("Setting up geometry...\n")
  soma area(.5) // make sure diam reflects 3d points
  nSec = 0
  forsec all {
//  nseg = int((L/(0.1*lambda_f(100))+.9)/2)*2 + 1
  nseg = 1 + 2*int(L/40)
  nSec = nSec + 1
  }

  nSecAll = nSec
  nSec = 0
  forsec somatic { nSec = nSec + 1}
  nSecSoma	= 	nSec
  nSec = 0
  forsec apical { nSec = nSec + 1}
  nSecApical= 	nSec
  nSec = 0
  forsec basal { nSec = nSec + 1}
  nSecBasal	= 	nSec
  nSec = 0
  forsec axonal { nSec = nSec + 1}
  nSecAxonalOrig = nSecAxonal	= 	nSec
}

proc biophys() {
	delete_axon()
	area(0.5)
	distance()
	access soma

	forsec "apic" insert SK_E2 
	forsec "apic" insert Ca_LVAst 
	forsec "apic" insert Ca_HVA 
	forsec "apic" insert SKv3_1 
	forsec "apic" insert NaTa_t 
	forsec "apic" insert Im 
	forsec "axon" insert Ca_LVAst 
	forsec "axon" insert Ca_HVA 
	forsec "axon" insert SKv3_1 
	forsec "axon" insert SK_E2 
	forsec "axon" insert K_Tst 
	forsec "axon" insert K_Pst 
	forsec "axon" insert Nap_Et2 
	forsec "axon" insert NaTa_t 
	forsec "soma" insert Ca_LVAst 
	forsec "soma" insert Ca_HVA 
	forsec "soma" insert SKv3_1 
	forsec "soma" insert SK_E2 
	forsec "soma" insert K_Tst 
	forsec "soma" insert K_Pst 
	forsec "soma" insert Nap_Et2 
	forsec "soma" insert NaTa_t 
	hardcode_biophys() 
	distribute_channels("apic","decay_CaDynamics_E2",0,1.000000,0.000000,0.000000,0.000000,132.0000000000) 
	distribute_channels("apic","gamma_CaDynamics_E2",0,1.000000,0.000000,0.000000,0.000000,0.0005120000) 
	distribute_channels("apic","gSK_E2bar_SK_E2",0,1.000000,0.000000,0.000000,0.000000,0.0033700000) 
	distribute_channels("apic","gCa_LVAstbar_Ca_LVAst",3,1.000000,0.010000,900.000000,1100.000000,0.1260000000) 
	distribute_channels("apic","gCa_HVAbar_Ca_HVA",3,1.000000,0.100000,900.000000,1100.000000,0.0043100000) 
	distribute_channels("apic","gSKv3_1bar_SKv3_1",0,1.000000,0.000000,0.000000,0.000000,0.0100000000) 
	distribute_channels("apic","gNaTa_tbar_NaTa_t",0,1.000000,0.000000,0.000000,0.000000,0.0238000000) 
	distribute_channels("apic","gImbar_Im",0,1.000000,0.000000,0.000000,0.000000,0.0002660000) 
	distribute_channels("apic","g_pas",0,1.000000,0.000000,0.000000,0.000000,0.0000787000) 
	distribute_channels("dend","g_pas",0,1.000000,0.000000,0.000000,0.000000,0.0000763000) 
	distribute_channels("axon","g_pas",0,1.000000,0.000000,0.000000,0.000000,0.0000231000) 
	distribute_channels("soma","g_pas",0,1.000000,0.000000,0.000000,0.000000,0.0000351000) 
	distribute_channels("axon","decay_CaDynamics_E2",0,1.000000,0.000000,0.000000,0.000000,307.0000000000) 
	distribute_channels("axon","gamma_CaDynamics_E2",0,1.000000,0.000000,0.000000,0.000000,0.0163000000) 
	distribute_channels("axon","gCa_LVAstbar_Ca_LVAst",0,1.000000,0.000000,0.000000,0.000000,0.0073400000) 
	distribute_channels("axon","gCa_HVAbar_Ca_HVA",0,1.000000,0.000000,0.000000,0.000000,0.0005280000) 
	distribute_channels("axon","gSKv3_1bar_SKv3_1",0,1.000000,0.000000,0.000000,0.000000,1.3200000000) 
	distribute_channels("axon","gSK_E2bar_SK_E2",0,1.000000,0.000000,0.000000,0.000000,0.0000243000) 
	distribute_channels("axon","gK_Tstbar_K_Tst",0,1.000000,0.000000,0.000000,0.000000,0.0856000000) 
	distribute_channels("axon","gK_Pstbar_K_Pst",0,1.000000,0.000000,0.000000,0.000000,0.7740000000) 
	distribute_channels("axon","gNap_Et2bar_Nap_Et2",0,1.000000,0.000000,0.000000,0.000000,0.0042500000) 
	distribute_channels("axon","gNaTa_tbar_NaTa_t",0,1.000000,0.000000,0.000000,0.000000,0.4840000000) 
	distribute_channels("soma","decay_CaDynamics_E2",0,1.000000,0.000000,0.000000,0.000000,567.0000000000) 
	distribute_channels("soma","gamma_CaDynamics_E2",0,1.000000,0.000000,0.000000,0.000000,0.0006300000) 
	distribute_channels("soma","gCa_LVAstbar_Ca_LVAst",0,1.000000,0.000000,0.000000,0.000000,0.0050200000) 
	distribute_channels("soma","gCa_HVAbar_Ca_HVA",0,1.000000,0.000000,0.000000,0.000000,0.0005120000) 
	distribute_channels("soma","gSKv3_1bar_SKv3_1",0,1.000000,0.000000,0.000000,0.000000,0.8930000000) 
	distribute_channels("soma","gSK_E2bar_SK_E2",0,1.000000,0.000000,0.000000,0.000000,0.0516000000) 
	distribute_channels("soma","gK_Tstbar_K_Tst",0,1.000000,0.000000,0.000000,0.000000,0.0454000000) 
	distribute_channels("soma","gK_Pstbar_K_Pst",0,1.000000,0.000000,0.000000,0.000000,0.0006890000) 
	distribute_channels("soma","gNap_Et2bar_Nap_Et2",0,1.000000,0.000000,0.000000,0.000000,0.0070400000) 
	distribute_channels("soma","gNaTa_tbar_NaTa_t",0,1.000000,0.000000,0.000000,0.000000,2.0700000000) 
}

proc hardcode_biophys() {
	forall {
	  insert pas
		cm = 1
		Ra = 100
		e_pas = -90
	}

	forsec "soma" {
		ek = -85
		ena = 50
	}

	forsec "soma" insert CaDynamics_E2

	forsec "apic" {
		cm = 2
	}
	forsec "dend" {
		cm = 2
	}
	
//  Active, complex axon
    forsec "myelin" {
        cm = 0.02
        g_pas = 4e-5
    }
    forsec "axon" {
        ek = -85
        ena = 50
    }
    forsec "axon" insert CaDynamics_E2
    forsec "axon" insert Ih
    distribute_channels("axon","gIhbar_Ih",0,1.000000,0.000000,0.000000,0.000000,0.00008000000)

  forsec "soma" insert Ih
	distribute_channels("soma","gIhbar_Ih",0,1.000000,0.000000,0.000000,0.000000,0.00008000000) 

  forsec "dend" insert Ih
	distribute_channels("dend","gIhbar_Ih",0,1.000000,0.000000,0.000000,0.000000,0.00020000000) 

  forsec "apic" insert Ih
	distribute_channels("apic","gIhbar_Ih",2,-0.8696,3.6161,0.0,2.0870,0.00020000000) 

	forsec "apic" insert CaDynamics_E2

	forsec "apic" {
		ek = -85
		ena = 50
	}
}

// deleting axon, keeping only first 60 micrometers
proc delete_axon(){
// 	printf("Deleting old axon\n")
    forsec axonal{delete_section()}
// 	printf("Creating new axon\n")
    create axon[2]
    access axon[0]{
      L= 30
      diam = 1
      nseg = 1+2*int(L/40)
      all.append()
      axonal.append()
    }
    access axon[1]{
      L= 30
      diam = 1
      nseg = 1+2*int(L/40)
      all.append()
      axonal.append()
    }

// 	printf("Connecting new axon\n")
  nSecAxonal = 2
  connect axon(0), soma(0.5)
  connect axon[1](0), axon[0](1) 
  access soma
}

//deleting axon, appending instead a standard axon
//$1-4: parameters of axonal tapering
//$1 d0, diameter at axon base
//$2 d1, diameter at axon 20 micrometers from soma
//$3 d2, diameter at axon 50 micrometers from soma
//$4 d3, diameter of myelin section
proc delete_axon2(){
    forsec axonal{delete_section()}
    create axon[2]
    access axon[0]{
        L= 20
//      diam = 1
        nseg = 1+2*int(L/10)
//      diam(0:1) = $1:$2
        diam(0:1) = 3:1.75
        all.append()
        axonal.append()
    }
    access axon[1]{
        L= 30
//      diam = 1
        nseg = 1+2*int(L/10)
//      diam(0:1) = $2:$3
        diam(0:1) = 1.75:1
        all.append()
        axonal.append()
    }

//  if($4){
        create myelin[1]
        access myelin{
            L = 1000
//          diam = $4
            diam = 1
            nseg = 1+2*int(L/100)
        }
        connect myelin(0), axon[1](1) 
//  }
    
    nSecAxonal = 2
    connect axon(0), soma(0.5)
    connect axon[1](0), axon[0](1) 
    access soma
    
//  forsec all psection()
}

proc distribute_channels()	{local dist,val,base,maxLength
	base = $8
	"soma" distance()
	maxLength = getLongestBranch($s1)
	
	
	forsec $s1		{
// 		psection()
		if(0==strcmp($s2,"Ra")){
			Ra = $8
		} else {
			for(x) {
				if ($3==3) {
					dist = distance(x)
				} else {
					dist = distance(x)/maxLength
				}
				val = calculate_distribution($3,dist,$4,$5,$6,$7,$8)
				sprint(tstr,"%s(%-5.10f) = %-5.10f",$s2,x,val)
// 				print "x=", x
// 				print "tstr=", tstr
				execute(tstr)
			}
		}
	}
}

// $1 is the distribution type:
//     0 linear, 1 sigmoid, 2 exponential
//     3 step for absolute distance (in microns)
func calculate_distribution()	{local value
	if ($1==0)	{value = $3 + $2*$4}
	if ($1==1) {value = $3 + ($4/(1+exp(($2-$5)/$6)))}
  	if ($1==2) {value = $3 + $6*exp($4*($2-$5))}
	if ($1==3) {
		if (($2 > $5) && ($2 < $6)) {
			value = $3
		} else {
			value = $4
		}
	}
	value = value*$7
	return value
}

// $s1 section
func getLongestBranch(){local maxL,d localobj distallist,sref
    sprint(tstr,"%s distance()",$s1)
    execute(tstr,this)    
    
  	if(0==strcmp($s1,"axon")){
      sprint(tstr,"%s[0] distance(1)",$s1)
      execute(tstr,this)    
  	}

		maxL = 0
		d = 0
		distallist = new SectionList()
		forsec $s1 {
			sref = new SectionRef()
			if (sref.nchild==0) distallist.append()
		}
		forsec distallist{
			d = distance(1)
			if(maxL<d) maxL = d
		}
		// for the soma case
		if (maxL == 0) {
      $s1 {
        maxL = L
      }
    }
		return maxL
	}

// $s1 section
// $2 distance x in micrometers
// return list of [1,2] vectors  - of the appropriate section and the location in each vector
obfunc locateSites() {local maxL,site,d0,d1,siteX,i localobj vv,ll
	ll = new List()

  sprint(tstr,"%s distance()",$s1)
  execute(tstr,this)    
    
	if(0==strcmp($s1,"axon")){
    sprint(tstr,"%s[0] distance(1)",$s1)
    execute(tstr,this)    
	}

	maxL = getLongestBranch($s1)
	site = $2
	i = 0
	forsec $s1 {
    if (distance(0) < distance(1)) {
  		d0 = distance(0)
  		d1 = distance(1)
  	} else {
  		d1 = distance(0)
  		d0 = distance(1)
  	}

    if (site <= d1 && site >= d0) {
      siteX = (site-d0)/(d1-d0)
      secNum = i
      vv = new Vector()
      ll.append(vv.append(secNum,siteX))
		}
		i = i+1
	}
  return ll
}

func getAbsSecIndex(){ local nAbsInd, index  localobj str,strObj
    strObj  =  new StringFunctions()
    str     =  new String()
    nAbsInd = 0
    index   = 0
    if(strObj.substr($s1, "soma") > 0) {
        strObj.tail($s1, "soma", str.s)
        if(sscanf(str.s, "%*c%d", &index) < 0) {
            index = 0
        }
        nAbsInd = index
    }else if (strObj.substr($s1, "axon") >0) {
        strObj.tail($s1, "axon", str.s)
        if(sscanf(str.s, "%*c%d", &index) < 0) {
            index = 0
        }
        nAbsInd = nSecSoma + index
    }else if (strObj.substr($s1, "dend") >0) {
        strObj.tail($s1, "dend", str.s)
        if(sscanf(str.s, "%*c%d", &index) < 0) {
            index = 0
        }
        nAbsInd = nSecSoma + nSecAxonalOrig + index
    }else if (strObj.substr($s1, "apic") > 0) {
        strObj.tail($s1, "apic", str.s)
        if(sscanf(str.s, "%*c%d", &index) < 0) {
            index = 0
        }
        nAbsInd = nSecSoma + nSecAxonalOrig + nSecBasal + index
    }
    return nAbsInd
}

proc import_morphology_file() { localobj f, tstr1, tstr2, strObj
	f = new File()
	f.ropen($s1)
	tstr1 = new String()
	tstr2 = new String()
	strObj = new StringFunctions()
	while (f.gets(tstr1.s) > -1) {
		if(strObj.substr(tstr1.s, "/*") == 0) {
			continue
		}
		if(strObj.substr(tstr1.s, "\n") == 0) {
			continue
		}
		if(strObj.substr(tstr1.s, "color") > -1) {
			continue
		}
		strObj.head(tstr1.s, "\n", tstr2.s)
		execute(tstr2.s, this)
	}
	
	f.close
}

endtemplate BAC_run5_bin_sort_4_index_418_0