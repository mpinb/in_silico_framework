begintemplate GAcell_v2

public init, import_morphology, biophys, geom_nseg, hardcode_biophys
public delete_axon
public locateSites, getLongestBranch, distribute_channels

public soma, dend, apic, axon, getAbsSecIndex
public all, somatic, apical, axonal, basal, nSecSoma, nSecApical, nSecBasal, nSecAxonal, nSecAll, nSecAxonalOrig

objref all, somatic, apical, axonal, basal, this

strdef tstr

proc init() {
	all = new SectionList()
	somatic = new SectionList()
	basal = new SectionList()
	apical = new SectionList()
	axonal = new SectionList()
	forall delete_section()
}

create soma[1], dend[1], apic[1], axon[1]

proc import_morphology() { local special86
// 	all = new SectionList()
// 	somatic = new SectionList()
// 	basal = new SectionList()
// 	apical = new SectionList()
// 	axonal = new SectionList()
// 	forall delete_section()
	
// 	printf("Trying to import morphology file...\n")
	import_morphology_file($s1)
//	soma psection()
// 	printf("Done; setting up SectionLists...\n")
	
    soma all.append()
    forsec "dend" all.append()
    forsec "apic" all.append()
    
    soma somatic.append()
    forsec "dend" basal.append()
    forsec "apic" apical.append()
	
	special86 = 0
	if(special86) {
		print "/*---------------------------------------------------------------------------*/"
		print "/* Special case 86_L5_CDK20041214:                                           */"
		print "/* Scale diameter of apical dendrites 0-32 by 2.5 (RE)                       */"
		print "/* Otherwise, apical trunk is too thin (<2mu) to allow coupling between      */"
		print "/* somatic Na+ and apical Ca2+ spiking zones                                 */"
		print "/*---------------------------------------------------------------------------*/"

		for i = 0, 32 {
			access apic[i]
			for j = 0, n3d()-1 {
				oldDiam = diam3d(j)
				newDiam = 2.5*oldDiam
				pt3dchange(j, newDiam)
	// 			print "Changing diameter from ", oldDiam, " to ", diam3d(j)
			}
		}
	}
}

proc geom() {
  forsec all {  L = 100  diam = 1  }
}
external lambda_f
proc geom_nseg() {local nSec, L1, L2, D1, D2, nSeg1, nSeg2
// 	printf("Setting up geometry...\n")
  soma area(.5) // make sure diam reflects 3d points
  nSec = 0
  forsec all {
//  nseg = int((L/(0.1*lambda_f(100))+.9)/2)*2 + 1
  nseg = 1 + 2*int(L/40)
  nSec = nSec + 1
  }

  nSecAll = nSec
  nSec = 0
  forsec somatic { nSec = nSec + 1}
  nSecSoma	= 	nSec
  nSec = 0
  forsec apical { nSec = nSec + 1}
  nSecApical= 	nSec
  nSec = 0
  forsec basal { nSec = nSec + 1}
  nSecBasal	= 	nSec
  nSec = 0
  forsec axonal { nSec = nSec + 1}
  nSecAxonalOrig = nSecAxonal	= 	nSec
}

proc biophys() {
	delete_axon()
 	access soma
	area(0.5)
	distance()
}

proc hardcode_biophys() {
	forall {
	  insert pas
		cm = 1
		Ra = 100
		e_pas = -90
	}

	forsec "soma" {
		ek = -85
		ena = 50
	}

	forsec "soma" insert CaDynamics_E2

	forsec "apic" {
		cm = 2
	}
	forsec "dend" {
		cm = 2
	}

  forsec "soma" insert Ih
	distribute_channels("soma","gIhbar_Ih",0,1.000000,0.000000,0.000000,0.000000,0.00020000000) 

  forsec "dend" insert Ih
	distribute_channels("dend","gIhbar_Ih",0,1.000000,0.000000,0.000000,0.000000,0.00020000000) 

  forsec "apic" insert Ih
	distribute_channels("apic","gIhbar_Ih",2,-0.8696,3.6161,0.0,2.0870,0.00020000000) 

	forsec "apic" insert CaDynamics_E2

	forsec "apic" {
		ek = -85
		ena = 50
	}
}

// deleting axon, keeping only first 60 micrometers
proc delete_axon(){
// 	printf("Deleting old axon\n")
    forsec axonal{delete_section()}
// 	printf("Creating new axon\n")
    create axon[2]
    access axon[0]{
      L= 30
      diam = 1
      nseg = 1+2*int(L/40)
      all.append()
      axonal.append()
    }
    access axon[1]{
      L= 30
      diam = 1
      nseg = 1+2*int(L/40)
      all.append()
      axonal.append()
    }

// 	printf("Connecting new axon\n")
  nSecAxonal = 2
  connect axon(0), soma(0.5)
  connect axon[1](0), axon[0](1) 
  access soma
}

proc distribute_channels()	{local dist,val,base,maxLength
	base = $8
	"soma" distance()
	maxLength = getLongestBranch($s1)
	
	forsec $s1		{
// 		psection()
		if(0==strcmp($s2,"Ra")){
			Ra = $8
		} else {
			for(x) {
				if ($3==3) {
					dist = distance(x)
				} else {
					dist = distance(x)/maxLength
				}
				val = calculate_distribution($3,dist,$4,$5,$6,$7,$8)
				sprint(tstr,"%s(%-5.10f) = %-5.10f",$s2,x,val)
				execute(tstr)
			}
		}
	}
}

// $1 is the distribution type:
//     0 linear, 1 sigmoid, 2 exponential
//     3 step for absolute distance (in microns)
func calculate_distribution()	{local value
	if ($1==0)	{value = $3 + $2*$4}
	if ($1==1) {value = $3 + ($4/(1+exp(($2-$5)/$6)))}
  	if ($1==2) {value = $3 + $6*exp($4*($2-$5))}
	if ($1==3) {
		if (($2 > $5) && ($2 < $6)) {
			value = $3
		} else {
			value = $4
		}
	}
	value = value*$7
	return value
}

// $s1 section
func getLongestBranch(){local maxL,d localobj distallist,sref
    sprint(tstr,"%s distance()",$s1)
    execute(tstr,this)    
    
  	if(0==strcmp($s1,"axon")){
      sprint(tstr,"%s[0] distance(1)",$s1)
      execute(tstr,this)    
  	}

		maxL = 0
		d = 0
		distallist = new SectionList()
		forsec $s1 {
			sref = new SectionRef()
			if (sref.nchild==0) distallist.append()
		}
		forsec distallist{
			d = distance(1)
			if(maxL<d) maxL = d
		}
		// for the soma case
		if (maxL == 0) {
      $s1 {
        maxL = L
      }
    }
		return maxL
	}

// $s1 section
// $2 distance x in micrometers
// return list of [1,2] vectors  - of the appropriate section and the location in each vector
obfunc locateSites() {local maxL,site,d0,d1,siteX,i localobj vv,ll
	ll = new List()

  sprint(tstr,"%s distance()",$s1)
  execute(tstr,this)    
    
	if(0==strcmp($s1,"axon")){
    sprint(tstr,"%s[0] distance(1)",$s1)
    execute(tstr,this)    
	}

	maxL = getLongestBranch($s1)
	site = $2
	i = 0
	forsec $s1 {
    if (distance(0) < distance(1)) {
  		d0 = distance(0)
  		d1 = distance(1)
  	} else {
  		d1 = distance(0)
  		d0 = distance(1)
  	}

    if (site <= d1 && site >= d0) {
      siteX = (site-d0)/(d1-d0)
      secNum = i
      vv = new Vector()
      ll.append(vv.append(secNum,siteX))
		}
		i = i+1
	}
  return ll
}

func getAbsSecIndex(){ local nAbsInd, index  localobj str,strObj
    strObj  =  new StringFunctions()
    str     =  new String()
    nAbsInd = 0
    index   = 0
    if(strObj.substr($s1, "soma") > 0) {
        strObj.tail($s1, "soma", str.s)
        if(sscanf(str.s, "%*c%d", &index) < 0) {
            index = 0
        }
        nAbsInd = index
    }else if (strObj.substr($s1, "axon") >0) {
        strObj.tail($s1, "axon", str.s)
        if(sscanf(str.s, "%*c%d", &index) < 0) {
            index = 0
        }
        nAbsInd = nSecSoma + index
    }else if (strObj.substr($s1, "dend") >0) {
        strObj.tail($s1, "dend", str.s)
        if(sscanf(str.s, "%*c%d", &index) < 0) {
            index = 0
        }
        nAbsInd = nSecSoma + nSecAxonalOrig + index
    }else if (strObj.substr($s1, "apic") > 0) {
        strObj.tail($s1, "apic", str.s)
        if(sscanf(str.s, "%*c%d", &index) < 0) {
            index = 0
        }
        nAbsInd = nSecSoma + nSecAxonalOrig + nSecBasal + index
    }
    return nAbsInd
}

proc import_morphology_file() { localobj f, tstr1, tstr2, strObj
	f = new File()
	f.ropen($s1)
	tstr1 = new String()
	tstr2 = new String()
	strObj = new StringFunctions()
	while (f.gets(tstr1.s) > -1) {
		if(strObj.substr(tstr1.s, "/*") == 0) {
			continue
		}
		if(strObj.substr(tstr1.s, "\n") == 0) {
			continue
		}
		if(strObj.substr(tstr1.s, "color") > -1) {
			continue
		}
		strObj.head(tstr1.s, "\n", tstr2.s)
		execute(tstr2.s, this)
	}
	
	f.close
}

endtemplate GAcell_v2
