/*****************************************************
* MOEA object that implements feature based errors and
* other kinds of errors
*
* Authors: Shaul Druckmann, Albert Gidon
* Hebrew U, May 2006
* 
* Modified by: Etay Hay, Hebrew University of Jerusalem, 2011
*****************************************************/

begintemplate DistanceCalculator
	objref tvec,verr,msevec,feature_type_list,feature_vec
	objref exp_file_list,exp_trace_list, exp_file_list,exp_deriv_list, den_mat_list
	objref exp_density_mat, sim_density_mat
	objref mat_v_ind_vec, mat_i_ind_vec
	objref exp_volt_vec, exp_deriv_vec, sim_volt_vec,sim_deriv_vec
	objref exp_density_mat,sim_density_mat
	objref spike_time_list, tdc, mc
	objref stim, stim_vec, clist

  objref clist2,apcvecList,vList,cascvec

	strdef feature_string,exp_s,dir,target_path
	public get_organism_stimulus_error, get_density_error, get_exp_trace
	public verr,mean_spike_depth
	public spike_time_list, vector_spike_time_error

	proc init()	{
		mc = $o1
		dir = $s2
		target_path = $s3
		tdc = $o4
		clist = new List()
		clist2 = new List()
    exp_file_list = new List()
		exp_trace_list = new List()
		exp_deriv_list = new List()
		den_mat_list = new List()
		spike_time_list = new List()
		stim_vec = new Vector(2)
        // RE: use -30 for combined step/BAC firing
     thresh = -30
        // RE: -30 does not work well for BAC firing only
//         thresh = -20
    caSpikethresh = -55
		density_start = 700

	}

	/*****************************************************************
	// The function that ultimately calculates the error (or distance)
	// given the voltage trace, time trace (and ap vector) according to
	// the config defined features
	*****************************************************************/
	obfunc get_organism_stimulus_error()	{local i,penalty,punish,ti,tj,interval,use_control,err, stim_delay, stim_duri,bb,vi,vbdend,tk localobj stat_std,stat_mean,vv, ftl
		stat_mean  = $o1
		print "stat_mean ", stat_mean
		stat_std = $o2
        print "stat_std ", stat_std
		tvec = $o3
	  vList = $o4
		punish = $7
        print "punish ", punish
		use_control = $8
        print "use_control ", use_control
		rep_num = $9
        print "rep_num ", rep_num
		ftl = $o10

    minspikenum = $12
        print "minspikenum ", minspikenum

		stim_vec = $o11.c //First value stim delay Second value stim duration
		stim_del = stim_vec.x[0]
		stim_dur = stim_vec.x[1]
        print "stim_del ", stim_del
        print "stim_dur ", stim_dur

    apcvecList = new List()
    for(i=0;i<vList.count();i+=1){
      if (i==0){
    		clist = find_crossing(vList.o[i],thresh)
    		apcvecList.append(tvec.ind(clist.o(0)))
    	}
    
      if (i==1){

        tk = tvec.indwhere(">=",0.5*stim_del)

    		clist2 = find_crossing(vList.o[i],caSpikethresh)
    		cascvec = tvec.ind(clist2.o(0))
    	}
    
      if (i>0){
        vbdend = voltage_base(vList.o[i],stim_del)

    		clist2 = find_crossing(vList.o[i].c(tk),vbdend+2)
    		apcvecList.append(tvec.c(tk).ind(clist2.o(0)))
    	}
  	}

        print "apcvecList.o[0].size: ", apcvecList.o[0].size
		verr = new Vector(stat_mean.size)
		feature_num = ftl.count
        print "feature_num ", feature_num
		penalty = 0

		var_fact = 1e-1

		verr.fill(0)

		if (use_control !=1)	{
			if (trace_check(stim_vec)==-1) {
                print "Found problem with trace!"
				//***** ARBITRARY ******
				ti = tvec.indwhere(">=",stim_del-100)
				tj = tvec.indwhere(">=",stim_del+(stim_dur/2))
				//***** ARBITRARY ******
				if (vList.o[0].c(ti,tj).size()>1)	{
					bb = punish - vList.o[0].c(ti,tj).var*var_fact
					if (bb<75)	{bb=75}
					verr.fill(bb)
				}	else	{verr.fill(punish)}
				return verr
			}
		}

		for (i=0;i<feature_num;i=i+1)	{
			feature_string = ftl.o(i).s
			print "Calculating feature ", feature_string
			err = calculate_single_feature(stat_mean.x[i], stat_std.x[i],ftl.o(i).s,stim_vec)
            print "Feature error: ", err
			verr.x[i] = err
			if (verr.x[i]>punish)	{verr.x[i] = (punish*0.75)}
			//THINK OF BAD ERROR CALCULATION VALUE (NOT ENOUGH SPIKES)
			//if (verr.x[i]<0)	{print "rejected error"	verr.x[i] = (punish*0.75)} // taken out by arco: I want to know in which direction the deviation is occuring
		}

		//return verr.abs
		return verr // changed by arco: I want to know in which direction the deviation is occuring
	}


	/*****************************************************************
	// Checks the trace for any problems (such as spiking without
	// stimulus) before features are calculated. Also sifts out traces
	// that do not contain spikes
	//
	// Note: Will need to be updated for different stimulus types
	*****************************************************************/
	func trace_check(){local ti,tj,ts,t_last, t_before,stim_del,stim_dur localobj stim_s
		stim_del = $o1.x[0]
		stim_dur = $o1.x[1]
		
	print "Checking for minimum spike number..."
    //Etay: changed for other stimuli
    if(apcvecList.o[0].size<minspikenum){return -1}

    print "Checking for returning to rest..."
    //Etay: added to punish case of not returning to rest
    if(vList.o[0].x[vList.o[0].size()-1] - voltage_base(vList.o[0],stim_del) > 2) {return -1} 

 	  //if(apcvecList.o[0].size<2){return -1}
		
    print "Checking for spikes before stimulus..."
    ts = tvec.indwhere(">=",apcvecList.o[0].x[0])
		ti = tvec.indwhere(">=",apcvecList.o[0].x[apcvecList.o[0].size-1])
		tj = vList.o[0].c(ti).indwhere("<=",thresh)
		if(tvec.x[ts]<stim_del){return -1}
		if(tj==-1){return -1}
		if(tvec.x[ti]>(stim_del+stim_dur+stim_dur/20)){return -1}
		if(tj==-1){apcvecList.o[0].remove(apcvecList.o[0].size-1)}
		t_last = ((stim_del+stim_dur)-apcvecList.o[0].x[apcvecList.o[0].size-1])
		t_before = (apcvecList.o[0].x[apcvecList.o[0].size-1]-apcvecList.o[0].x[apcvecList.o[0].size-2])
		return 0
	}

	func calculate_single_feature()	{local i, fmean, fstd, err, stim_del, stim_dur	localobj a
		err = 0
		fmean = $1
		fstd = $2
		stim_del = $o4.x[0]
		stim_dur = $o4.x[1]

		if (0 == strcmp($s3,"AP_height"))	{
			err = mean_spike_height(fmean,fstd) // arco: abs removed
            print "Mean spike height: ", err
		}

		if (0 == strcmp($s3,"AHP_depth"))	{
			err = mean_spike_depth(stim_del,fmean) // arco: abs removed
            print "AHP_depth: ", err
		}

		if (0 == strcmp($s3,"AHP_depth_abs"))	{
			err = mean_spike_depth_abs(fmean,fstd) // arco: abs removed
		}

		if (0 == strcmp($s3,"AHP_depth_abs_fast"))	{
			err = mean_spike_depth_abs_fast(fmean,fstd) // arco: abs removed
		}

		if (0 == strcmp($s3,"AHP_depth_abs_slow"))	{
			err = mean_spike_depth_abs_slow(fmean,fstd) // arco: abs removed
		}

		if (0 == strcmp($s3,"AHP_slow_time"))	{
			err = mean_spike_depth_slow_time(fmean,fstd) // arco: abs removed
		}

		if (0 == strcmp($s3,"doublet_ISI"))	{
			err = doublet_ISI(fmean,fstd) // arco: abs removed
		}

		if (0 == strcmp($s3,"pulseTimes"))	{
			err = pulseTimes(fmean,fstd,stim_del,stim_dur) // arco: abs removed
		}

		if (0 == strcmp($s3,"BPAPatt2"))	{
			err = BPAPatt(fmean,fstd,stim_del,vList.o[1],apcvecList.o[1]) // arco: abs removed
		}

		if (0 == strcmp($s3,"BPAPatt3"))	{
			err = BPAPatt(fmean,fstd,stim_del,vList.o[2],apcvecList.o[2]) // arco: abs removed
		}

		if (0 == strcmp($s3,"BAC_ISI"))	{
			err = BAC_ISI(fmean,fstd,stim_del+stim_dur) // arco: abs removed
		}

		if (0 == strcmp($s3,"Spikecount"))	{
			err = Spikecount(fmean) // arco: abs removed
		}

		if (0 == strcmp($s3,"BAC_caSpike_height"))	{
			err = BAC_caSpike_height(fmean,fstd) // arco: abs removed
            print "Mean Ca spike height: ", err
		}

		if (0 == strcmp($s3,"BAC_caSpike_width"))	{err = BAC_caSpike_width(fmean,fstd)}

		if (0 == strcmp($s3,"bAP_width"))	{err = bAP_width(fmean,fstd)}

		if (0 == strcmp($s3,"mean_frequency"))	{err = abs(fmean-(apcvecList.o[0].size()*(1000/stim_dur)))}

		if (0 == strcmp($s3,"mean_frequency2"))	{err = abs(mean_frequency2(fmean,fstd,stim_del,stim_dur))}

		if (0 == strcmp($s3,"adaptation_ratio"))	{err = abs(fmean - adapt_ratio(fmean,fstd,stim_del,stim_dur))}

		if (0 == strcmp($s3,"adaptation_index"))	{err = abs(fmean - adaptation_index(fstd,(stim_del+stim_dur)))}

		if (0 == strcmp($s3,"adaptation_index2"))	{err = abs(fmean - adaptation_index2(fstd,(stim_del+stim_dur)))}

		if (0 == strcmp($s3,"AP_width"))	{err = mean_spike_width(fmean,fstd)}

		if (0 == strcmp($s3,"time_to_first_spike"))	{err = abs(fmean-(apcvecList.o[0].x[0]-stim_del))}

		if (0 == strcmp($s3,"burst_ratio"))	{err = abs(fmean-burst_ratio(fmean,fstd,stim_del,stim_dur))}

		if (0 == strcmp($s3,"ISI_CV"))	{err = ISI_CV(fmean)}

		if (0 == strcmp($s3,"burst_number"))	{err = burst_number(fmean)}

		if (0 == strcmp($s3,"spike_timing"))	{err = vector_spike_time_error(spike_time_list.o(fmean),apcvecList.o[0],stim_del)}

		if (0 == strcmp($s3,"timing_error"))    {err = tdc.get_timing_error(vList.o[0],tvec,rep_num)}

		if (0 == strcmp($s3,"trajectory_density"))	{err = tdc.get_trajectory_error(vList.o[0],tvec,rep_num)}

		if (0 == strcmp($s3,"mean_square_error"))	{err = tdc.get_mse_error(vList.o[0],tvec,rep_num)}

		if (0 == strcmp($s3,"ramp_trajectory_density"))	{err = tdc.get_trajectory_error(vList.o[0],tvec,rep_num)}

		if (0 == strcmp($s3,"ramp_AP_height_slope"))	{err = abs(fmean - ramp_spike_height_slope())}

		if (0 == strcmp($s3,"ramp_AP_height_base"))	{err = abs(fmean - ramp_spike_height_base())}

		if (0 == strcmp($s3,"ramp_AHP_depth_slope"))	{err = abs(fmean - ramp_spike_depth_slope(stim_del))}

		if (0 == strcmp($s3,"ramp_AHP_depth_base"))	{err = abs(fmean - ramp_spike_depth_base(stim_del))}

		if (0 == strcmp($s3,"ramp_adaptation_index"))	{err = abs(fmean - ramp_adaptation_index(fstd,(stim_del+stim_dur)))}

		if (0 == strcmp($s3,"spike_half_width"))	{
			a = extract_peak_index(vList.o[0],thresh)
			a = comp_spike_width(vList.o[0],tvec,a.c)
			err = a.sub(fmean).abs.mean
		}

		if (0 == strcmp($s3,"ahp_half_width"))	{
			a = extract_peak_index(vList.o[0],thresh)
			a = comp_ahp_width(vList.o[0],tvec,a.c)
			err = a.sub(fmean).abs.median
		}

		if (0 == strcmp($s3,"voltage_base"))	{err = abs(fmean - voltage_base(vList.o[0],stim_del))}

    //print $s3, " ", err/fstd
        print "\tErr: ", err
        print "\tSTD: ", fstd
        print "\tnorm. diff: ", (err/fstd)
		return (err/fstd)
	}


	//*****************************************************
	// The peak of the spike is the most well defined time
	// Thus as an initial value it works well
	//*****************************************************

	obfunc extract_peak_index(/*voltage vector, threshold*/)	{local i,ind localobj pvec,clist
		pvec = new Vector()

		clist = find_crossing($o1,$2)

		if (clist.o(0).size != clist.o(1).size)	{
			print "Warning different number of threshold up and down crossings"
			return new Vector(1,-1)
		}	else	{
			pvec.resize(clist.o(0).size)
			for (i=0;i<clist.o(0).size;i=i+1)	{pvec.x[i] = $o1.max_ind(clist.o(0).x[i],clist.o(1).x[i])}
		}

		return pvec
	}

	//***************************************************************
	// Function that giving a threshold returns a list of two vectors
	// The first is the crossing up of that threshold
	// The second is the crossing down of that threshold
	//***************************************************************

	obfunc find_crossing(/*voltage vector, threshold*/)	{local i,thresh,ef localobj clist,avec,bvec
		ef = 0
		thresh = $2
		avec = new Vector()
		bvec = new Vector()
		clist = new List()
		for (i=1;i<$o1.size;i=i+1){
			if ($o1.x[i]> thresh && $o1.x[i-1] < thresh) {
				avec.append(i)
				ef = 1
			}	else	{
				if ($o1.x[i] < thresh && $o1.x[i-1] > thresh) {
					bvec.append(i)
				}
			}
		}

		if (avec.size != bvec.size && ef == 1)	{

			clist.append(new Vector())
			clist.append(new Vector())
			return clist
		}

		clist.append(avec)
		clist.append(bvec)

		return clist
	}

	//***************************************************************
	// Function that calculates mean rate over entire stimulus
	//***************************************************************

	obfunc firing_rate(/*pvec*/)	{
		return new Vector(1,$o1.size/(stim_dur/1000))
	}

	//***************************************************************
	// Function that returns the voltage value of the spike peaks
	//***************************************************************

	obfunc peak_spike_v(/*voltage vec,time vec,peak ind vec*/)	{
		return $o1.ind($o3)
	}

	//***************************************************************
	// Function that returns the time of the first spike following
	// the start of the stimulus
	//***************************************************************

	obfunc first_spike_t(/*voltage vec,time vec,peak ind vec*/)	{
		return new Vector(1,$o2.x[$o3.x[0]]-stim_del)
	}

	//*********************************************************
	// Calculates spike width by taking the width at the half
	// point between the threshold crossing and the peak
	//*********************************************************

	obfunc comp_ahp_width(/*voltage vec,time vec,peak ind vec*/)	{local i,ind,a,half,ei,b,stime,w,s localobj ovec,avec,bvec,wvec, cvec
		ovec = spike_onset_t($o1,$o2,$o3)
		avec = ahp_i($o1,$o2,$o3)
		wvec = new Vector(ovec.size)
		cvec = new Vector()
		ind = $o2.indwhere(">=",ovec.x[0])
		half = $o1.x[ind]+(abs($o1.x[ind]-$o1.x[$o3.x[0]])/2)
		hi = $o1.indwhere(">=",half)
		wvec.x[0] = $o2.x[hi+$o1.c(hi).indwhere("<=",half)]-$o2.x[hi]

		for i=1, ovec.size-2	{
			ind = $o2.indwhere(">=",ovec.x[i])
			half = $o1.x[ind]+abs($o1.x[ind]-$o1.x[$o3.x[i]])/2
			hi = $o1.c(avec.x[i-1],$o3.x[i]).indwhere(">=",half)+avec.x[i-1]
			s = int($o1.c(avec.x[i-1],$o3.x[i]).indwhere(">=",half))/2+avec.x[i-1]
			cvec.append($o1.x[s]-$o1.x[avec.x[i-1]])
			stime = $o2.x[hi]
			ei = $o1.c($o3.x[i],avec.x[i]).indwhere("<=",half)+$o3.x[i]
			wvec.x[i] = $o2.x[ei]-stime
		}

		ind = $o2.indwhere(">=",ovec.x[ovec.size-1])
		half = $o1.x[ind]+abs($o1.x[ind]-$o1.x[$o3.x[ovec.size-1]])/2
		hi = $o1.c(avec.x[ovec.size-1-1],$o3.x[ovec.size-1]).indwhere(">=",half)+avec.x[ovec.size-1-1]
		s = int($o1.c(avec.x[ovec.size-1-1],$o3.x[ovec.size-1]).indwhere(">=",half)/2)+avec.x[ovec.size-1-1]
		cvec.append($o1.x[s]-$o1.x[avec.x[ovec.size-1-1]])
		stime = $o2.x[hi]
		ei = $o1.c($o3.x[ovec.size-1]).indwhere("<=",half)+$o3.x[ovec.size-1]
		wvec.x[ovec.size-1] = $o2.x[ei]-stime
		return cvec
	}
	//*********************************************************
	// Calculates spike width by taking the width at the half
	// point between the threshold crossing and the peak
	//*********************************************************

	obfunc comp_spike_width(/*voltage vec,time vec,peak ind vec*/)	{local i,ind,a,half,ei,b,stime,w,s localobj ovec,avec,bvec,wvec
		ovec = spike_onset_t($o1,$o2,$o3)
		avec = ahp_i($o1,$o2,$o3)
		wvec = new Vector(ovec.size)
		ind = $o2.indwhere(">=",ovec.x[0])
		half = $o1.x[ind]+(abs($o1.x[ind]-$o1.x[$o3.x[0]])/2)
		hi = $o1.indwhere(">=",half)
		wvec.x[0] = $o2.x[hi+$o1.c(hi).indwhere("<=",half)]-$o2.x[hi]

		for i=1, ovec.size-2	{
			ind = $o2.indwhere(">=",ovec.x[i])
			half = $o1.x[ind]+abs($o1.x[ind]-$o1.x[$o3.x[i]])/2
			hi = $o1.c(avec.x[i-1],$o3.x[i]).indwhere(">=",half)+avec.x[i-1]
			s = int($o1.c(avec.x[i-1],$o3.x[i]).indwhere(">=",half))/2+avec.x[i-1]
			stime = $o2.x[hi]
			ei = $o1.c($o3.x[i],avec.x[i]).indwhere("<=",half)+$o3.x[i]
			wvec.x[i] = $o2.x[ei]-stime
		}

		ind = $o2.indwhere(">=",ovec.x[ovec.size-1])
		half = $o1.x[ind]+abs($o1.x[ind]-$o1.x[$o3.x[ovec.size-1]])/2
		hi = $o1.c(avec.x[ovec.size-1-1],$o3.x[ovec.size-1]).indwhere(">=",half)+avec.x[ovec.size-1-1]
		stime = $o2.x[hi]
		ei = $o1.c($o3.x[ovec.size-1]).indwhere("<=",half)+$o3.x[ovec.size-1]
		wvec.x[ovec.size-1] = $o2.x[ei]-stime
		return wvec
	}

	//*********************************************************
	// Spike onset time defined as maximum of second derivative
	//*********************************************************

	obfunc spike_onset_t(/*voltage vec,time vec,peak ind vec*/)	{local i,ind,a,b,idt localobj ivec,dvec, ovec,xdest,vec
		idt = 0.1
		vec = new Vector()
		ivec = new Vector()
		dvec = new Vector()
		ovec = new Vector($o3.size)
		indnum = int(($o2.max)/idt)
		xdest = new Vector(indnum)
		xdest.indgen(idt)
		ivec.interpolate(xdest, $o2, $o1)
		dvec.deriv(ivec, idt,2)
		dvec.deriv(dvec.c, idt,2)
		a = xdest.indwhere(">=",$o2.x[$o3.x[0]])
		ind = dvec.max_ind(0,a)
		ovec.x[0] = xdest.x[ind]
		for i=0, $o3.size-2	{
			a = xdest.indwhere(">=",$o2.x[$o3.x[i]])
			b = xdest.indwhere(">=",$o2.x[$o3.x[i+1]])
			ind = dvec.max_ind(a,b)
			ovec.x[i+1] = xdest.x[ind]
		}
		return ovec
	}

	obfunc ahp_v(/*voltage vec,time vec,peak ind vec*/)	{local i localobj ahpv
		ahpv = new Vector($o3.size-1)

		for i=0, $o3.size-2	{
			ahpv.x[i] = $o1.min($o3.x[i],$o3.x[i+1])
		}

		return ahpv
	}

	obfunc ahp_i(/*voltage vec,time vec,peak ind vec*/)	{local i,min localobj ahpi,avec
		ahpi = new Vector($o3.size)

		for i=0, $o3.size-2	{
			min = $o1.min($o3.x[i],$o3.x[i+1])
			avec = $o1.c($o3.x[i],$o3.x[i+1])
			ahpi.x[i] = avec.indwhere("==", min)+$o3.x[i]
		}

		return ahpi
	}


	func mean_isi(/*calc_isi*/){local misi
		if(apcvecList.o[0].size<2) return $1
		misi = apcvecList.o[0].c(1).sub(apcvecList.o[0].c(0,apcvecList.o[0].size-2)).mean
		return abs(misi/$1)
	}

	func ramp_adaptation_index()	{local l,start,bn localobj adi,isi,cut_isi
		bn = 0
		if(apcvecList.o[0].size<5){return 0}//needs atleast two isi's to obtain aptation index
		start = 1
		isi = apcvecList.o[0].c(1+start).sub(apcvecList.o[0].c(start,apcvecList.o[0].size-2))
		l = ($2-apcvecList.o[0].x[apcvecList.o[0].size-1])
		if (l>0 && l>isi.x[isi.size-1])	{isi.append(l)}
		start = 1
		cut_isi = isi.c(start)
		adi = cut_isi.c(1).sub(cut_isi.c(0,cut_isi.size-2))
		adi = adi.div(cut_isi.c(1).add(cut_isi.c(0,cut_isi.size-2)))
		return ((adi.sum()/adi.size))
	}

	func adaptation_index()	{local l,start,bn localobj adi,isi,cut_isi
		bn = 0
		if(apcvecList.o[0].size<5){return 0}//needs atleast two isi's to obtain aptation index
		start = 1
		isi = apcvecList.o[0].c(1+start).sub(apcvecList.o[0].c(start,apcvecList.o[0].size-2))
		l = ($2-apcvecList.o[0].x[apcvecList.o[0].size-1])
		if (l>0 && l>isi.x[isi.size-1])	{isi.append(l)}
		start = (int(apcvecList.o[0].size()/5))
		cut_isi = isi.c(start)
		adi = cut_isi.c(1).sub(cut_isi.c(0,cut_isi.size-2))
		adi = adi.div(cut_isi.c(1).add(cut_isi.c(0,cut_isi.size-2)))
		return ((adi.sum()/adi.size)+50*bn*$1)
	}

	func adaptation_index2()	{local l,start,bn localobj adi,isi,cut_isi
		bn = 0
		if(apcvecList.o[0].size<5){return 0}//needs atleast two isi's to obtain aptation index
		start = 1
		isi = apcvecList.o[0].c(1+start).sub(apcvecList.o[0].c(start,apcvecList.o[0].size-2))
		l = ($2-apcvecList.o[0].x[apcvecList.o[0].size-1])
		if (l>0 && l>isi.x[isi.size-1])	{isi.append(l)}

		start = 0

		cut_isi = isi.c(start)
		adi = cut_isi.c(1).sub(cut_isi.c(0,cut_isi.size-2))
		adi = adi.div(cut_isi.c(1).add(cut_isi.c(0,cut_isi.size-2)))
		return ((adi.sum()/adi.size)+50*bn*$1)
	}

  
	// $1 mean
	// $2 std
	// $3 stim_del
	// $4 stim_dur
  func mean_frequency2() {local r
    r = apcvecList.o[0].size()*(1000/$4)
    if ($3+$4 - apcvecList.o[0].x[apcvecList.o[0].size()-1] > 2*1000/r) {return 20*$2}
    return abs($1-r)
  }
	
  func burst_number(/*isi_vec*/)	{local i, count, factor localobj isi
		factor = 2
		if(apcvecList.o[0].size<5){return $1}//needs atleast two isi's to obtain aptation index
		start = 1
		isi = apcvecList.o[0].c(1+start).sub(apcvecList.o[0].c(start,apcvecList.o[0].size-2))
		count = 0
		for (i=1;i<(isi.size-1);i+=1){
			if ((isi.x[i] > factor*isi.x[i-1]) && (isi.x[i+1] < isi.x[i]/factor))	{count = count +1}
		}
		return (abs(count-$1))
	}

	func ISI_CV()	{local start localobj vec,isi
		if(apcvecList.o[0].size<5){return $1}//needs atleast two isi's to obtain aptation index
		start = 1
		isi = apcvecList.o[0].c(1+start).sub(apcvecList.o[0].c(start,apcvecList.o[0].size-2))
		return (abs((isi.stdev/isi.mean)-$1))
	}

	func mean_spike_width(/*mean_width*/)	{local i,ti,tj localobj w
		if(apcvecList.o[0].size<1) {return 20*$2}
    w = new Vector()
		for (i=0;i<apcvecList.o[0].size;i+=1){
			ti = tvec.indwhere(">=",apcvecList.o[0].x[i])
			tj = vList.o[0].c(ti).indwhere("<=",thresh) + ti
			if (tj<ti)	{tj=ti}
			w.append(tvec.x[tj] - tvec.x[ti])
		}
    return w.sub($1).abs().mean
	}

// Etay: dendritic BAC version
	func BAC_caSpike_width(/*mean_width*/)	{local i,ti,tj,rv localobj w
		if(cascvec.size!=1) {return 20*$2}
		w = new Vector()
		for (i=0;i<cascvec.size;i+=1){
			ti = tvec.indwhere(">=",cascvec.x[i])
			tj = vList.o[1].c(ti).indwhere("<=",caSpikethresh) + ti
			if (tj<ti)	{tj=ti}
			w.append(tvec.x[tj] - tvec.x[ti])
		}
		
    if (apcvecList.o[0].size==2) {
      return w.sub($1 - 7).abs().mean
    } else {
      return w.sub($1).abs().mean
    }
	}

// Etay: dendritic bAP version
	func bAP_width(/*mean_width*/)	{local i,ti,tj,rv,naSpikethresh localobj w
		if(apcvecList.o[1].size!=1) {return 20*$2}
		w = new Vector()

    naSpikethresh = voltage_base(vList.o[1],stim_del) + 2

		for (i=0;i<apcvecList.o[1].size;i+=1){
			ti = tvec.indwhere(">=",apcvecList.o[1].x[i])
			tj = vList.o[1].c(ti).indwhere("<=",naSpikethresh) + ti
			if (tj<ti)	{tj=ti}
			w.append(tvec.x[tj] - tvec.x[ti])
		}

    // return w.sub($1).abs().mean
	return w.sub($1).mean // we expect only one spike, in this scenario, we can allow negative values
	}

	func adapt_ratio()	{local i,j,mid,end,ratio,mean,std,del,dur
		mean = $1
		std = $2
		del = $3
		dur = $4
		if(apcvecList.o[0].size<5) {return mean+std*10}//needs atleast five spikes to obtain adaptation index
		mid = 0
		end = 0
		i = apcvecList.o[0].indwhere(">=",((del+(2/5)*dur)))
		if (i>=0)	{
			j = apcvecList.o[0].indwhere(">=",(del + (3/5)*dur))
			if (j>=i)	{
				mid = j-i
			}
		}
		i = apcvecList.o[0].indwhere(">=",(del+(4/5)*dur))
		if (i>=0)	{
				end = apcvecList.o[0].size()-i
		}
		if (mid != 0 && end != 0)	{
			return (mid/end)
		}   else {return mean+std*10}
	}

	func burst_ratio()   {local i,j,mid,start,ratio,mean,std,del,dur
		mean = $1
		std = $2
		del = $3
		dur = $4
		if(apcvecList.o[0].size<5) {return mean+std*10}//needs atleast five spikes to obtain burst index
		mid = 0
		start = 0
		i = apcvecList.o[0].indwhere(">=",((del+(2/5)*dur)))
		if (i>=0)	{
			j = apcvecList.o[0].indwhere(">=",(del + (3/5)*dur))
			if (j>=i)	{
				mid = j-i
			}
		}
		i = apcvecList.o[0].indwhere(">=",(del+(1/5)*dur))
		if (i>=0)	{
			start = i+1
		}
		if (mid != 0 && start !=0)	{
			return (mid/start)
		}   else {return mean+std*10}
	}

	func mean_spike_height(/*mean_height*/)	{local i,ti,tj,smin localobj h
		if(apcvecList.o[0].size<1) {return 20*$2}
		h =  calc_spike_height(thresh,vList.o[0],apcvecList.o[0])
		return h.sub($1).abs().mean
	}

  // Etay: BAC version
	func BAC_caSpike_height(/*mean_height*/)	{local i,ti,tj,smin localobj h
		if(cascvec.size!=1) {return 20*$2}
    
    // making sure the peak of the ca spike comes after the second AP
    if(apcvecList.o[0].size < 2) {return 20*$2} 
    if (tvec.x[vList.o[1].indwhere(">=",vList.o[1].max)] < apcvecList.o[0].x[1]) {return 20*$2} 

		h =  calc_spike_height(caSpikethresh,vList.o[1],cascvec)
		return h.sub($1).abs().mean
	}


	func ramp_spike_height_slope()	{local i,start,m,o localobj h,hd,hp
		if (apcvecList.o[0].size==2)	{h = calc_spike_height(thresh,vList.o[0],apcvecList.o[0])	return (h.x[1]-h.x[0])}
		start = 0
		h =  calc_spike_height(thresh,vList.o[0],apcvecList.o[0])
		hd = h.c(start+1).sub(h.c(start,h.size-2))
		m =  hd.c(1).mean()
		return m
	}

	func ramp_spike_height_base()	{local i,start,m,o localobj h,hd,hp
		if (apcvecList.o[0].size==2)	{h = calc_spike_height(thresh,vList.o[0],apcvecList.o[0])	return h.x[1]}
		start = 0
		h =  calc_spike_height(thresh,vList.o[0],apcvecList.o[0])
		o =  h.c(1,2).mean()
		return o
	}

  // $1 threshold
  // $o2 voltage vector
  // $o3 apc vector
	obfunc calc_spike_height()	{local i,ti,tj,smin localobj h
		smin = -10
		h = new Vector()
		for (i=0;i<$o3.size;i+=1){
			ti = tvec.indwhere(">=",$o3.x[i])
			tj = $o2.c(ti).indwhere("<=",$1) + ti
			if (tj<ti)	{tj=ti}
			h.append($o2.c(ti,tj).max)
		}
		return h.c
	}


	func voltage_base(/*stim delay*/)	{local ts,ta,b
    ta = tvec.indwhere(">=",0.5*$2)
		ts = tvec.indwhere(">=",0.75*$2)

		if (ts>0)	{
			b = $o1.c(ta,ts).mean
			return b
		}	else	{
			//print "Returned early"
			return $o1.x[0]
		}
	}

	func mean_spike_depth(/*mean_depth*/)	{local i,st,ti1,ti2,ti3,ti4,base,del,ahp localobj d
		del = $1
		//if(apcvecList.o[0].size<2) {return abs($1-(-100)) }//mV
		d = new Vector()
		base = calc_trace_base($1)
		d = calc_spike_depth()
		d = d.sub(base)
		//return d.sub($2).abs().mean
		//****************HACK*********************
		//**Need to put in base as an actual variable**
		return (d.sub($2).abs().mean + abs(base+71))
	}

	// $1 mean
	// $2 std
	func mean_spike_depth_abs(/*mean_depth*/)	{local i,ti1,ti2 localobj d
		d = new Vector()
		if(apcvecList.o[0].size<2) {return abs(20 * $2) }//mV

		for (i=0;i<apcvecList.o[0].size-1;i+=1){
			ti1 = tvec.indwhere(">=",apcvecList.o[0].x[i])
			ti2 = tvec.indwhere(">=",apcvecList.o[0].x[i+1])
			d.append(vList.o[0].c(ti1,ti2).min)
		}

		return (d.sub($1).abs().mean)
	}

	// $1 mean
	// $2 std
	func mean_spike_depth_abs_fast(/*mean_depth*/)	{local i,ti1,ti2 localobj d
		d = new Vector()
		if(apcvecList.o[0].size<3) {return abs(20 * $2) }//mV

		for (i=1;i<apcvecList.o[0].size-1;i+=1){
			ti1 = tvec.indwhere(">=",apcvecList.o[0].x[i])
			
      if ((apcvecList.o[0].x[i+1]-apcvecList.o[0].x[i]) < 5) {
        ti2 = tvec.indwhere(">=",apcvecList.o[0].x[i+1])
      } else {
        ti2 = tvec.indwhere(">=",apcvecList.o[0].x[i]+5)
      }
			d.append(vList.o[0].c(ti1,ti2).min)
		}

		return (d.sub($1).abs().mean)
	}

	// $1 mean
	// $2 std
	func mean_spike_depth_abs_slow(/*mean_depth*/)	{local i,ti1,ti2 localobj d
		d = new Vector()
		if(apcvecList.o[0].size<3) {return abs(20 * $2) }//mV

		for (i=1;i<apcvecList.o[0].size-1;i+=1){
      if ((apcvecList.o[0].x[i+1]-apcvecList.o[0].x[i]) < 5) {
        ti1 = tvec.indwhere(">=",apcvecList.o[0].x[i])
      } else {
			  ti1 = tvec.indwhere(">=",apcvecList.o[0].x[i]+5)
			}
			ti2 = tvec.indwhere(">=",apcvecList.o[0].x[i+1])
			d.append(vList.o[0].c(ti1,ti2).min)
		}

		return (d.sub($1).abs().mean)
	}

	// $1 mean
	// $2 std
	func mean_spike_depth_slow_time(/*mean_depth*/)	{local i,ti1,ti2,vmin localobj d
		d = new Vector()
		if(apcvecList.o[0].size<3) {return abs(20 * $2) }//mV

		for (i=1;i<apcvecList.o[0].size-1;i+=1){
      if ((apcvecList.o[0].x[i+1]-apcvecList.o[0].x[i]) < 5) {
        ti1 = tvec.indwhere(">=",apcvecList.o[0].x[i])
      } else {
			  ti1 = tvec.indwhere(">=",apcvecList.o[0].x[i]+5)
			}
			ti2 = tvec.indwhere(">=",apcvecList.o[0].x[i+1])
			
      ti3 = vList.o[0].c(ti1,ti2).min_ind()
      d.append(((tvec.c(ti1,ti2).x[ti3])-apcvecList.o[0].x[i])/(apcvecList.o[0].x[i+1]-apcvecList.o[0].x[i]))
		}
		return (d.sub($1).abs().mean)
	}

	// $1 mean
	// $2 std
	func doublet_ISI() {local dbltISI
		if(apcvecList.o[0].size<2) {return abs(20 * $2) }//mV

		dbltISI = apcvecList.o[0].x[1] - apcvecList.o[0].x[0]

		return (abs(dbltISI - $1))
	}

	// $1 mean
	// $2 std
	// $3 stim_del
	// $4 stim_dur
	func pulseTimes() {local i, pulseFreq
    pulseFreq = (minspikenum-1)*1000/(stim_dur - 5) 
    if(apcvecList.o[0].size<minspikenum) {return abs(20 * $2) }//mV
    for(i=0;i<minspikenum;i+=1) {
      if((apcvecList.o[0].x[i] > $3 + i*1000/pulseFreq + 5) || (apcvecList.o[0].x[i] < $3 + i*1000/pulseFreq)) {return abs(20 * $2)}
    }

		return 0
	}

	// $1 mean
	// $2 std
	// $3 stimdel
	// $o4 the relevant dendritic voltage vector
  // $o5 the relevant dendritic APC vector
  // checks the backpropagating AP attenuation, as an amplitude
  func BPAPatt() {local b1,b2,r1,sh localobj h1,h2
    if(apcvecList.o[0].size!=1) {return abs(20 * $2) }
		if($o5.size!=1) {return abs(20 * $2) }
    
    b1 = voltage_base(vList.o[0],$3)
    b2 = voltage_base($o4,$3)
    h1 = calc_spike_height(thresh,vList.o[0],apcvecList.o[0])
    h2 = calc_spike_height(b2+2,$o4,$o5)

    sh = h2.x[0]-b2
    r1 = (h1.x[0]-b1)/sh

    if (r1 < 1) {return abs(20 * $2) } 
    return sh - $1
  }

	// $1 mean
	// $2 std
	// $3 stim delay+dur (end of stim)
  // The purpose of this error function is to punish prolonged bursts and no
  //  bursts, as well as measure the isi between the first two spikes.
	func BAC_ISI() {local ISI1, ISI2, ti1
		if((apcvecList.o[0].size != 2) && (apcvecList.o[0].size != 3)) {return abs(20 * $2) } //want a burst of exactly 2 or 3 spikes
    ti1 = tvec.indwhere(">=",$3)
    if(vList.o[0].x[ti1] > -55) {return abs(20 * $2) }//don't want endless plateaus
		
    ISI1 = apcvecList.o[0].x[1] - apcvecList.o[0].x[0]
    if (apcvecList.o[0].size == 3) {
      ISI2 = apcvecList.o[0].x[2] - apcvecList.o[0].x[1]
      } else {
        ISI2 = ISI1
        }

		return (1/2*abs((ISI1 - $1) + (ISI2 - $1)))
	}

	// $1 mean
	func Spikecount() {
		return (abs(apcvecList.o[0].size - $1))
	}

	obfunc calc_spike_depth(/*mean_depth*/)	{local i,st,ti1,ti2,ti3,ti4,base,del,ahp localobj d
		ahp = 0
		d = new Vector()
		for (i=0;i<apcvecList.o[0].size-1;i+=1){
			ti1 = tvec.indwhere(">=",apcvecList.o[0].x[i])
			ti2 = tvec.indwhere(">=",apcvecList.o[0].x[i+1])
			d.append(vList.o[0].c(ti1,ti2).min)
		}
		return (d.c)
	}

	func calc_trace_base(/*stim delay*/)	{local base,st,ti3,ti4
		st = 200
		ti3 = tvec.indwhere(">=", $1)
		ti4 = tvec.indwhere(">=", st)
		base = vList.o[0].c(ti4,ti3-1).mean
		return base
	}

	func ramp_spike_depth_slope(/*stim_del*/)	{local start,m localobj d,dd
		del = $1
		start = 0
		d = new Vector()
		d = calc_spike_depth($1)
		if(apcvecList.o[0].size<4) {return 0}//mV
		dd = d.c(start+1).sub(d.c(start,d.size-2))
		m =  dd.c(1).mean()
		return m
	}

	func ramp_spike_depth_base(/*stim_del*/)	{local start,o localobj d,dd
		del = $1
		start = 0
		d = new Vector()
		d = calc_spike_depth($1)
		if(apcvecList.o[0].size<4) {return d.x[0]}//mV
		o =  d.c(1,2).mean()
		return o
	}

	obfunc get_exp_trace()	{
		return exp_trace_list.o($1)
	}

	proc	set_spike_time_list(/*exp trace list, spike time list*/)	{local i localobj temp_vec
		for (i=0;i<$o1.count();i=i+1)	{
			temp_vec = new Vector()
			temp_vec = create_spike_target($o1.o(i))
			$o2.append(temp_vec)
		}
	}

	/******
	** Loads the experimental trace as the target
	**/

	obfunc create_spike_target(){local counter,indicator,vsize,g,exp_dt localobj analyse_vec
		analyse_vec = new Vector()
		counter=0
		indicator=0
		vsize=$o1.size()
		exp_dt = 0.25
		for (indicator=0;indicator<vsize;indicator=indicator+1){
			if ($o1.x(indicator)>0 && $o1.x(indicator-1) < 0) {counter=counter+1}
		}
		analyse_vec.resize(counter)
		analyse_vec.fill(0)
		counter = 0
		indicator = 0
		for (g=0;g<vsize;g=g+1){
			if ($o1.x(g)>0 && $o1.x(g-1) < 0) {
			analyse_vec.x[counter]=(g*0.25)
			counter = counter + 1
			}
		}
		return analyse_vec
	}

	func vector_spike_time_error(/*data_spike_time_vector,simulated_spike_time_vector, delay*/)	{local i,j,error,exp_spike_num,delay localobj exp_vec,sim_vec
		delay = $3
		exp_vec = $o1.sub(delay).div(1000)
		sim_vec = $o2.sub(delay).div(1000)
		error = 0
		i = 0
		exp_spike_num = exp_vec.size
		for (i=0;i<exp_vec.size;i=i+1)	{
			if (i<sim_vec.size)	{
				error = error + abs(exp_vec.x(i)-sim_vec.x(i))/initial_bias(sim_vec.x[i])
			}
		}
		error = error + (abs(exp_vec.size-sim_vec.size)*(0.5/(exp_vec.size^0.6)))
		error = error/exp_vec.size
		return error
	}

	func theta_st(/*simulated_spike_num,data_spike_index*/)	{
		if (($1-1)<$2)		{return	0}	else	{return	1}
	}

	func initial_bias(/*simulated_spike_num,data_spike_index*/)	{local bias, pow_1
		pow_1 = 0.4
		if ($1<0.01)		{return	(0.01)^pow_1}	else	{return	($1)^pow_1}
	}

	func list_spike_time_error(/*data_spike_time_list,simulated_spike_time_list*/)	{local i,j,error,spike_num
		error = 0
		spike_num = 0
		if ($o1.count != $o2.count)	{print "simulated and data trace number mismatch" return -1}
		for (i=0;i<$o1.count;i=i+1)	{
			spike_num = spike_num + $o1.o(i).size
			for (j=0;j<$o1.o(i).size;j=j+1)	{

			}
		}
		return error
	}

endtemplate DistanceCalculator
