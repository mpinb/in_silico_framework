
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>project_specific_ipynb_code.neurobiological_design_principles &#8212; In-Silico Framework (ISF) 0.0.1 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for project_specific_ipynb_code.neurobiological_design_principles</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">Interface</span> <span class="k">as</span> <span class="nn">I</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">from</span> <span class="nn">torch</span> <span class="kn">import</span> <span class="n">nn</span>
<span class="kn">import</span> <span class="nn">torch.nn.functional</span> <span class="k">as</span> <span class="nn">F</span>
<span class="kn">import</span> <span class="nn">torch.nn.utils.prune</span> <span class="k">as</span> <span class="nn">prune</span>

<div class="viewcode-block" id="get_cell_info"><a class="viewcode-back" href="../../project_specific_ipynb_code.html#project_specific_ipynb_code.neurobiological_design_principles.get_cell_info">[docs]</a><span class="k">def</span> <span class="nf">get_cell_info</span><span class="p">(</span><span class="n">cellID</span><span class="p">,</span> <span class="n">cis_realisation</span><span class="p">):</span>
    <span class="n">neurons_df</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">cis_realisation</span> <span class="o">+</span> <span class="s1">&#39;neurons.csv&#39;</span><span class="p">)</span>
    <span class="n">celltypes_df</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">cis_realisation</span> <span class="o">+</span> <span class="s1">&#39;cell_types.csv&#39;</span><span class="p">)</span>
    
    <span class="n">cellID</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">cellID</span><span class="p">)</span>
    <span class="n">celltype_id</span> <span class="o">=</span> <span class="n">neurons_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">cellID</span><span class="p">,</span> <span class="s1">&#39;cell_type&#39;</span><span class="p">]</span>
    <span class="n">celltype</span> <span class="o">=</span> <span class="n">celltypes_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">celltype_id</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">]</span>
    
    <span class="n">x</span> <span class="o">=</span> <span class="n">neurons_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">cellID</span><span class="p">,</span> <span class="s1">&#39;soma_x&#39;</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">neurons_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">cellID</span><span class="p">,</span> <span class="s1">&#39;soma_y&#39;</span><span class="p">]</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">neurons_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">cellID</span><span class="p">,</span> <span class="s1">&#39;soma_z&#39;</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">celltype</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)</span></div>

<span class="c1">##########################</span>
<span class="c1"># SET UP A TORCH NETWORK #</span>
<span class="c1">##########################</span>
<div class="viewcode-block" id="get_input_mask"><a class="viewcode-back" href="../../project_specific_ipynb_code.html#project_specific_ipynb_code.neurobiological_design_principles.get_input_mask">[docs]</a><span class="k">def</span> <span class="nf">get_input_mask</span><span class="p">(</span><span class="n">rnn_nodes</span><span class="p">,</span> <span class="n">cis_realisation</span><span class="p">,</span> <span class="n">input_celltype</span><span class="p">,</span> <span class="n">input_node_assignments</span><span class="p">,</span> <span class="n">input_len</span> <span class="o">=</span> <span class="mi">28</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;This function determines which nodes should receive which input connections. Should be applied as a pruning mask to the weight_ih_l0 parameter of the rnn layer.</span>
<span class="sd">        rnn_nodes: list of cell identifiers</span>
<span class="sd">        input_celltype: str, e.g. &#39;VPM&#39; or &#39;VPM_C2&#39;</span>
<span class="sd">        input_node_assignments: nested list of len input_len, where each list contains cell identifiers for all input cells that should be mapped to the corresponding input pixel</span>
<span class="sd">        input_len: int, optional (default = 28, for MNIST dataset), determines size of mask&#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">has_input</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">input_celltype</span><span class="p">):</span>
        <span class="n">pre_celltypes</span> <span class="o">=</span> <span class="n">con</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="c1"># input_celltype has format &#39;VPM_C2&#39;</span>
        <span class="k">if</span> <span class="n">input_celltype</span> <span class="ow">in</span> <span class="n">pre_celltypes</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="n">pre_celltypes_split</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">pre_celltypes</span><span class="p">]</span> <span class="c1"># input_celltype has format &#39;VPM&#39;</span>
        <span class="k">if</span> <span class="n">input_celltype</span> <span class="ow">in</span> <span class="n">pre_celltypes_split</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>        
            <span class="k">return</span> <span class="kc">False</span>
    
    <span class="n">cells_with_direct_input</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">rnn_nodes</span><span class="p">:</span>
        <span class="n">con</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">scp</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">read_functional_realization_map</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cis_realisation</span><span class="p">,</span> <span class="s1">&#39;post_neurons&#39;</span><span class="p">,</span> <span class="n">cell</span><span class="p">,</span> <span class="n">cell</span><span class="o">+</span><span class="s1">&#39;.con&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">has_input</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="n">input_celltype</span><span class="p">):</span>
            <span class="n">input_origins</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">con</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">input_celltype</span> <span class="ow">in</span> <span class="n">k</span><span class="p">]</span> <span class="c1"># works for both input_celltype &#39;VPM&#39; and &#39;VPM_C2&#39;</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">con</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">input_origins</span><span class="p">]</span>
            <span class="n">flat_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">inputs</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]</span>
            <span class="n">cells_with_direct_input</span><span class="p">[</span><span class="n">cell</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">flat_inputs</span><span class="p">)</span>
    
    <span class="n">input_mask</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">rnn_nodes</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">presyns</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">cells_with_direct_input</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">cell</span><span class="p">)]]</span> <span class="c1"># cell IDs of presynaptic input cells</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span> <span class="c1"># this cell doesn&#39;t receive input from the target population</span>
            <span class="n">input_mask</span><span class="p">[</span><span class="n">cell</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">input_len</span>
            <span class="k">continue</span>

        <span class="n">pixels_in</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># map to pixel index</span>
        <span class="k">for</span> <span class="n">pre</span> <span class="ow">in</span> <span class="n">presyns</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">input_node_assignments</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">pre</span> <span class="ow">in</span> <span class="n">v</span><span class="p">:</span>
                    <span class="n">pixels_in</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">input_mask</span><span class="p">[</span><span class="n">cell</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pixels_in</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">input_len</span><span class="p">)]</span>
        
    <span class="k">return</span> <span class="n">input_mask</span></div>

<div class="viewcode-block" id="get_connection_matrix_from_realisation"><a class="viewcode-back" href="../../project_specific_ipynb_code.html#project_specific_ipynb_code.neurobiological_design_principles.get_connection_matrix_from_realisation">[docs]</a><span class="k">def</span> <span class="nf">get_connection_matrix_from_realisation</span><span class="p">(</span><span class="n">cis_realisation</span><span class="p">):</span>
    <span class="n">post_cells_dir</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cis_realisation</span><span class="p">,</span> <span class="s1">&#39;post_neurons&#39;</span><span class="p">)</span>
    <span class="n">post_cells</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">post_cells_dir</span><span class="p">)</span>
    
    <span class="nd">@I</span><span class="o">.</span><span class="n">dask</span><span class="o">.</span><span class="n">delayed</span>
    <span class="k">def</span> <span class="nf">write_con_matrix_row</span><span class="p">(</span><span class="n">post_cell</span><span class="p">):</span>
        <span class="n">con_df</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">post_cell</span><span class="p">],</span> <span class="n">index</span> <span class="o">=</span> <span class="n">post_cells</span><span class="p">)</span>
        <span class="n">con</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">scp</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">read_functional_realization_map</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">post_cells_dir</span><span class="p">,</span> <span class="n">post_cell</span><span class="p">,</span> <span class="n">post_cell</span><span class="o">+</span><span class="s1">&#39;.con&#39;</span><span class="p">))</span>

        <span class="c1"># get list of all unique presynaptic cells</span>
        <span class="n">pre_cells</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">celltype</span> <span class="ow">in</span> <span class="n">con</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">con</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">celltype</span><span class="p">]</span>
            <span class="n">pre_cells</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">l</span><span class="p">]))</span>

        <span class="n">row</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span> <span class="ow">in</span> <span class="n">pre_cells</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">post_cells</span><span class="p">]</span>
        <span class="n">con_df</span><span class="p">[</span><span class="n">post_cell</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span>    

        <span class="k">return</span> <span class="n">con_df</span><span class="o">.</span><span class="n">T</span>
    
    <span class="n">ds</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">post_cells</span><span class="p">:</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">write_con_matrix_row</span><span class="p">(</span><span class="n">cell</span><span class="p">))</span>
        
    <span class="n">client</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">distributed</span><span class="o">.</span><span class="n">Client</span><span class="p">(</span><span class="s1">&#39;localhost:38786&#39;</span><span class="p">)</span>
    
    <span class="n">fs</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
    <span class="n">out_df</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out_df</span></div>


<div class="viewcode-block" id="make_cis_ann_binary"><a class="viewcode-back" href="../../project_specific_ipynb_code.html#project_specific_ipynb_code.neurobiological_design_principles.make_cis_ann_binary">[docs]</a><span class="k">def</span> <span class="nf">make_cis_ann_binary</span><span class="p">(</span><span class="n">cis_realisation</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">con</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">input_mask</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">weight_min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">weight_max</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">input_size</span> <span class="o">=</span> <span class="mi">28</span><span class="p">,</span> <span class="n">input_celltype</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">L5PTs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">inhs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">num_classes</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">rand_seed</span> <span class="o">=</span> <span class="mi">42</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Fully sets up a torch RNN based on a cortex in silico realization folder, where cells that are not connected in CIS have unconnected nodes in the RNN. Other weights are initialised randomly, with inhibitory connections receiving negative weights and excitatory connections receiving positive weights.</span>
<span class="sd">        cis_realisation: str, filepath to cortex in silico folder ending in realization_YYYY-MM-DD/</span>
<span class="sd">        con: pandas dataframe, optional, shape cells x cells, containing 1 if cells are connected and 0 if not. Skips generating connection matrix if you already have one, as this takes some time.</span>
<span class="sd">        input_mask: torch tensor, optional (will be generated if not supplied, it just takes a long time)</span>
<span class="sd">        weight_min, weight_max: float, optional (default min 0, max 1). Initial weights will be sampled with a uniform distribution between weight_min and weight_max. Weights for inhibitory connections will be uniformly sampled between -weight_max and -weight_min.</span>
<span class="sd">        input_size: int, optional (default 28 for MNIST dataset)</span>
<span class="sd">        input_celltype: str, e.g. &#39;VPM&#39; or &#39;VPM_C2&#39;</span>
<span class="sd">        num_classes: int, optional (default 10 for MNIST dataset)</span>
<span class="sd">        rand_seed: int, optional (default 42), ensures reproducibility.&#39;&#39;&#39;</span>
    <span class="c1">## get information about anatomical connectivity from cortex in silico realisation</span>
    <span class="k">assert</span> <span class="n">input_celltype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">con</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;generating connection matrix...&#39;</span><span class="p">)</span>
        <span class="n">con</span> <span class="o">=</span> <span class="n">get_connection_matrix_from_realisation</span><span class="p">(</span><span class="n">cis_realisation</span><span class="p">)</span>
   
    <span class="n">rnn_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">con</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">L5PTs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;reading cell types...&#39;</span><span class="p">)</span>
        <span class="n">L5PTs</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rnn_nodes</span><span class="p">)</span> <span class="k">if</span> <span class="n">get_cell_info</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">cis_realisation</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;L5tt&#39;</span><span class="p">]</span> <span class="c1"># output layer</span>
        <span class="n">inhs</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rnn_nodes</span><span class="p">)</span> <span class="k">if</span> <span class="n">get_cell_info</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">cis_realisation</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">I</span><span class="o">.</span><span class="n">inhibitory</span><span class="p">]</span> <span class="c1"># identify inhibitory cells</span>
    
    <span class="c1">## set up a basic torch RNN with a fully connected output layer</span>
    <span class="n">torch</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="n">rand_seed</span><span class="p">)</span>
    <span class="k">class</span> <span class="nc">RNN</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_size</span><span class="p">,</span> <span class="n">hidden_size</span><span class="p">,</span> <span class="n">num_layers</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">):</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">RNN</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span> <span class="c1"># initialise the nn.Module</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hidden_size</span> <span class="o">=</span> <span class="n">hidden_size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_layers</span> <span class="o">=</span> <span class="n">num_layers</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rnn</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">RNN</span><span class="p">(</span><span class="n">input_size</span><span class="p">,</span> <span class="n">hidden_size</span><span class="p">,</span> <span class="n">num_layers</span><span class="p">,</span> <span class="n">nonlinearity</span> <span class="o">=</span> <span class="s1">&#39;relu&#39;</span><span class="p">,</span> <span class="n">batch_first</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fc</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">L5PTs</span><span class="p">),</span> <span class="n">num_classes</span><span class="p">)</span>


        <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
            <span class="c1"># set initial hidden state</span>
            <span class="n">h0</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_layers</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">hidden_size</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
            <span class="c1"># forward run model</span>
            <span class="n">output</span><span class="p">,</span> <span class="n">hidden</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnn</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">h0</span><span class="p">)</span> <span class="c1"># output shape (batch_size, seq_length, hidden_size)</span>

            <span class="c1"># reshape the output so it fits into the fully connected layer (get the last output from the L5PTs)</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">output</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">L5PTs</span><span class="p">]</span> <span class="c1"># shape (sample, timestep, node)</span>
            <span class="c1"># pass it to the linear layer</span>
            <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fc</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">output</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;setting up torch network...&#39;</span><span class="p">)</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">RNN</span><span class="p">(</span><span class="n">input_size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">rnn_nodes</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;modifying hidden layer...&#39;</span><span class="p">)</span>
    <span class="c1">## apply the anatomical information to the torch network</span>
    <span class="n">rnn_layer</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">rnn</span>
    <span class="n">rnn_layer</span><span class="o">.</span><span class="n">weight_hh_l0</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">uniform_</span><span class="p">(</span><span class="n">rnn_layer</span><span class="o">.</span><span class="n">weight_hh_l0</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">weight_min</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">weight_max</span><span class="p">)</span> <span class="c1"># randomly initialise weights</span>
    <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
        <span class="n">rnn_layer</span><span class="o">.</span><span class="n">weight_hh_l0</span><span class="p">[:,</span> <span class="n">inhs</span><span class="p">]</span><span class="o">*=-</span><span class="mi">1</span> <span class="c1"># make connections from inhibitory celltypes negative</span>
    
    <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">con</span><span class="o">.</span><span class="n">index</span><span class="p">)):</span> <span class="c1"># allow self-self connections, which reflects persistent cell state</span>
        <span class="n">con</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">cell</span><span class="p">,</span> <span class="n">cell</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        
    <span class="n">mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">con</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span>
    <span class="n">prune</span><span class="o">.</span><span class="n">custom_from_mask</span><span class="p">(</span><span class="n">rnn_layer</span><span class="p">,</span> <span class="s1">&#39;weight_hh_l0&#39;</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span> <span class="c1"># remove connections not present in the anatomical model</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;modifying input layer...&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">input_mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">input_mask</span> <span class="o">=</span> <span class="n">get_input_mask</span><span class="p">(</span><span class="n">rnn_nodes</span><span class="p">,</span> <span class="n">cis_realisation</span><span class="p">,</span> <span class="n">input_celltype</span><span class="p">,</span> <span class="n">input_node_assignments</span><span class="p">,</span> <span class="n">input_len</span> <span class="o">=</span> <span class="n">input_size</span><span class="p">)</span> <span class="c1"># give each cell appropriate input</span>
        <span class="n">input_mask_list</span> <span class="o">=</span> <span class="p">[]</span> 
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">rnn_nodes</span><span class="p">:</span>
            <span class="n">input_mask_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_mask</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
        <span class="n">input_mask_tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">input_mask_list</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">input_mask_tensor</span> <span class="o">=</span> <span class="n">input_mask</span>
    <span class="n">prune</span><span class="o">.</span><span class="n">custom_from_mask</span><span class="p">(</span><span class="n">rnn_layer</span><span class="p">,</span> <span class="s1">&#39;weight_ih_l0&#39;</span><span class="p">,</span> <span class="n">input_mask_tensor</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">model</span></div>

<div class="viewcode-block" id="make_dummy_ann"><a class="viewcode-back" href="../../project_specific_ipynb_code.html#project_specific_ipynb_code.neurobiological_design_principles.make_dummy_ann">[docs]</a><span class="k">def</span> <span class="nf">make_dummy_ann</span><span class="p">(</span><span class="n">input_size</span> <span class="o">=</span> <span class="mi">28</span><span class="p">,</span> <span class="n">L5PTs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">num_classes</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">rnn_nodes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">device</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Sets up a torch RNN as a foundation for loading an existing trained model&#39;s parameters into.</span>
<span class="sd">        input_size: int, optional (default 28 for MNIST dataset)</span>
<span class="sd">        num_classes: int, optional (default 10 for MNIST dataset)&#39;&#39;&#39;</span>
             
    <span class="c1">## set up a basic torch RNN with a fully connected output layer</span>
    <span class="k">class</span> <span class="nc">RNN</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_size</span><span class="p">,</span> <span class="n">hidden_size</span><span class="p">,</span> <span class="n">num_layers</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">):</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">RNN</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span> <span class="c1"># initialise the nn.Module</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hidden_size</span> <span class="o">=</span> <span class="n">hidden_size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_layers</span> <span class="o">=</span> <span class="n">num_layers</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rnn</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">RNN</span><span class="p">(</span><span class="n">input_size</span><span class="p">,</span> <span class="n">hidden_size</span><span class="p">,</span> <span class="n">num_layers</span><span class="p">,</span> <span class="n">nonlinearity</span> <span class="o">=</span> <span class="s1">&#39;relu&#39;</span><span class="p">,</span> <span class="n">batch_first</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fc</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">L5PTs</span><span class="p">),</span> <span class="n">num_classes</span><span class="p">)</span>


        <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
            <span class="c1"># set initial hidden state</span>
            <span class="n">h0</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_layers</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">hidden_size</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
            <span class="c1"># forward run model</span>
            <span class="n">output</span><span class="p">,</span> <span class="n">hidden</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rnn</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">h0</span><span class="p">)</span> <span class="c1"># output shape (batch_size, seq_length, hidden_size)</span>

            <span class="c1"># reshape the output so it fits into the fully connected layer (get the last output from the L5PTs)</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">output</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">L5PTs</span><span class="p">]</span> <span class="c1"># shape (sample, timestep, node)</span>
            <span class="c1"># pass it to the linear layer</span>
            <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fc</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">output</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;setting up torch network...&#39;</span><span class="p">)</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">RNN</span><span class="p">(</span><span class="n">input_size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">rnn_nodes</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">model</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">In-Silico Framework (ISF)</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">in_silico_framework</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, Arco Bast, Amir Najafgholi, Maria Royo Cano, Rieke Fruengel, Matt Keaton, Bjorge Meulemeester, Omar Valerio.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>