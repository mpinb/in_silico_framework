/******************************************
File that contains functions to parse BlueFit configuration files.
Most functions revised from ParseBlueConfig

Author: Shaul Druckmann Hebrew U October 2006

Modified by: Etay Hay, Hebrew University of Jerusalem, 2011
******************************************/

begintemplate ParserFunctions

	objref config_file
	objref strobj
	strdef str_1,str_2,str_3,str_4,str_5
		
	public locate_file_section, read_string_parameter_list, read_numerical_parameter_list
	public generate_header_list, populate_full_list, locate_bracket
	public get_string_var, get_floating_var, locate_header
	
	proc init()	{
		config_file = new File()
		strobj = new StringFunctions()
	}
	
	obfunc locate_file_section()	{local i,l,a,b localobj bound_vec
		bound_vec = new Vector(2)
		str_1 = ""
		a = 0
		b = 0
// 		l = get_file_length($s1)
// 		if ($2>l)	{
// 			print "Not that many lines in file"
// 			return bound_vec
// 			}
		config_file.ropen($s1)
		config_file.seek($2)
		//for i=0,$2-1	{config_file.gets(str_1)}
		config_file.gets(str_1)
		while(config_file.gets(str_1) >= 0){
			sscanf(str_1, "%s%*s",str_2)
			if (0==strcmp(str_2,$s3))	{
				config_file.gets(str_1)
				sscanf(str_1, "%s%*s",str_2)
				if (0==strcmp(str_2,"{"))	{a = config_file.tell}
			}
			if (0==strcmp(str_2,"}") && a!= 0 && b==0)	{b = config_file.tell	break}
		}
		config_file.close
		bound_vec.x[0] = a
		bound_vec.x[1] = b
		return bound_vec
	}
	
	func get_file_length()	{local l
		l = 0
		str_1 = ""
		config_file.ropen($s1)
		while(config_file.gets(str_1) >= 0){l = l + 1}
		config_file.close
		return l
	}
	
	proc read_string_parameter_list()	{local i
		str_1 = ""
		config_file.ropen($s1)
		config_file.seek($o2.x[0])
		while(config_file.gets(str_1) >= 0){
			if (config_file.tell >= $o2.x[1])	{break}	
			sscanf(str_1, "%s%s",str_2,str_3)
			$o3.append(new String(str_2))
			$o4.append(new String(str_3))
			//print "first ", str_2, " then ", str_3
		}
		config_file.close
	}
	
	proc read_numerical_parameter_list()	{local i, value
		str_1 = ""
		config_file.ropen($s1)
		config_file.seek($o2.x[0])
		while(config_file.gets(str_1) >= 0){
			if (config_file.tell >= $o2.x[1])	{break}	
			sscanf(str_1, "%s%lf",str_2, &value)
			$o3.append(new String(str_2))
			$o4.append(value)
			//print "first ", str_2, " then ", value
		}
		config_file.close
	}
	
	func locate_header()	{local n,a
		a = 0
		n = numarg()
		str_1 = ""
		config_file.ropen($s1)
		config_file.seek(0)
		while(config_file.gets(str_1) >= 0){
			sscanf(str_1, "%s%s",str_2,str_3)
			//print "first ", str_2, " then ", str_3
			if (0==strcmp(str_2,$s2))	{
				if (n == 2)	{return config_file.tell}
				if (0==strcmp(str_3,$s3))	{return config_file.tell}
			}
		}
		config_file.close
		return a
	}
	
	/**********************************************************************************
	(f)
	This function returns a list of all the 'objects' with a certain header
	
	Inputs  :   $s1 - Config file name with complete path.
		$s2 - Header to be found.
		$o3 - List object to be populated.
		
	Usage   :  GetReportList("/home/teki/work/Parser/ParseBlueConfig/BlueConfig",list)
	
	Note	: This does not delete the current members of list but appends to it
	***********************************************************************************/
	func generate_header_list(){ local report_flag
	config_file.ropen($s1)
	report_flag = 0
	if (config_file.isopen == 0) {
		printf("Error: Could not open Input Spec file: ", $s1)
		execerror("Error: Could not open Input spec file: ", $s1)        
		return 0
	}
	str_1 = ""
	while(config_file.gets(str_1) >= 0){
		sscanf(str_1, "%s",str_2)
		if(0 == strcmp(str_2, $s2)){
		sscanf(str_1, "%*s%s",str_2)
		$o3.append(new String(str_2))
		report_flag = 1
		}
	}
	config_file.close()
	if (report_flag == 1)	{return(1)} else {return(0)}  
	}
	
	/**********************************************************************************
	(f)
	This function returns a list of all the 'objects' with a certain header
	
	Inputs  :   $s1 - Config file name with complete path.
		$s2 - Header to be found.
		$s3 - Name to be found.
		$o4 - List object to be populated.
		
	Usage   :  GetReportList("/home/teki/work/Parser/ParseBlueConfig/BlueConfig",list)
	
	Note	: This does not delete the current members of list but appends to it
	***********************************************************************************/
	func populate_full_list(){ local report_flag,bracket_flag
	//$o2 = new List()
	config_file.ropen($s1)
	//config_file.ropen("fit_channels.hoc")
	report_flag = 0
	barcket_flag = 0
	
	if (config_file.isopen == 0) {
		printf("Error: Could not open Input Spec file: ", $s1)
		execerror("Error: Could not open Input spec file: ", $s1)        
		return 0
	}
	str_1 = ""
	while(config_file.gets(str_1) >= 0){
		sscanf(str_1, "%s",str_2)
		print str_1
		if(0 == strcmp(str_2, $s2)){
		sscanf(str_1, "%*s%s",str_2)
		if(0 == strcmp(str_2, $s3)){
			bracket_flag = 1
			report_flag = 1
			config_file.gets(str_1)
			while(bracket_flag && (config_file.gets(str_1)>=0)){                    
			
			sscanf(str_1,"%s", str_2)
			
			if(0 == strcmp(str_2, "}")){
				bracket_flag = 0
				config_file.close()
				return(0)
			}
			$o4.append(new String(str_2)) 
			}
		} 
		}
	}
	config_file.close()
	if (report_flag == 1)	{return(1)} else {return(0)}  
	}
	
	/**********************************************************************************
	(f)
	This function looks in all header lines for a certain name
	and within it looks for a certain _FLOATING POINT_ variable.
	
	Inputs  :   $s1 - Config file name with complete path.
		$s2 - Header to be found.
		$s3 - Name under header.
		$s4 - Variable name.
	Usage   :  
	
	***********************************************************************************/
	
	func get_floating_var()	{ local bracket_flag,value
	//print "running get floating"
	//print "\nStimulus Injected:", $s2
	//print "Parameter:", $s3
	//StimInjectFlag      =  0
	config_file.ropen($s1)
	if (config_file.isopen == 0) {
		printf("Error: Could not open config file: ", $s1)
		execerror("Error: Could not open config file: ", $s1)        
		return 0
	}
	bracket_flag = 0
	value = 0
	str_1 = ""
	
	while(config_file.gets(str_1) >= 0){
		sscanf(str_1, "%s",str_2)
		//sprint str_2
		if(0 == strcmp(str_2, $s2)){
		//print "found header"
		sscanf(str_1, "%*s%s", str_2)            
		//print "arf"
		if(0 == strcmp(str_2, $s3)){
			//print "found name"
			bracket_flag = 1                
			while(bracket_flag && (config_file.gets(str_1)>=0)){                    
			sscanf(str_1,"%s", str_2)                    
			if(0 == strcmp(str_2, $s4)){
				//print "found"
				//print str_1
				sscanf(str_1,"%*s%lf", &value)
				//print value
				config_file.close()
				return(value)
			} 
			if(0 == strcmp(str_2, "}")){
				bracket_flag = 0
				config_file.close()
				return(0)
			} 
			}
		}
		}
	}    
	config_file.close()
	return(0)
	}
	
	/**********************************************************************************
	(f)
	This function looks in all header lines for a certain name
	and within it looks for a certain _STRING_ variable.
	
	Inputs  :   $s1 - Config file name with complete path.
		$s2 - Header to be found.
		$s3 - Name under header.
		$s4 - Variable name.
		$s5 - String to receive answer
	Usage   :  
	
	***********************************************************************************/
	
	func get_string_var()	{ local bracket_flag,value
	//print "running get floating"
	//print "\nStimulus Injected:", $s2
	//print "Parameter:", $s3
	//StimInjectFlag      =  0
	config_file.ropen($s1)
	if (config_file.isopen == 0) {
		printf("Error: Could not open config file: ", $s1)
		execerror("Error: Could not open config file: ", $s1)        
		return 0
	}
	bracket_flag = 0
	value = 0
	str_1 = ""
	
	while(config_file.gets(str_1) >= 0){
		sscanf(str_1, "%s",str_2)
		//sprint str_2
		if(0 == strcmp(str_2, $s2)){
		//print "found header"
		sscanf(str_1, "%*s%s", str_2)            
		//print "arf"
		if(0 == strcmp(str_2, $s3)){
			//print "found name"
			bracket_flag = 1                
			while(bracket_flag && (config_file.gets(str_1)>=0)){                    
			sscanf(str_1,"%s", str_2)                    
			if(0 == strcmp(str_2, $s4)){
				//print "found"
				//print str_1
				sscanf(str_1,"%*s%s", str_2)
				$s5 = str_2
				config_file.close()
				return(1)
			} 
			if(0 == strcmp(str_2, "}")){
				bracket_flag = 0
				config_file.close()
				return(0)
			} 
			}
		}
		}
	}    
	config_file.close()
	return(0)
	}
	
	/**********************************************************************************
	(f)
	This function looks in all header lines for a certain name
	and within it looks for a certain _STRING_ variable.
	
	Inputs  :   $s1 - Config file name with complete path.
		$s2 - Header to be found.
		$s3 - Name under header.
		$s4 - Variable name.
		$o5 - Vector to receive answer.
	Usage   :  
	
	***********************************************************************************/
	
	func get_vector_var()	{local bracket_flag,value
	config_file.ropen($s1)
	if (config_file.isopen == 0) {
		printf("Error: Could not open config file: ", $s1)
		execerror("Error: Could not open config file: ", $s1)        
		return 0
	}
	bracket_flag = 0
	value = 0
	str_1 = ""
	
	while(config_file.gets(str_1) >= 0){
		sscanf(str_1, "%s",str_2)
		//sprint str_2
		if(0 == strcmp(str_2, $s2)){
		//print "found header"
		sscanf(str_1, "%*s%s", str_2)            
		//print "arf"
		if(0 == strcmp(str_2, $s3)){
			//print "found name"
			bracket_flag = 1                
			while(bracket_flag && (config_file.gets(str_1)>=0)){                    
			sscanf(str_1,"%s", str_2)                    
			if(0 == strcmp(str_2, $s4)){
				//print "found"
				//print str_1
				sscanf(str_1,"%s", str_2)
				strobj.tail(str_1,str_2,str_3)
				//print str_3
				$o5 = break_string_to_vector(str_3)
				config_file.close()
				return(1)
			} 
			if(0 == strcmp(str_2, "}")){
				bracket_flag = 0
				config_file.close()
				return(0)
			} 
			}
		}
		}
	}    
	config_file.close()
	return(0)
	}
	
	/**********************************************************************************
	(f)
	This function breaks a string that contains numbers into a vector of those
	numbers.
	
	Inputs  :   $s1 - String to be broken into a vector
	
	Usage   :  
	
	***********************************************************************************/
	
	obfunc break_string_to_vector()	{local value	localobj temp_vector
		str_4 = $s1
		value = 0
		temp_vector = new Vector()
		while (strobj.len(str_4)>1)	{
			sscanf(str_4,"%s", str_3)
			sscanf(str_4,"%lf", &value)
			temp_vector.append(value)
			strobj.tail(str_4,str_3,str_4)
	//		print str_4
		}
		return temp_vector
	}
	
	/**********************************************************************************
	(f)
	This function breaks a string that contains strings into a vector of those
	substrings
	
	Inputs  :   $s1 - String to be broken into substrings.
		$o2 - List to be populated
	Usage   :  
	
	***********************************************************************************/
	
	func break_dot_string()	{local value, dot_flag,index,a
		dot_flag = 0
		str_1 = $s1
		value = 0
		while (strobj.len(str_1)>1)	{
		//while (strobj.substr(str_1,".")>0)	{
		//for (i=1;i<=$2;i=i+1)	{
			//str_3 = "."
			//print "str_1 before is ", str_1
			str_2 = str_1
			index = strobj.substr(str_1,".")
			//print "index is ", index
			//print str_3
			//if (strobj.head(str_1,str_3,str_2)>0)	{$o2.append(new String(str_2))} else {$o2.append(new String(str_1))}
			//if (strobj.left(str_1,index)>0)	{$o2.append(new String(str_2))} else {$o2.append(new String(str_1))}
			if (index>0)	{
				strobj.right(str_1,index+1)
				//print "a is ", a
				strobj.left(str_2,index)
				//print "str1 after is ", str_1
				//print "str2 after is ", str_2
				$o2.append(new String(str_2))
			} else	{
				//print "str2 is ", str_2
				$o2.append(new String(str_2))
				str_1 = ""
			}
			dot_flag = 1
			//strobj.tail(str_1,"_",str_1)
		}
		return(dot_flag)
	}
	
	/***************************************************************************************
	(g)
	This function returns tokens from a string of numeric values.
	
	Usage   :  GetTokens(str, Empty list object to store tokens)
	****************************************************************************************/
	
	func GetTokens(){ local RetVal, length localobj strobj
	strobj = new StringFunctions()
	strdef str, Token
	//print "\nthe string is: ", $s1
	str = $s1
	i = 0
	while(1){
		RetVal = 0
		RetVal = sscanf(str, "%s", Token)
		if(RetVal <1) {        
		break
		}
		i = i+1
		$o2.append(new String(Token))
		//print "Value#", i, "= ", Token
		//i = i+1
		RetVal = 0
		RetVal = strobj.substr(str,Token)
		if(RetVal <0){
		break
		}
		length = 0
		length = strobj.len(Token)
		strobj.right(str, length+RetVal )
	}
	return i
	}// end of GetTokens()
	
	proc create_insertion_list()	{local i	
			//print $o1.o(0).s
			for (i=0;i<$o1.count;i=i+1)	{
				//s_1 = channel_type_list.o(i).s
				str_1 = $o2.o(i).s
				//s_2 = channel_subset_list.o(i).s
				str_2 = $o3.o(i).s
				//print str_1
				//print str_2
				//sprint(final_string,"forsec(%s)   {insert %s}",s_2,s_1)
				sprint(str_3,"forsec \"%s\" insert %s",str_2,str_1)
				//print "printing final string"
				//print str_3
				//insertion_list.append(new String(final_string))
				$o4.append(new String(str_3))
			}
		}
	
	proc create_parameter_setting_list()	{local i	
		//print $o1.o(0).s
		for (i=0;i<$o1.count;i=i+1)	{
			//s_1 = channel_type_list.o(i).s
			str_1 = $o2.o(i).s
			//s_2 = channel_subset_list.o(i).s
			str_2 = $o3.o(i).s
			str_3 = $o4.o(i).s
			//print str_1
			//print str_2
			//sprint(final_string,"forsec(%s)   {insert %s}",s_2,s_1)
			//sprint(str_4,"forsec \"%s\" %s_%s = assign_vec.x[i]",str_2,str_1,str_3)
			sprint(str_4,"forsec \"%s\" %s_%s = ",str_2,str_1,str_3)
			//print "printing final string"
			//print str_4
			//insertion_list.append(new String(final_string))
			$o5.append(new String(str_4))
		}
	}

endtemplate ParserFunctions