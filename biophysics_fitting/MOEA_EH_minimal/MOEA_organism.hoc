/*****************************************************
*Template for genetic algorithm in NEURON
*Author: Shaul Druckmann, Hebrew U, May 2006
*
*Modified by: Etay Hay, Hebrew University of Jerusalem, 2011
*****************************************************/

begintemplate Organism
	objref org_genome,org_ran,mutate_ran, org_fitness_vec
	public org_genome, org_genome_size
	public gene_num,seed,generation
	public create_random, set_genome, uniform_mutate_org,non_uniform_mutate_org
	public pass_fitness,pass_genome,set_organism_fitness
	public pass_fitness_vec, set_organism_fitness_vec
	public non_uniform_single_mutate_org
	
	proc init()	{
		gene_num = $1
		org_genome_size = $2
		seed = $3
		p_mutate = $4
		objective_num = $5
		
		org_fitness_vec = new Vector(objective_num)
		org_genome = new Vector(org_genome_size)
		org_ran = new Random(seed)
		mutate_ran = new Random(seed)
		mutate_ran.uniform(0,1)
		
		fitness = 0
		generation = 0
	}

	proc uniform_mutate_org()	{local i localobj g_mat,temp_vec
 		g_mat = $o1
 		temp_vec = org_genome.c
 		for (i=0;i<org_genome_size;i=i+1)	{
 			min = g_mat.x[i][0]
 			max = g_mat.x[i][1]
			org_ran.uniform(min,max)
 			if (mutate_ran.repick()<p_mutate)	{temp_vec.x[i] = org_ran.repick()}

 		}
 		org_genome = temp_vec.c
	}

	proc non_uniform_mutate_org()	{local i,t,x,span,r,current_generation,max_generation,b localobj g_mat,temp_vec
	//
	//	CHECK VALIDITY
	//
		g_mat = $o1
	 	current_generation = $2
	 	max_generation = $3
	 	//b = 0.5	CHANGE 8.2
	 	//c = sqrt(2)	CHANGE 8.2
		b = 2
		c = 1
		// HACKED IN C AS A CONSTANT TO IMPROVE ANNEALING
		temp_vec = org_genome.c
	 	org_ran.uniform(0,1)
	 	mutate_ran.uniform(0,1)
	 	for (i=0;i<org_genome_size;i=i+1)	{
	 		x = mutate_ran.repick
	 		if (x<p_mutate)	{
	 			if (mutate_ran.repick()<0.5)	{
					t = 1
					span = g_mat.x[i][1] - org_genome.x[i]
				}	else	{
					t = -1
					span = org_genome.x[i] - g_mat.x[i][0]
				}
	 			r = org_ran.repick()
	 			org_genome.x[i] = org_genome.x[i] + c*t*span*(1-r^((1-(current_generation/max_generation))^b))
	 			if (org_genome.x[i] > g_mat.x[i][1])	{org_genome.x[i] = g_mat.x[i][1]}
	 			if (org_genome.x[i] < g_mat.x[i][0])	{org_genome.x[i] = g_mat.x[i][0]}
	 		}
	 	}
	}
	
	proc non_uniform_single_mutate_org()	{local i,j,k,t,x,span,r,current_generation,max_generation,b,m_num localobj g_mat,temp_vec
	//
	//	CHECK VALIDITY
	//
		g_mat = $o1
	 	current_generation = $2
	 	max_generation = $3
	 	//b = 0.5
		//b = 1 CHANGE 8.2
		b = 2
	 	temp_vec = org_genome.c
	 	org_ran.uniform(0,1)
	 	mutate_ran.uniform(0,1)
	 	x = mutate_ran.repick
		j = p_mutate
		m_num = 1
		while (x<j)	{
			m_num = m_num + 1
			j = j*j
		}
		for (k=0;k<m_num;k=k+1)	{
			mutate_ran.discunif(0,org_genome_size-1)
			i = mutate_ran.repick
			if (org_ran.repick()<0.5)	{
				t = 1
				span = g_mat.x[i][1] - org_genome.x[i]
			}	else	{
				t = -1
				span = org_genome.x[i] - g_mat.x[i][0]
			}
			r = org_ran.repick()
			org_genome.x[i] = org_genome.x[i] + t*span*(1-r^((1-(current_generation/max_generation))^b))
			if (org_genome.x[i] > g_mat.x[i][1])	{org_genome.x[i] = g_mat.x[i][1]}
			if (org_genome.x[i] < g_mat.x[i][0])	{org_genome.x[i] = g_mat.x[i][0]}
			//print "j = ", j
			//j = j*j*j
		}
	}
	
	proc create_random()	{local i,min,max,seed localobj g_mat
		g_mat = $o1
		for (i=0;i<org_genome_size;i=i+1)	{
 			min = g_mat.x[i][0]
 			max = g_mat.x[i][1]
 			org_ran.uniform(min,max)
 			org_genome.x[i] = org_ran.repick()
 		}
// 		print "created organism genome is:"
// 		org_genome.printf()
	}

	proc set_genome()	{org_genome = $o1.c}

	func pass_fitness()	{return fitness}
	
	obfunc pass_fitness_vec()	{return org_fitness_vec}
	
	obfunc pass_genome()	{return org_genome}

	proc set_organism_fitness()	{fitness = $1}
	
	proc set_organism_fitness_vec()	{org_fitness_vec = $o1}

endtemplate Organism
