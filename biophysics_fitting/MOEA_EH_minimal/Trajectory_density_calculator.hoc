begintemplate TrajectoryDensityCalculator

	objref target_trace_list, target_deriv_list, den_mat_list, target_spike_list, target_svolt_list
	objref target_density_mat, sim_density_mat
	objref target_volt_vec, target_deriv_vec, mat_v_ind_vec, mat_i_ind_vec
	objref tvec, sim_volt_vec, sim_deriv_vec, g,gv
	
	strdef str1
	
	public setup_density_calculation, set_target_list, set_target_dt, set_target_bounds
	public set_target_file_list, load_targets_from_file
	public get_trajectory_error, get_mse_error, get_timing_error
	public generate_target_list
	
	proc init()	{
		target_trace_list = new List()
		target_deriv_list = new List()
		target_spike_list = new List()
		target_svolt_list = new List()
		den_mat_list = new List()
		g = new Graph()
		gv = new Vector()
		start_point = 0
		target_dt = 0.1
		sim_dt = 0.025
		thresh = -30
	}
	
	proc set_target_list(/*Target trace object*/)	{
		target_trace_list = $o1
	}
	
	proc generate_target_list(/*File name list*/)	{local i localobj tl,tf, tv
		tl = new List()
		tv = new Vector()
		
		for i=0, $o1.count-1	{
			tf = new File($o1.o(i).s)
			tf.ropen
			tv.scanf(tf)
			tf.close
			tl.append(tv.c)
		}
		set_target_list(tl)
	}
	
	proc setup_density_calculation(/*Target start, Target dt*/)	{
		start_point = $1
		target_dt = $2
		stop_point = $3
		if (target_trace_list.count == 0)	{
			print "target trace list still unassigned"
			return
		}
		set_density_parameters()
		set_deriv_list()
		set_spike_list()
		set_svolt_list()
		target_density_mat = new Matrix(mat_step_num,mat_step_num)
		sim_density_mat = new Matrix(mat_step_num,mat_step_num)
		set_density_matrices()
	}
	
	proc set_density_parameters()	{
		target_num = target_trace_list.count
		mat_step_num = 100
		mat_v_min = -80
		mat_v_max = 50
		mat_i_min = -250
		mat_i_max = 350
		marg = 25

		mat_v_step = (mat_v_max-mat_v_min)/mat_step_num
		mat_i_step = (mat_i_max-mat_i_min)/mat_step_num
		
		target_volt_vec = new Vector()
		target_deriv_vec = new Vector()
		mat_v_ind_vec = new Vector()
		mat_i_ind_vec = new Vector()
		sim_volt_vec = new Vector()
		sim_deriv_vec = new Vector()
		
		mat_v_ind_vec.indgen(mat_v_min,mat_v_max,mat_v_step)
		mat_i_ind_vec.indgen(mat_i_min,mat_i_max,mat_i_step)
		
		target_density_mat = new Matrix(mat_step_num,mat_step_num)
		sim_density_mat = new Matrix(mat_step_num,mat_step_num)
	}
	
	proc set_deriv_list()	{local i localobj fileref,temp_vec,temp_d_vec
		/*for (i=0;i<target_num;i+=1){
			print "before size of trace ", i, "is ", target_trace_list.o(i).size
			print "before mean of trace ", i, "is ", target_trace_list.o(i).mean
		}*/
		for (i=0;i<target_num;i+=1){
			temp_vec = new Vector()
			temp_d_vec = new Vector()
			temp_vec = target_trace_list.o(i).c
			temp_vec = temp_vec.c(start_point/target_dt)
			target_trace_list.insrt(i, temp_vec.c)
			target_trace_list.remove(i+1)
			temp_d_vec.deriv(temp_vec,target_dt,2)
			target_deriv_list.append(temp_d_vec.c)
		}
// 		for (i=0;i<target_num;i+=1){
// 			print "size of trace ", i, "is ", target_trace_list.o(i).size
// 			print "mean of trace ", i, "is ", target_trace_list.o(i).mean
// 		}
	}
	
	proc set_spike_list()	{local i,d localobj fileref,tvec, temp_vec, avec
		tvec = new Vector(stop_point/target_dt)
		tvec.indgen(target_dt)
		tvec = tvec.c(start_point/target_dt)
		//print "Target list size ", target_trace_list.count
		for (i=0;i<target_num;i+=1){
			temp_vec = extract_spike_time(target_trace_list.o(i).c, tvec, thresh)
			//temp_vec.printf()
			target_spike_list.append(temp_vec.c)
		}
 		//for (i=0;i<target_num;i+=1)	{target_spike_list.o(i).printf()}
	}
	
	proc set_svolt_list()	{local i,j,ti localobj temp_vec, temp_list,tvec
		tvec = new Vector(stop_point/target_dt)
		tvec.indgen(target_dt)
		tvec = tvec.c(start_point/target_dt)
		for (i=0;i<target_num;i+=1){
			temp_list = get_spike_surround(target_spike_list.o(i),tvec,target_trace_list.o(i))
			target_svolt_list.append(temp_list)
		}
	}
	
	obfunc get_spike_surround(/*Voltage vec, Time vec*/)	{local i,ti localobj tl, avec,temp_vec
		tl = new List()
		avec = new Vector()
		for i=0, $o1.size-1	{
			ti = $o1.x[i]
			avec.indvwhere($o2,"[]", ti-marg,ti+marg)
			temp_vec = $o3.ind(avec)
			//temp_vec.printf()
			tl.append(temp_vec.c)
		}
		//print "list is of size ", tl.count
		return tl
	}

	proc set_density_matrices()	{local i localobj temp_mat
		for (i=0;i<target_trace_list.count();i=i+1)	{
			temp_mat = new Matrix()
			temp_mat = calculate_density_matrix(target_trace_list.o(i),target_deriv_list.o(i),mat_v_ind_vec,mat_i_ind_vec)
			den_mat_list.append(temp_mat.c)
		}
	}
	
	
	obfunc calculate_density_matrix()	{local i,j,ind_v,ind_i,k,p_num,a localobj density_matrix
		a = 0
		density_matrix = new Matrix($o3.size(),$o4.size())
		density_matrix.zero
		for (i=0;i<$o1.size;i=i+1)	{	
			ind_v = $o3.indwhere(">",$o1.x[i])
			if (ind_v == -1)	{
				print "v index out of bounds"
				if ($o1.x[i] > mat_v_max)	{
					print "v exceeded max"
					ind_v = density_matrix.nrow-1
				}
			}
			//print "voltage value was ", $o1.x[i], " voltage index found was ", ind_v
			ind_i = $o4.indwhere(">",$o2.x[i])
			if (ind_i == -1)	{print "i index out of bounds"}
			//print "delta voltage value was ", $o2.x[i], " voltage index found was ", ind_i
			density_matrix.x[ind_v][ind_i] = density_matrix.x[ind_v][ind_i] + 1
		}
		//for (i=0;i<density_matrix.nrow-1; i=i+1)	{a = a + density_matrix.getrow(i).sum}
		//print "matrix sum is ", a
		return density_matrix.c
	}
	
	func get_timing_error(/*simulated_voltage_vector,time_vector,index of target matrix to use*/)	{local err,i,m,n localobj xd,yd,svec,err_vec
		yd = new Vector()
		xd = new Vector(stop_point/target_dt)
		xd.indgen(target_dt)
		yd.interpolate(xd,$o2,$o1)
		
		sim_volt_vec = yd.c(start_point/target_dt)
		
		svec = extract_spike_time(sim_volt_vec, xd.c(start_point/target_dt), thresh)
		//print "Span is ", (stop_point-start_point)
 		//print "Target spikes are "
		//target_spike_list.o($3).printf()
 		//print "Actual spikes are "
		//svec.printf()
		err = 0
		//print "Sim spikes"
		//svec.printf()
		//print "Target spikes"
		//target_spike_list.o($3).printf()
		//if (svec.size<=target_spike_list.o($3).size)	{m = svec.size}	else	{m = target_spike_list.o($3).size}
		//for i=0, m-1	{err = err + ((svec.x[i]-target_spike_list.o($3).x[i])/((stop_point-start_point)/m))^2}
		//err = err/m
		
		if (svec.size<=target_spike_list.o($3).size)	{m = svec.size	n=target_spike_list.o($3).size}	else	{m = target_spike_list.o($3).size	n=svec.size}
		
		err_vec = new Vector(m)
		for i=0, m-1	{
			err_vec.x[i] = ((svec.x[i]-target_spike_list.o($3).x[i])/((stop_point-start_point)/(m*target_spike_list.o($3).size)))^2
		}
		
		if (n != m)	{
			for i=m, n-1	{
				err_vec.append(err_vec.max)
			}
		}
		err = err_vec.mean()
		
		//print "New timing error ",err
		return err
	}
	
	func get_mse_error(/*simulated_voltage_vector,time_vector,index of target matrix to use*/)	{local err,i,m,n,p,stim_stop,stim_start,base localobj xd,yd,svec,tl,tv,ttv,sv,err_vec
		stim_start = 700
		stim_stop = 2700
		yd = new Vector()
		xd = new Vector(stop_point/target_dt)
		xd.indgen(target_dt)
		yd.interpolate(xd,$o2,$o1)
		sim_volt_vec = yd.c(start_point/target_dt)
		svec = extract_spike_time(sim_volt_vec, xd.c(start_point/target_dt), thresh)
		
		tl = new List()
		tl = get_spike_surround(svec,xd.c(start_point/target_dt),sim_volt_vec)
		
		base = sim_volt_vec.c(1,(stim_start-start_point)/target_dt).mean
		
		err = 0 
		
		if (tl.count<=target_svolt_list.o($3).count)	{m = tl.count	n=target_svolt_list.o($3).count}	else	{m = target_svolt_list.o($3).count	n=tl.count}
		
		err_vec = new Vector(m)
		for i=0, m-1	{
			//err = err + (tl.o(i).sub(target_svolt_list.o($3).o(i)).pow(2).sum)/tl.o(i).size
			err_vec.x[i] = (tl.o(i).sub(target_svolt_list.o($3).o(i)).pow(2).sum)/tl.o(i).size
		}
		
		//err = err/m
		
		if (n != m)	{
			for i=m, n-1	{
				err_vec.append(err_vec.max)
			}
		}
		err = err_vec.mean()
				
		tv = sim_volt_vec.c(1,(stim_start-start_point)/target_dt)
		ttv = target_trace_list.o($3).c(1,(stim_start-start_point)/target_dt)
		err = err + sqrt(tv.sub(ttv).pow(2).sum/ttv.size)
		
		tv = sim_volt_vec.c((stim_stop-start_point)/target_dt)
		ttv = target_trace_list.o($3).c((stim_stop-start_point)/target_dt)
		err = err + sqrt(tv.sub(ttv).pow(2).sum/ttv.size)
		
		return err
	}
	
	func get_trajectory_error(/*simulated_voltage_vector,time_vector,index of target matrix to use*/)	{local err localobj xd,yd, sm
		//sim_volt_vec = $o1.c(start_point/target_dt)
		//Resizing vector
// 		print "Target trace length is ", target_trace_list.o(0).size
// 		print "Simulated trace tstop should be ", $o2.max
// 		print "Target trace tstop should be ", target_trace_list.o(0).size*target_dt
		yd = new Vector()
		xd = new Vector(stop_point/target_dt)
		xd.indgen(target_dt)
		yd.interpolate(xd,$o2,$o1)
		
		sim_volt_vec = yd.c(start_point/target_dt)
		//print "Check should be non zero", sim_volt_vec.sub(target_trace_list.o($3)).sum
		if (sim_volt_vec.size != target_trace_list.o($3).size)	{
			print "Size of target and simulated vectors unequal check dt"
			print "Size of target was ", target_trace_list.o($3).size, " Size of sim vec was ", sim_volt_vec.size
			return -1
		}
		//print "started trajectory error"
		sim_deriv_vec = new Vector()
		sim_deriv_vec.deriv(sim_volt_vec.c,target_dt,2)
		sim_density_mat = calculate_density_matrix(sim_volt_vec,sim_deriv_vec,mat_v_ind_vec,mat_i_ind_vec).c
		//sm = calculate_density_matrix(sim_volt_vec,sim_deriv_vec,mat_v_ind_vec,mat_i_ind_vec)
		err = compare_density(den_mat_list.o($3).c,sim_density_mat,target_trace_list.o($3).size())
		//print "On index ", $3, "Error was ", err
		return err
	}
	
	func compare_density()	{local i,j,err,berr localobj m
		err = 0
		berr = 0
		
		m = $o1.c
		m.add($o2.muls(-1))
		m.from_vector(m.to_vector().abs)
		m.pow(1/2)
		for i=0, m.nrow-1	{err = err + m.getrow(i).sum}
		err = (err/$3)^2
		
		/*for (i=0;i<$o1.nrow();i=i+1)	{
			berr = berr + $o1.getrow(i).sub($o2.getrow(i)).div($3).pow(2).sum
		}
		berr = sqrt(berr)*/
		
		return err
	}
	
	proc set_target_dt(/*Target dt*/)	{
		target_dt = $1
	}
	
	obfunc get_target_trace(/*Trace number in list*/)	{
		return target_trace_list.o($1)
	}
	
	obfunc extract_spike_time(/*voltage_vector, time_vector, threshold*/)	{localobj vec
		return $o2.ind(extract_peak_index($o1,$3)).c
	}
	
	//*****************************************************
	// The peak of the spike is the most well defined time
	// Thus as an initial value it works well
	//*****************************************************
	
	obfunc extract_peak_index(/*voltage vector, threshold*/)	{local i,ind localobj pvec,clist
		pvec = new Vector()
		
		clist = find_crossing($o1,$2)
	
		if (clist.o(0).size != clist.o(1).size)	{
			print "Warning different number of threshold up and down crossings"
			return new Vector(1,-1)
		}	else	{
			pvec.resize(clist.o(0).size)
			for (i=0;i<clist.o(0).size;i=i+1)	{pvec.x[i] = $o1.max_ind(clist.o(0).x[i],clist.o(1).x[i])}
		}
		return pvec.c
	}
	
	//***************************************************************
	// Function that giving a threshold returns a list of two vectors
	// The first is the crossing up of that threshold
	// The second is the crossing down of that threshold
	//***************************************************************
	
	obfunc find_crossing(/*voltage vector, threshold*/)	{local i,thresh,ef localobj clist,avec,bvec
		ef = 0
		thresh = $2	
		avec = new Vector()
		bvec = new Vector()
		clist = new List()
		for (i=1;i<$o1.size;i=i+1){
			if ($o1.x[i]> thresh && $o1.x[i-1] < thresh) {
				avec.append(i)
			}	else	{
				if ($o1.x[i] < thresh && $o1.x[i-1] > thresh) {
					bvec.append(i)
				}
			}
		}
		clist.append(avec)
		clist.append(bvec)
		if (clist.o(0).size != clist.o(1).size && ef == 1)	{print "Warning different number of up and down crossings"}
		return clist
	}
		
endtemplate TrajectoryDensityCalculator
