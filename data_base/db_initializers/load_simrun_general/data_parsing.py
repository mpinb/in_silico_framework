import os
import warnings

import dask
import dask.dataframe as dd
import numpy as np
import pandas as pd

from data_base.utils import chunkIt, unique


@dask.delayed
def read_voltage_traces_from_files_pandas(prefix, fnames):
    """Reads a list of **multiple** voltage trace files and parses it to a single pandas dataframe.

    The delayed version of this method is used to construct a dask dataframe containing the voltage traces
    in :py:meth:`~data_base.db_initializers.load_simrun_general.read_voltage_traces_by_filenames`.
    Each singular file is read using :py:meth:`~data_base.db_initializers.load_simrun_general.read_voltage_traces_from_file`.

    Args:
        prefix (str): Path to the directory containing the simulation results.
        fnames (list): List of filenames pointing to voltage trace files.

    Returns:
        pandas.DataFrame: A pandas dataframe containing the voltage traces.

    See also:
        :py:meth:`~data_base.db_initializers.load_simrun_general.read_voltage_traces_by_filenames`.
    """
    dfs = [read_voltage_traces_from_file(prefix, fname) for fname in fnames]
    return pd.concat(dfs, axis=0)


def read_voltage_traces_from_file(prefix, fname):
    """Reads a **single** voltage traces file as generated by the simrun package.

    Infers the data format of the voltage traces file from the file extension (either ``.csv`` or ``.npz``).
    Reads them in and parses it to a pandas datafram, containing the original path and simulation trial as an index.

    Example:

        >>> simrun_result_fn = 'path/to/sim_result/vm_all_traces.csv'
        >>> with open(simrun_result_fn, 'r') as file: print(file.read())
        # This is an example for a .csv file (so not .npz)
        t	Vm run 00	Vm run 01
        100.0	-61.4607218758	-55.1366909604
        100.025	-61.4665809176	-55.1294343391
        100.05	-61.4735021526	-55.1223216173
        ...
        >>> read_voltage_traces_from_file(prefix="path/to/sim_result", v_fn)
        sim_trial_index                         100.0         100.025          ...
        path/to/sim_result/000000    -61.4607218758 -61.4665809176   ...
        path/to/sim_result/000001    -55.1366909604 -55.1294343391   ...
        ...

    Important:
        The simulation trial index is inferred from the filename of the voltage traces file.
        Ideally, this path should contain a unique identifier, containing e.g. the date,
        seed and/or the PID of the simulation run.

    Args:
        prefix (str): Path to the directory containing the simulation results.
        fname (str): Filename pointing to a voltage trace file. The file can be in either ``.csv`` or ``.npz`` format.

    Returns:
        pd.DataFrame: A pandas dataframe containing the voltage traces.

    See also:
        :py:meth:`~data_base.db_initializers.load_simrun_general.read_voltage_traces_from_csv` and
        :py:meth:`~data_base.db_initializers.load_simrun_general.read_voltage_traces_from_npz`
    """
    if fname.endswith(".csv"):
        return read_voltage_traces_from_csv(prefix, fname)
    if fname.endswith(".npz"):
        return read_voltage_traces_from_npz(prefix, fname)


read_voltage_traces_from_file_delayed = dask.delayed(read_voltage_traces_from_file)


def read_voltage_traces_from_csv(prefix, fname):
    """Reads a single :ref:`voltage_traces_csv_format` file as generated by the :py:mod:`simrun` package.

    Args:
        prefix (str): Path to the directory containing the simulation results.
        fname (str): Filename pointing to a voltage trace file. The file is expected to be in ``.csv`` format.

    See also:
        :py:meth:`~data_base.db_initializers.load_simrun_general.read_voltage_traces_from_file`

    Returns:
        pd.DataFrame: A pandas dataframe containing the voltage traces.
    """
    full_fname = os.path.join(prefix, fname)
    with open(full_fname) as f:
        data = np.loadtxt(f, skiprows=1, unpack=True, dtype="float64")
    # special case: if only one row is contained in data, this has to be a column vector
    if len(data.shape) == 1:
        data = data.reshape(len(data), 1)
    t = data[0]
    data = data[1:]
    # In case the simulation trial indices are not consecutive
    INDICES = sorted(
        [
            int(f.split("_")[1][3:])
            for f in os.listdir(os.path.dirname(full_fname))
            if "synapses" in f
        ]
    )
    index = [
        str(os.path.join(os.path.dirname(fname), str(index).zfill(6)))
        for index in INDICES
    ]  ##this will be the sim_trail_indexndex = [
    # print index
    df = pd.DataFrame(data, columns=t)
    df["sim_trial_index"] = index
    df.set_index("sim_trial_index", inplace=True)
    return df


def read_voltage_traces_from_npz(prefix, fname):
    """Reads a single :ref:`voltage_traces_npz_format` file as generated by the simrun package.

    Args:
        prefix (str): Path to the directory containing the simulation results.
        fname (str): Filename pointing to a voltage trace file. The file is expected to be in ``.npz`` format.

    See also:
        :py:meth:`~data_base.db_initializers.load_simrun_general.read_voltage_traces_from_file`
    """
    warnings.warn(
        "You are loading voltage traces from npz files. This only works, if you are using a fixed stepsize of 0.025 ms"
    )
    data = np.load(os.path.join(prefix, fname))["arr_0"]
    data = np.transpose(data)
    vt = data[1:, :]
    t = np.array([0.025 * n for n in range(data.shape[1])])
    sim_trial_index_base = os.path.dirname(
        fname
    )  # os.path.dirname(os.path.relpath(prefix, fname))
    index = [
        str(os.path.join(sim_trial_index_base, str(index).zfill(6)))
        for index in range(len(vt))
    ]  ##this will be the sim_trial_index

    df = pd.DataFrame(vt, columns=t)
    df["sim_trial_index"] = index
    df.set_index("sim_trial_index", inplace=True)

    return df


def read_voltage_traces_by_filenames(prefix, fnames, divisions=None, repartition=None):
    """Reads a list of **multiple** voltage trace files and parses it to a dask dataframe.

    Also sets the database key ``sim_trial_index`` to contain the paths of the simulation trials.
    This is the default way of constructing a dask dataframe containing the voltage traces.

    Args:
        prefix (str): Path to the directory containing the simulation results.
        fnames (list): list of filenames pointing to voltage trace files
        divisions (list): list of divisions for the dask dataframe. Default is None, letting Dask handle it.
        repartition (bool): If True, the dask dataframe is repartitioned to 5000 partitions (only if it contains over :math:`10000` entries).

    Returns:
        dask.DataFrame: A dask dataframe containing the voltage traces.

    See also:
        :py:meth:`~data_base.db_initializers.load_simrun_general.read_voltage_traces_from_file`
        is used to read in each single voltage trace file. Consult this method for more information on how the data format
        is parsed.
    """
    assert repartition is not None
    fnames = sorted(fnames)
    if repartition and len(fnames) > 10000:
        fnames_chunks = chunkIt(fnames, 5000)
        delayeds = [
            read_voltage_traces_from_files_pandas(prefix, fnames_chunk)
            for fnames_chunk in fnames_chunks
        ]
    else:
        delayeds = [
            read_voltage_traces_from_file_delayed(prefix, fname) for fname in fnames
        ]
    if divisions is not None:
        assert len(divisions) - 1 == len(delayeds)
    meta = read_voltage_traces_from_file(prefix, fnames[0]).head()
    ddf = dd.from_delayed(delayeds, meta=meta, divisions=divisions)
    return ddf


def load_dendritic_voltage_traces_helper(db, suffix, divisions=None, repartition=None):
    """Read the dendritic voltage traces of a single recording site across multiple simulation trials.

    This method constructs a list of all filenames corresponding to a single recording site and reads them in
    using :py:meth:`~data_base.db_initializers.load_simrun_general.read_voltage_traces_by_filenames`.

    Args:
        db (:py:class:`~data_base.isf_data_base.isf_data_base.ISFDataBase`):
            The target database that should contain the parsed simulation results.
        suffix (str):
            The suffix of the dendritic voltage trace files.
            This suffix is used to construct the filenames of the dendritic voltage trace files.
        divisions (list):
            List of divisions for the dask dataframe.
            Default is None, letting Dask handle it.
        repartition (bool):
            If True, the dask dataframe is repartitioned to 5000 partitions (only if it contains over :math:`10000` entries).

    Returns:
        dask.DataFrame: A dask dataframe containing the dendritic voltage traces.
    """
    assert repartition is not None
    metadata = db["metadata"]
    if not suffix.endswith(".csv"):
        suffix = suffix + ".csv"
    if not suffix.startswith("_"):
        suffix = "_" + suffix
    # print os.path.join(db['simresult_path'], m.iloc[0].path, m.iloc[0].path.split('_')[-1] + suffix)
    absolute_simresult_path = db['simresult_path']
    relative_simresult_path = metadata.iloc[0].path                 # e.g. results/20250101-1553_seed123456_pid0001
    example_pid = relative_simresult_path.split("_")[-1]            # e.g. pid7896
    example_random_seed = relative_simresult_path.split("_")[-2]    # e.g. seed74895461
    
    # old naming convention: used PID as a suffix
    # e.g.: subdirectory/20250101-1553_0001
    example_old_path = os.path.join(
        absolute_simresult_path,
        relative_simresult_path,
        example_pid + suffix,
    )
    # new-ish naming convention: used PID as a seed
    # e.g.: subdirectory/20250101-1553_seed0001
    example_new_path = os.path.join(
        absolute_simresult_path,
        relative_simresult_path,
        "seed_" + example_pid + suffix,
    )
    # brand new naming convention: Use both PID and random seed
    # e.g.: subdirectoy/20250101-1553_seed123456_pid0001
    example_brand_new_path = os.path.join(
        absolute_simresult_path,
        relative_simresult_path,
        example_random_seed
        + "_"
        + example_pid
        + suffix,
    )

    if os.path.exists(example_old_path):
        fnames = [
            os.path.join(x.path, x.path.split("_")[-1] + suffix)
            for index, x in metadata.iterrows()
        ]

    elif os.path.exists(example_new_path):
        fnames = [
            os.path.join(x.path, "seed_" + x.path.split("_")[-1] + suffix)
            for index, x in metadata.iterrows()
        ]

    elif os.path.exists(example_brand_new_path):
        fnames = [
            os.path.join(
                x.path, x.path.split("_")[-2] + "_" + x.path.split("_")[-1] + suffix
            )
            for index, x in metadata.iterrows()
        ]
    else:
        raise FileNotFoundError(
            "Could not find any files with the suffix {} in the directory {}".format(
                suffix, db["simresult_path"]
            )
        )

    # print(suffix)
    fnames = unique(fnames)
    ddf = read_voltage_traces_by_filenames(
        db["simresult_path"], fnames, divisions=divisions, repartition=repartition
    )
    return ddf


def load_dendritic_voltage_traces(db, suffix_key_dict, repartition=None):
    """Load the voltage traces from dendritic recording sites.

    Dendritic recording sites are defined in the :ref:`cell_parameters_format` files (under the key ``sim.recordingSites``).
    The voltage traces for each recording site are read with
    :py:meth:`~data_base.db_initializers.load_simrun_general.load_dendritic_voltage_traces_helper`.

    Args:
        db (:py:class:`~data_base.isf_data_base.isf_data_base.ISFDataBase`):
            The target database that should contain the parsed simulation results.
        suffix_key_dict (dict):
            Dictionary containing the suffixes of the dendritic voltage trace files.
            The keys are the labels of the recording sites, and the values are the suffixes of the dendritic voltage trace files.
        repartition (bool):
            If True, the dask dataframe is repartitioned to 5000 partitions (only if it contains over :math:`10000` entries).

    Returns:
        dict: Dictionary containing the dask dataframes of the dendritic voltage traces.

    """
    recsite_dendvt_dict = {}
    divisions = db["voltage_traces"].divisions
    # suffix_key_dict is of form: {recSite.label:  recSite.label + '_vm_dend_traces.csv'}
    for recsite, dend_vt_fn in suffix_key_dict.items():
        recsite_dendvt_dict[recsite] = load_dendritic_voltage_traces_helper(
            db, dend_vt_fn, divisions=divisions, repartition=repartition
        )
    return recsite_dendvt_dict
