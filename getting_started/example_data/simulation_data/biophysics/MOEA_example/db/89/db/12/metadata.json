{"dumper": "just_create_isf_db", "time": [2024, 4, 11, 13, 43, 50, 3, 102, -1], "conda_list": "# packages in environment at /gpfs/soma_fs/scratch/meulemeester/anaconda_isf3.8:\n#\n# Name                    Version                   Build  Channel\n_ipyw_jlab_nb_ext_conf    0.1.0                    py38_0  \n_libgcc_mutex             0.1                        main  \nalabaster                 0.7.12                     py_0  \nanaconda                  2020.11                  py38_0  \nanaconda-client           1.7.2                    py38_0  \nanaconda-navigator        1.10.0                   py38_0  \nanaconda-project          0.8.4                      py_0  \nannotated-types           0.5.0                    pypi_0    pypi\naplus                     0.11.0                   pypi_0    pypi\napptools                  5.2.1                    pypi_0    pypi\nargh                      0.26.2                   py38_0  \nargon2-cffi               20.1.0           py38h7b6447c_1  \nasn1crypto                1.4.0                      py_0  \nastroid                   2.4.2                    py38_0  \nastropy                   4.0.2            py38h7b6447c_0  \nasttokens                 2.4.1                    pypi_0    pypi\nasync_generator           1.10                       py_0  \natomicwrites              1.4.0                      py_0  \nattrs                     20.3.0             pyhd3eb1b0_0  \nautopep8                  1.5.4                      py_0  \nbabel                     2.13.0                   pypi_0    pypi\nbackcall                  0.2.0                      py_0  \nbackports                 1.0                        py_2  \nbackports.functools_lru_cache 1.6.1                      py_0  \nbackports.shutil_get_terminal_size 1.0.0                    py38_2  \nbackports.tempfile        1.0                        py_1  \nbackports.weakref         1.0.post1                  py_1  \nbeautifulsoup4            4.9.3              pyhb0f4dca_0  \nbitarray                  1.6.1            py38h27cfd23_0  \nbkcharts                  0.2                      py38_0  \nblake3                    0.3.3                    pypi_0    pypi\nblas                      1.0                         mkl  \nbleach                    3.2.1                      py_0  \nblosc                     1.10.2                   pypi_0    pypi\nbluepyopt                 1.9.126                  pypi_0    pypi\nbokeh                     2.2.3                    py38_0  \nboto                      2.49.0                   py38_0  \nbottleneck                1.3.2            py38heb32a55_1  \nbrotlipy                  0.7.0           py38h7b6447c_1000  \nbzip2                     1.0.8                h7b6447c_0  \nca-certificates           2020.10.14                    0  \ncairo                     1.14.12              h8948797_3  \ncertifi                   2020.6.20          pyhd3eb1b0_3  \ncffi                      1.14.3           py38he30daa8_0  \nchardet                   3.0.4                 py38_1003  \ncharset-normalizer        3.3.0                    pypi_0    pypi\nchart-studio              1.1.0                    pypi_0    pypi\nclick                     7.1.2                      py_0  \ncloudpickle               1.6.0                      py_0  \nclyent                    1.2.2                    py38_1  \ncolorama                  0.4.4                      py_0  \ncomm                      0.2.1                    pypi_0    pypi\nconda                     4.9.2            py38h06a4308_0  \nconda-build               3.20.5                   py38_1  \nconda-env                 2.6.0                         1  \nconda-package-handling    1.7.2            py38h03888b9_0  \nconda-verify              3.4.2                      py_1  \nconfigobj                 5.0.8                    pypi_0    pypi\ncontextlib2               0.6.0.post1                py_0  \ncoverage                  7.3.0                    pypi_0    pypi\ncryptography              3.1.1            py38h1ba5d50_0  \ncurl                      7.71.1               hbc83047_1  \ncycler                    0.10.0                   py38_0  \ncython                    0.29.21          py38he6710b0_0  \ncytoolz                   0.11.0           py38h7b6447c_0  \ndash                      2.9.3                    pypi_0    pypi\ndash-core-components      2.0.0                    pypi_0    pypi\ndash-html-components      2.0.0                    pypi_0    pypi\ndash-table                5.0.0                    pypi_0    pypi\ndask                      2.30.0                     py_0  \ndask-core                 2.30.0                     py_0  \ndask-glm                  0.3.0                    pypi_0    pypi\ndask-ml                   2023.3.24                pypi_0    pypi\ndbus                      1.13.18              hb2f20db_0  \ndeap                      1.3.1                    pypi_0    pypi\ndebugpy                   1.8.0                    pypi_0    pypi\ndecorator                 4.4.2                      py_0  \ndefusedxml                0.6.0                      py_0  \ndiff-match-patch          20200713                   py_0  \ndistributed               2.30.1           py38h06a4308_0  \ndocutils                  0.20.1                   pypi_0    pypi\nefel                      3.1.70                   pypi_0    pypi\nentrypoints               0.3                      py38_0  \nenvisage                  7.0.3                    pypi_0    pypi\net_xmlfile                1.0.1                   py_1001  \nexceptiongroup            1.1.2                    pypi_0    pypi\nexecnet                   2.0.2                    pypi_0    pypi\nexecuting                 2.0.1                    pypi_0    pypi\nexpat                     2.2.10               he6710b0_2  \nfastcache                 1.1.0            py38h7b6447c_0  \nfasteners                 0.16                     pypi_0    pypi\nfastjsonschema            2.15.3                   pypi_0    pypi\nfilelock                  3.0.12                     py_0  \nflake8                    3.8.4                      py_0  \nflask                     1.1.2                      py_0  \nflask-cors                4.0.0                    pypi_0    pypi\nfontconfig                2.13.0               h9420a91_0  \nfreetype                  2.10.4               h5ab3b9f_0  \nfribidi                   1.0.10               h7b6447c_0  \nfrozendict                2.3.8                    pypi_0    pypi\nfsspec                    0.8.3                      py_0  \nfuro                      2023.9.10                pypi_0    pypi\nfuture                    0.18.2                   py38_1  \nget_terminal_size         1.0.0                haa9412d_0  \ngevent                    20.9.0           py38h7b6447c_0  \nglib                      2.66.1               h92f7085_0  \nglob2                     0.7                        py_0  \ngmp                       6.1.2                h6c8ec71_1  \ngmpy2                     2.0.8            py38hd5f6e3b_3  \ngraphite2                 1.3.14               h23475e2_0  \ngreenlet                  0.4.17           py38h7b6447c_0  \ngst-plugins-base          1.14.0               hbbd80ab_1  \ngstreamer                 1.14.0               hb31296c_0  \nh5py                      2.10.0           py38h7918eee_0  \nharfbuzz                  2.4.0                hca77d97_1  \nhdf5                      1.10.4               hb1b8bf9_0  \nheapdict                  1.0.1                      py_0  \nhtml5lib                  1.1                        py_0  \nicu                       58.2                 he6710b0_3  \nidna                      2.10                       py_0  \nimageio                   2.9.0                      py_0  \nimagesize                 1.4.1                    pypi_0    pypi\nimportlib-metadata        4.11.3                   pypi_0    pypi\nimportlib-resources       5.13.0                   pypi_0    pypi\nimportlib_metadata        2.0.0                         1  \ninflection                0.5.1                    pypi_0    pypi\niniconfig                 1.1.1                      py_0  \nintel-openmp              2020.2                      254  \nintervaltree              3.1.0                      py_0  \nipykernel                 6.29.0                   pypi_0    pypi\nipython                   8.12.3                   pypi_0    pypi\nipython_genutils          0.2.0                    py38_0  \nipywidgets                7.5.1                      py_1  \nisort                     5.6.4                      py_0  \nitsdangerous              1.1.0                      py_0  \njbig                      2.1                  hdba287a_0  \njdcal                     1.4.1                      py_0  \njedi                      0.17.1                   py38_0  \njeepney                   0.5.0              pyhd3eb1b0_0  \njinja2                    3.0.3                    pypi_0    pypi\njoblib                    1.3.2                    pypi_0    pypi\njpeg                      9b                   h024ee3a_2  \njson5                     0.9.5                      py_0  \njsonschema                3.2.0                      py_2  \njupyter                   1.0.0                    py38_7  \njupyter-client            8.6.0                    pypi_0    pypi\njupyter-contrib-core      0.4.2                    pypi_0    pypi\njupyter-contrib-nbextensions 0.7.0                    pypi_0    pypi\njupyter-core              5.7.1                    pypi_0    pypi\njupyter-highlight-selected-word 0.2.0                    pypi_0    pypi\njupyter-nbextensions-configurator 0.6.3                    pypi_0    pypi\njupyter_console           6.2.0                      py_0  \njupyterlab                2.2.6                      py_0  \njupyterlab-simpledark     1.0.2                    pypi_0    pypi\njupyterlab_pygments       0.1.2                      py_0  \njupyterlab_server         1.2.0                      py_0  \nkazoo                     2.8.0                    pypi_0    pypi\nkeyring                   21.4.0                   py38_1  \nkiwisolver                1.3.0            py38h2531618_0  \nkrb5                      1.18.2               h173b8e3_0  \nlazy-object-proxy         1.4.3            py38h7b6447c_0  \nlcms2                     2.11                 h396b838_0  \nld_impl_linux-64          2.33.1               h53a641e_7  \nlibarchive                3.4.2                h62408e4_0  \nlibcurl                   7.71.1               h20c2e04_1  \nlibedit                   3.1.20191231         h14c3975_1  \nlibffi                    3.3                  he6710b0_2  \nlibgcc-ng                 9.1.0                hdf63c60_0  \nlibgfortran-ng            7.3.0                hdf63c60_0  \nliblief                   0.10.1               he6710b0_0  \nlibllvm10                 10.0.1               hbcb73fb_5  \nlibpng                    1.6.37               hbc83047_0  \nlibsodium                 1.0.18               h7b6447c_0  \nlibspatialindex           1.9.3                he6710b0_0  \nlibssh2                   1.9.0                h1ba5d50_1  \nlibstdcxx-ng              9.1.0                hdf63c60_0  \nlibtiff                   4.1.0                h2733197_1  \nlibtool                   2.4.6             h7b6447c_1005  \nlibuuid                   1.0.3                h1bed415_2  \nlibxcb                    1.14                 h7b6447c_0  \nlibxml2                   2.9.10               hb55368b_3  \nlibxslt                   1.1.34               hc22bd24_0  \nllvmlite                  0.34.0           py38h269e1b5_4  \nlocket                    0.2.0                    py38_1  \nlxml                      4.6.1            py38hefd8a0e_0  \nlz4-c                     1.9.2                heb0550a_3  \nlzo                       2.10                 h7b6447c_2  \nmarkdown-it-py            3.0.0                    pypi_0    pypi\nmarkupsafe                2.1.3                    pypi_0    pypi\nmatplotlib                3.3.2                         0  \nmatplotlib-base           3.3.2            py38h817c723_0  \nmatplotlib-inline         0.1.6                    pypi_0    pypi\nmayavi                    4.8.1                    pypi_0    pypi\nmccabe                    0.6.1                    py38_1  \nmdurl                     0.1.2                    pypi_0    pypi\nmistune                   0.8.4           py38h7b6447c_1000  \nmkl                       2020.2                      256  \nmkl-service               2.3.0            py38he904b0f_0  \nmkl_fft                   1.2.0            py38h23d657b_0  \nmkl_random                1.1.1            py38h0573a6f_0  \nmock                      4.0.2                      py_0  \nmodulegraph2              2.2.1                    pypi_0    pypi\nmore-itertools            8.6.0              pyhd3eb1b0_0  \nmpc                       1.1.0                h10f8cd9_1  \nmpfr                      4.0.2                hb69a4c5_1  \nmpmath                    1.1.0                    py38_0  \nmsgpack-python            1.0.0            py38hfd86e86_1  \nmultipledispatch          0.6.0                    py38_0  \nnavigator-updater         0.2.1                    py38_0  \nnbclient                  0.5.1                      py_0  \nnbconvert                 6.0.7                    py38_0  \nnbformat                  5.0.8                      py_0  \nncurses                   6.2                  he6710b0_1  \nneo                       0.9.0                    pypi_0    pypi\nnest-asyncio              1.4.2              pyhd3eb1b0_0  \nnetworkx                  2.5                        py_0  \nneuron                    7.8.2                    pypi_0    pypi\nnltk                      3.5                        py_0  \nnose                      1.3.7                    py38_2  \nnotebook                  6.1.4                    py38_0  \nnumba                     0.51.2           py38h0573a6f_1  \nnumexpr                   2.7.1            py38h423224d_0  \nnumpy                     1.19.2                   pypi_0    pypi\nnumpydoc                  1.1.0              pyhd3eb1b0_1  \nobjectgraph               1.0.3                    pypi_0    pypi\nolefile                   0.46                       py_0  \nopenpyxl                  3.0.5                      py_0  \nopenssl                   1.1.1h               h7b6447c_0  \npackaging                 23.2                     pypi_0    pypi\npandas                    1.1.3            py38he6710b0_0  \npandas-msgpack            0.1.4+14.gfcb0471.dirty          pypi_0    pypi\npandoc                    2.11                 hb0f4dca_0  \npandocfilters             1.4.3            py38h06a4308_1  \npango                     1.45.3               hd140c19_0  \nparameters                0.2.1                    pypi_0    pypi\nparso                     0.7.0                      py_0  \npartd                     1.1.0                      py_0  \npatchelf                  0.12                 he6710b0_0  \npath                      15.0.0                   py38_0  \npath.py                   12.5.0                        0  \npathlib2                  2.3.5                    py38_0  \npathtools                 0.1.2                      py_1  \npatsy                     0.5.1                    py38_0  \npcre                      8.44                 he6710b0_0  \npep8                      1.7.1                    py38_0  \npexpect                   4.8.0                    py38_0  \npickleshare               0.7.5                 py38_1000  \npillow                    8.2.0                    pypi_0    pypi\npip                       20.2.4           py38h06a4308_0  \npixman                    0.40.0               h7b6447c_0  \npkginfo                   1.6.1            py38h06a4308_0  \nplatformdirs              3.11.0                   pypi_0    pypi\nplotly                    5.17.0                   pypi_0    pypi\npluggy                    0.13.1                   py38_0  \nply                       3.11                     py38_0  \npooch                     1.8.0                    pypi_0    pypi\nprogressbar2              4.2.0                    pypi_0    pypi\nprometheus_client         0.8.0                      py_0  \nprompt-toolkit            3.0.43                   pypi_0    pypi\nprompt_toolkit            3.0.8                         0  \npsutil                    5.7.2            py38h7b6447c_0  \nptyprocess                0.6.0                    py38_0  \npure-eval                 0.2.2                    pypi_0    pypi\npy                        1.9.0                      py_0  \npy-lief                   0.10.1           py38h403a769_0  \npyarrow                   12.0.1                   pypi_0    pypi\npycodestyle               2.6.0                      py_0  \npycosat                   0.6.3            py38h7b6447c_1  \npycparser                 2.20                       py_2  \npycurl                    7.43.0.6         py38h1ba5d50_0  \npydantic                  1.10.4                   pypi_0    pypi\npydeps                    1.12.17                  pypi_0    pypi\npydocstyle                5.1.1                      py_0  \npyface                    8.0.0                    pypi_0    pypi\npyflakes                  2.2.0                      py_0  \npygments                  2.16.1                   pypi_0    pypi\npylint                    2.6.0                    py38_0  \npyodbc                    4.0.30           py38he6710b0_0  \npyopenssl                 19.1.0                     py_1  \npyparsing                 2.4.7                      py_0  \npypdf2                    1.26.0                   pypi_0    pypi\npyqt                      5.9.2            py38h05f1152_4  \npyrsistent                0.17.3           py38h7b6447c_0  \npysocks                   1.7.1                    py38_0  \npytables                  3.6.1            py38h9fd0a39_0  \npytest                    7.4.0                    pypi_0    pypi\npytest-cov                4.1.0                    pypi_0    pypi\npytest-xdist              3.3.1                    pypi_0    pypi\npython                    3.8.5                h7579374_1  \npython-dateutil           2.8.2                    pypi_0    pypi\npython-graphviz           0.20.1                   pypi_0    pypi\npython-jsonrpc-server     0.4.0                      py_0  \npython-language-server    0.35.1                     py_0  \npython-libarchive-c       2.9                        py_0  \npython-utils              3.7.0                    pypi_0    pypi\npytz                      2020.1                     py_0  \npyvista                   0.42.3                   pypi_0    pypi\npywavelets                1.1.1            py38h7b6447c_2  \npyxdg                     0.27               pyhd3eb1b0_0  \npyyaml                    5.3.1            py38h7b6447c_1  \npyzmq                     25.1.2                   pypi_0    pypi\nqdarkstyle                2.8.1                      py_0  \nqt                        5.9.7                h5867ecd_1  \nqtawesome                 1.0.1                      py_0  \nqtconsole                 4.7.7                      py_0  \nqtpy                      1.9.0                      py_0  \nquantities                0.12.4                   pypi_0    pypi\nreadline                  8.0                  h7b6447c_0  \nredis                     3.5.3                    pypi_0    pypi\nregex                     2020.10.15       py38h7b6447c_0  \nrequests                  2.31.0                   pypi_0    pypi\nretrying                  1.3.3                    pypi_0    pypi\nrich                      13.5.2                   pypi_0    pypi\nripgrep                   12.1.1                        0  \nrope                      0.18.0                     py_0  \nrtree                     0.9.4                    py38_1  \nruamel_yaml               0.15.87          py38h7b6447c_1  \nscandir                   1.10.0                   pypi_0    pypi\nscikit-image              0.17.2           py38hdf5156a_0  \nscikit-learn              1.3.2                    pypi_0    pypi\nscipy                     1.5.2            py38h0b6359f_0  \nscooby                    0.9.2                    pypi_0    pypi\nseaborn                   0.11.0                     py_0  \nsecretstorage             3.1.2                    py38_0  \nsend2trash                1.5.0                    py38_0  \nsetuptools                50.3.1           py38h06a4308_1  \nsimplegeneric             0.8.1                    py38_2  \nsimpleitk                 2.0.2                    pypi_0    pypi\nsingledispatch            3.4.0.3                 py_1001  \nsip                       4.19.13          py38he6710b0_0  \nsix                       1.15.0           py38h06a4308_0  \nsnowballstemmer           2.0.0                      py_0  \nsortedcollections         1.2.1                      py_0  \nsortedcontainers          2.2.2                      py_0  \nsoupsieve                 2.0.1                      py_0  \nsparse                    0.14.0                   pypi_0    pypi\nsphinx                    7.1.2                    pypi_0    pypi\nsphinx-basic-ng           1.0.0b2                  pypi_0    pypi\nsphinx-paramlinks         0.6.0                    pypi_0    pypi\nsphinxcontrib             1.0                      py38_1  \nsphinxcontrib-applehelp   1.0.2                      py_0  \nsphinxcontrib-devhelp     1.0.2                      py_0  \nsphinxcontrib-htmlhelp    2.0.1                    pypi_0    pypi\nsphinxcontrib-jsmath      1.0.1                      py_0  \nsphinxcontrib-qthelp      1.0.3                      py_0  \nsphinxcontrib-serializinghtml 1.1.5                    pypi_0    pypi\nsphinxcontrib-websupport  1.2.4                      py_0  \nspyder                    4.1.5                    py38_0  \nspyder-kernels            1.9.4                    py38_0  \nsqlalchemy                1.3.20           py38h7b6447c_0  \nsqlite                    3.33.0               h62c20be_0  \nstack-data                0.6.3                    pypi_0    pypi\nstatsmodels               0.12.0           py38h7b6447c_0  \nstdlib-list               0.10.0                   pypi_0    pypi\nsumatra                   0.7.4                    pypi_0    pypi\nsympy                     1.6.2            py38h06a4308_1  \ntabulate                  0.9.0                    pypi_0    pypi\ntbb                       2020.3               hfd86e86_0  \ntblib                     1.7.0                      py_0  \ntenacity                  8.2.3                    pypi_0    pypi\nterminado                 0.9.1                    py38_0  \ntestpath                  0.4.4                      py_0  \nthreadpoolctl             2.1.0              pyh5ca1d4c_0  \ntifffile                  2020.10.1        py38hdd07704_2  \ntk                        8.6.10               hbc83047_0  \ntoml                      0.10.1                     py_0  \ntoolz                     0.11.1                     py_0  \ntorch                     1.8.1                    pypi_0    pypi\ntorchaudio                0.8.1                    pypi_0    pypi\ntorchvision               0.9.1                    pypi_0    pypi\ntornado                   6.4                      pypi_0    pypi\ntqdm                      4.50.2                     py_0  \ntraitlets                 5.14.1                   pypi_0    pypi\ntraits                    6.4.3                    pypi_0    pypi\ntraitsui                  8.0.0                    pypi_0    pypi\ntyping-extensions         4.7.1                    pypi_0    pypi\nujson                     4.0.1            py38he6710b0_0  \nunicodecsv                0.14.1                   py38_0  \nunixodbc                  2.3.9                h7b6447c_0  \nurllib3                   1.25.11                    py_0  \nvaex                      4.16.0                   pypi_0    pypi\nvaex-astro                0.9.3                    pypi_0    pypi\nvaex-core                 4.16.1                   pypi_0    pypi\nvaex-hdf5                 0.14.1                   pypi_0    pypi\nvaex-jupyter              0.8.2                    pypi_0    pypi\nvaex-ml                   0.18.3                   pypi_0    pypi\nvaex-server               0.8.1                    pypi_0    pypi\nvaex-viz                  0.5.4                    pypi_0    pypi\nvtk                       9.2.6                    pypi_0    pypi\nwatchdog                  0.10.3                   py38_0  \nwcwidth                   0.2.5                      py_0  \nwebencodings              0.5.1                    py38_1  \nwerkzeug                  1.0.1                      py_0  \nwheel                     0.35.1                     py_0  \nwidgetsnbextension        3.5.1                    py38_0  \nwrapt                     1.11.2           py38h7b6447c_0  \nwurlitzer                 2.0.1                    py38_0  \nxlrd                      1.2.0                      py_0  \nxlsxwriter                1.3.7                      py_0  \nxlwt                      1.3.0                    py38_0  \nxmltodict                 0.12.0                     py_0  \nxz                        5.2.5                h7b6447c_0  \nyaml                      0.2.5                h7b6447c_0  \nyapf                      0.30.0                     py_0  \nzeromq                    4.3.3                he6710b0_3  \nzict                      2.0.0                      py_0  \nzipp                      3.4.0              pyhd3eb1b0_0  \nzlib                      1.2.11               h7b6447c_3  \nzope                      1.0                      py38_1  \nzope.event                4.5.0                    py38_0  \nzope.interface            5.1.2            py38h7b6447c_0  \nzstd                      1.4.5                h9ceee32_0  \n", "module_versions": {"re": "2.2.1", "json": "2.0.9", "logging": "0.5.1.2", "zlib": "1.0", "traitlets": "5.0.5", "argparse": "1.1", "ipython_genutils": "0.2.0", "platform": "1.0.8", "pygments": "2.16.1", "ptyprocess": "0.6.0", "pexpect": "4.8.0", "decorator": "4.4.2", "pickleshare": "0.7.5", "backcall": "0.2.0", "wcwidth": "0.2.5", "prompt_toolkit": "3.0.8", "parso": "0.7.0", "_ctypes": "1.1.0", "ctypes": "1.1.0", "colorama": "0.4.4", "jedi": "0.17.1", "IPython": "7.19.0", "zmq": "19.0.2", "jupyter_core": "4.6.3", "distutils": "3.8.5", "jupyter_client": "6.1.7", "ipykernel": "5.3.4", "_curses": "b'2.2'", "dateutil": "2.8.1", "six": "1.15.0", "_decimal": "1.70", "decimal": "1.70", "Interface": "heads/publish+0.g7a21afd2.dirty", "mkl": "2.3.0", "numpy": "1.19.2", "pyparsing": "2.4.7", "cycler": "0.10.0", "kiwisolver": "1.3.0", "matplotlib": "3.3.2", "pytz": "2020.1", "bottleneck": "1.3.2", "_csv": "1.0", "csv": "1.0", "pandas": "1.1.3", "yaml": "5.3.1", "toolz": "0.11.1", "cytoolz": "0.11.0", "tlz": "0.11.0", "psutil": "5.7.2", "cloudpickle": "1.6.0", "tblib": "1.7.0", "dask": "2.30.0", "scipy": "1.5.2", "numexpr": "2.7.1", "pyarrow": "12.0.1", "fsspec": "0.8.3", "socketserver": "0.4", "click": "7.1.2", "blosc": "1.10.2", "sortedcontainers": "2.2.2", "distributed": "2.30.1", "PIL": "8.2.0", "cffi": "1.14.3", "statsmodels": "0.12.0", "ipywidgets": "7.5.1", "seaborn": "0.11.0", "kazoo": "2.8.0", "tables": "3.6.1", "neuron": "7.8.2", "sumatra": "0.7.4", "future": "0.18.2", "parameters": "0.2.1", "joblib": "0.17.0", "sklearn": "0.23.2", "pandas_msgpack": "0.1.4+14.gfcb0471.dirty", "scandir": "1.10.0", "markupsafe": "1.1.1", "jinja2": "2.11.2", "werkzeug": "1.0.1", "itsdangerous": "1.1.0", "greenlet": "0.4.17", "flask": "1.1.2", "dash": "2.9.3", "plotly": "4.14.3", "deap": "1.3", "past": "0.18.2", "bluepyopt": "1.9.126", "filelock": "3.0.12", "blake3": "0.3.3", "ipaddress": "1.0", "pydantic": "1.10.4", "attr": "20.3.0", "gevent": "20.9.0"}, "history": "import Interface as I\nfrom getting_started import getting_started_dir\n\nexample_data_dir = I.os.path.join(getting_started_dir, 'example_data', 'simulation_data', 'biophysics')\ndb = I.DataBase(example_data_dir)\ndb_mooa = db.create_sub_db('MOEA_example')\nfrom biophysics_fitting.hay_complete_default_setup import get_feasible_model_params\n\nparams = get_feasible_model_params().drop('x', axis=1)\nparams.index = [e.replace('CaDynamics_E2', 'CaDynamics_E2_v2') for e in params.index]\nparams.index = 'ephys.' + params.index\nparams = params.append(\n    I.pd.DataFrame({\n        'ephys.SKv3_1.apic.slope': {\n            'min': -3,\n            'max': 0\n        },\n        'ephys.SKv3_1.apic.offset': {\n            'min': 0,\n            'max': 1\n        }\n    }).T)\nparams = params.append(\n    I.pd.DataFrame({\n        'min': .333,\n        'max': 3\n    }, index=['scale_apical.scale']))\n\n\nparams = params.sort_index()\nparams\nfrom biophysics_fitting.L5tt_parameter_setup import get_L5tt_template\nimport biophysics_fitting.hay_complete_default_setup as hay_setup\n\ndef scale_apical(cell_param, params):\n    assert(len(params) == 1)\n    cell_param.cell_modify_functions.scale_apical.scale = params['scale']\n    return cell_param\n\ndef get_fixed_params(db_setup):\n    \"\"\"\n    Configure the fixed params and return\n    \"\"\"\n    fixed_params = db_setup['fixed_params']\n    fixed_params['morphology.filename'] = db_setup['morphology'].get_file(\n        'hoc')\n    return fixed_params\n\ndef get_Simulator(db_setup, step=False):\n    \"\"\"\n    Configure the Simulator object and return\n    \"\"\"\n    fixed_params = db_setup['get_fixed_params'](db_setup)\n    s = hay_setup.get_Simulator(\n        I.pd.Series(fixed_params),\n        step=step)\n    s.setup.cell_param_generator = get_L5tt_template_v2\n    s.setup.cell_param_modify_funs.append(\n        ('scale_apical', scale_apical)\n        )\n    return s\n\ndef get_Evaluator(db_setup, step=False):\n    \"\"\"\n    No additional configuration is needed for the Evaluator, simply return biophysics_fitting.L5tt_parameter_setup.get_Evaluator\n    \"\"\"\n    return hay_setup.get_Evaluator(step=step)\n\ndef get_Combiner(db_setup, step=False):\n    \"\"\"\n    No additional configuration is needed for the Combiner, simply return biophysics_fitting.L5tt_parameter_setup.get_Combiner\n    \"\"\"\n    return hay_setup.get_Combiner(step=step)\ndef set_up_db_for_MOEA(db, morphology_id='89', morphology=\"\", step=False):\n    \"\"\"\n    Set up a DataBase for MOEA.\n\n    Args:\n        db: a DataBase object\n        morphology_id: name of the morphology\n        morphology: path to a .hoc morphology file\n        step: whether or not to perform step current injections\n\n    Returns:\n        data_base.DataBase: a database containing:\n            - fixed_params\n            - get_fixed_params\n            - get_Simulator\n            - get_Evaluator\n            - get_Combiner\n            - the morphology file\n    \"\"\"\n    from data_base.IO.LoaderDumper import pandas_to_pickle, to_cloudpickle\n    db.create_sub_db(morphology_id)\n\n    db[morphology_id].create_managed_folder('morphology')\n    I.shutil.copy(\n        I.os.path.join(\n            morphology\n        ), db[morphology_id]['morphology'].join(\n            morphology.split(I.os.sep)[-1]\n        ))\n\n    db[morphology_id]['fixed_params'] = {\n        'BAC.hay_measure.recSite': 835,\n        'BAC.stim.dist': 835,\n        'bAP.hay_measure.recSite1': 835,\n        'bAP.hay_measure.recSite2': 1015,\n        'hot_zone.min_': 900,\n        'hot_zone.max_': 1100,\n        'morphology.filename': None\n    }\n\n    db[morphology_id]['get_fixed_params'] = get_fixed_params\n    db[morphology_id].set('params', params, dumper=pandas_to_pickle)\n    db[morphology_id].set('get_Simulator',\n                      I.partial(get_Simulator, step=step),\n                      dumper=to_cloudpickle)\n    db[morphology_id].set('get_Evaluator',\n                      I.partial(get_Evaluator, step=step),\n                      dumper=to_cloudpickle)\n    db[morphology_id].set('get_Combiner',\n                      I.partial(get_Combiner, step=step),\n                      dumper=to_cloudpickle)\n\n    return db\nmorphology = [e for e in db['89']['morphology'].listdir() if e.endswith(\".hoc\")][0]\nmorphology_path = I.os.path.join(db['89']['morphology'], morphology)\nset_up_db_for_MOEA(\n    db_mooa,\n    morphology_id=\"89\",\n    morphology=morphology_path,\n    step=False\n    )\nset_up_db_for_MOEA(\n    db_mooa,\n    morphology_id=\"89\",\n    morphology=morphology_path,\n    step=False\n    )\nfrom biophysics_fitting.optimizer import start_run\n\nstart_run(\n    db_mooa['89'], \n    n=42, # seed\n    client=I.get_client(), \n    offspring_size=10,  # Low amount of offspring just as an example \n    pop=None,  # adapt this to the output population of the previous run to continue where you left off\n    continue_cp=False,  # if it is a first run, this should equal False. If you want to continue a preivoius run, set to True\n    max_ngen=1  # run for just 1 generation\n    )\nfrom biophysics_fitting.L5tt_parameter_setup import get_L5tt_template_v2\nimport biophysics_fitting.hay_complete_default_setup as hay_setup\n\ndef scale_apical(cell_param, params):\n    assert(len(params) == 1)\n    cell_param.cell_modify_functions.scale_apical.scale = params['scale']\n    return cell_param\n\ndef get_fixed_params(db_setup):\n    \"\"\"\n    Configure the fixed params and return\n    \"\"\"\n    fixed_params = db_setup['fixed_params']\n    fixed_params['morphology.filename'] = db_setup['morphology'].get_file(\n        'hoc')\n    return fixed_params\n\ndef get_Simulator(db_setup, step=False):\n    \"\"\"\n    Configure the Simulator object and return\n    \"\"\"\n    fixed_params = db_setup['get_fixed_params'](db_setup)\n    s = hay_setup.get_Simulator(\n        I.pd.Series(fixed_params),\n        step=step)\n    s.setup.cell_param_generator = get_L5tt_template_v2\n    s.setup.cell_param_modify_funs.append(\n        ('scale_apical', scale_apical)\n        )\n    return s\n\ndef get_Evaluator(db_setup, step=False):\n    \"\"\"\n    No additional configuration is needed for the Evaluator, simply return biophysics_fitting.L5tt_parameter_setup.get_Evaluator\n    \"\"\"\n    return hay_setup.get_Evaluator(step=step)\n\ndef get_Combiner(db_setup, step=False):\n    \"\"\"\n    No additional configuration is needed for the Combiner, simply return biophysics_fitting.L5tt_parameter_setup.get_Combiner\n    \"\"\"\n    return hay_setup.get_Combiner(step=step)\ndef set_up_db_for_MOEA(db, morphology_id='89', morphology=\"\", step=False):\n    \"\"\"\n    Set up a DataBase for MOEA.\n\n    Args:\n        db: a DataBase object\n        morphology_id: name of the morphology\n        morphology: path to a .hoc morphology file\n        step: whether or not to perform step current injections\n\n    Returns:\n        data_base.DataBase: a database containing:\n            - fixed_params\n            - get_fixed_params\n            - get_Simulator\n            - get_Evaluator\n            - get_Combiner\n            - the morphology file\n    \"\"\"\n    from data_base.IO.LoaderDumper import pandas_to_pickle, to_cloudpickle\n    db.create_sub_db(morphology_id)\n\n    db[morphology_id].create_managed_folder('morphology')\n    I.shutil.copy(\n        I.os.path.join(\n            morphology\n        ), db[morphology_id]['morphology'].join(\n            morphology.split(I.os.sep)[-1]\n        ))\n\n    db[morphology_id]['fixed_params'] = {\n        'BAC.hay_measure.recSite': 835,\n        'BAC.stim.dist': 835,\n        'bAP.hay_measure.recSite1': 835,\n        'bAP.hay_measure.recSite2': 1015,\n        'hot_zone.min_': 900,\n        'hot_zone.max_': 1100,\n        'morphology.filename': None\n    }\n\n    db[morphology_id]['get_fixed_params'] = get_fixed_params\n    db[morphology_id].set('params', params, dumper=pandas_to_pickle)\n    db[morphology_id].set('get_Simulator',\n                      I.partial(get_Simulator, step=step),\n                      dumper=to_cloudpickle)\n    db[morphology_id].set('get_Evaluator',\n                      I.partial(get_Evaluator, step=step),\n                      dumper=to_cloudpickle)\n    db[morphology_id].set('get_Combiner',\n                      I.partial(get_Combiner, step=step),\n                      dumper=to_cloudpickle)\n\n    return db\nmorphology = [e for e in db['89']['morphology'].listdir() if e.endswith(\".hoc\")][0]\nmorphology_path = I.os.path.join(db['89']['morphology'], morphology)\ndeldb['%morephology']\ndel db['%morephology']\ndel db['morphology']\nset_up_db_for_MOEA(\n    db_mooa,\n    morphology_id=\"89\",\n    morphology=morphology_path,\n    step=False\n    )\nset_up_db_for_MOEA(\n    db_mooa,\n    morphology_id=\"89\",\n    morphology=morphology_path,\n    step=False\n    )\nfrom biophysics_fitting.optimizer import start_run\n\nstart_run(\n    db_mooa['89'], \n    n=42, # seed\n    client=I.get_client(), \n    offspring_size=10,  # Low amount of offspring just as an example \n    pop=None,  # adapt this to the output population of the previous run to continue where you left off\n    continue_cp=False,  # if it is a first run, this should equal False. If you want to continue a preivoius run, set to True\n    max_ngen=1  # run for just 1 generation\n    )\npopulation = db_mooa['89']['42']['1']\npopulation\nobjectives = population.drop(params.index, axis=1)\nobjectives\nfrom biophysics_fitting.hay_complete_default_setup import get_hay_problem_description\nempirical_data = get_hay_problem_description()\nempirical_data = empirical_data[empirical_data['objective'] \\\n                                .isin(objectives.columns)] \\\n                                .set_index(\"objective\") \\\n                                .loc[objectives.columns]\nempirical_data\n%matplotlib inline\nI.plt.style.use(\"fivethirtyeight\")\ndiff = (objectives - empirical_data['mean']) / empirical_data[\"std\"]\nax = diff.plot.box(vert=False)\nax.set_xscale('log')\nax.set_xlabel(\"amount of $\\sigma$ from empirical mean\")\nfrom biophysics_fitting.hay_complete_default_setup_python import get_Evaluator\n\nevaluator = get_Evaluator(step=False)\nsimulator = db['simulator']\nbiophysical_parameter_ranges = db['89']['params']\nexample_models = db['example_models']\nbiophysical_parameter_names = [e for e in example_models.columns if \"ephys\" in e or e == \"scale_apical.scale\"]\nif not I.os.path.exists(I.os.path.join(db.basedir, 'RW_exploration_example')):\n    db.create_managed_folder('RW_exploration_example')\nfrom biophysics_fitting.exploration_from_seedpoint.RW import RW\nfrom biophysics_fitting.exploration_from_seedpoint.utils import evaluation_function_incremental_helper\nfrom biophysics_fitting.hay_evaluation import hay_evaluate_bAP, hay_evaluate_BAC\n\nevaluation_function = I.partial(\n    evaluation_function_incremental_helper,  # this incremental helper stops the evaluation as soon as a stimulus protocol doesn't work.\n    s=simulator,\n    e=evaluator,\n    stim_order=['bAP', 'BAC']\n)\n\nrw = RW(\n    param_ranges = biophysical_parameter_ranges,\n    df_seeds = example_models[biophysical_parameter_names],\n    evaluation_function = evaluation_function,\n    MAIN_DIRECTORY = db['RW_exploration_example'],\n    min_step_size = 0.02,\n    max_step_size = 0.02,\n    checkpoint_every = 1  # This is a lot of IO. Increase this value if you are not merely doing an example.\n)\nduration = 120  # in seconds\n\nfrom time import sleep\nfrom threading import Thread\nimport multiprocessing\n\nproc = multiprocessing.Process(\n    target=rw.run_RW, \n    kwargs={\n        'selected_seedpoint': 0,\n        'particle_id': 0,\n        'seed': 42  # for numpy random seed\n    })\n\n# --- run for some time, then kill the process\nproc.start()\nsleep(duration)\nproc.terminate()  # sends a SIGTERM\nproc.join()\nprint(l.get_df())\nfrom biophysics_fitting.exploration_from_seedpoint.RW_analysis import Load\n\noutdir = db['RW_exploration_example'].join('0')\nl = Load(\n    I.get_client(),\n    outdir,\n    n_particles = 1)\nprint(l.get_df())\nexplored_models = l.get_df().compute()\nprint(\"Explored {} new models\".format(len(explored_models)))\ndef normalize(df, mn, mx):\n    return (df - mn)/(mx-mn)\n    \nmn, mx = biophysical_parameter_ranges['min'], biophysical_parameter_ranges['max']\nnormalized_startpoint = normalize(example_models.iloc[0][biophysical_parameter_names], mn, mx)\nnormalized_explored_models = normalize(explored_models[biophysical_parameter_names], mn, mx)\n\n# calc exploration relative to startpoint, in % of total allowed parameter limits\nd = I.pd.concat([normalized_explored_models, I.pd.DataFrame(normalized_startpoint).T])\nd -= normalized_startpoint\nd[biophysical_parameter_names] *= 100\nd = d.melt(var_name='Biophysical parameter', value_name='Normalized value (%)')\nI.plt.figure(figsize=(5, 10))\n\nax = I.sns.boxplot(\n    data=d,\n    y='Biophysical parameter', x='Normalized value (%)',\n    whis=100,\n    linewidth=1,\n    showcaps = False\n   )\ndelayeds = [I.dask.delayed(\n    simulator.run)(p, 'BAC') for _, p in explored_models[biophysical_parameter_names].iterrows()]\nf = I.get_client().compute(delayeds)\nresponses = [f_.result() for f_ in f]\nBAC_responses = [response['BAC.hay_measure'] for response in responses]\nresponses\nresponses = [f_.result() for f_ in f]\n\nresponses\ndef import_mechanisms(): import mechanisms\nclient.run(import_mechanisms)\ndef import_mechanisms(): import mechanisms\nI.get_client().run(import_mechanisms)\nresponses = [f_.result() for f_ in f]\n\nresponses\ndef import_mechanisms(): import mechanisms\ndef update_path(): sys.path.insert(0, os.path.join(__file__, \"../../../mechanisms\")\nI.get_client().run(import_mechanisms)\nI.get_client().run(update_path)\ndef import_mechanisms(): import mechanisms\ndef update_path(): sys.path.insert(0, os.path.join(__file__, \"../../../mechanisms\"))\nI.get_client().run(import_mechanisms)\nI.get_client().run(update_path)\ndef import_mechanisms(): import mechanisms\nimport sys\ndef update_path(): sys.path.insert(0, os.path.join(__file__, \"../../../mechanisms\"))\nI.get_client().run(import_mechanisms)\nI.get_client().run(update_path)\ndef import_mechanisms(): import mechanisms\nimport sys, os\ndef update_path(): sys.path.insert(0, os.path.join(__file__, \"../../../mechanisms\"))\nI.get_client().run(import_mechanisms)\nI.get_client().run(update_path)\ndef import_mechanisms(): import mechanisms\nimport sys, os\ndef update_path(): sys.path.insert(0, \"../../../mechanisms\")\nI.get_client().run(import_mechanisms)\nI.get_client().run(update_path)\nresponses = [f_.result() for f_ in f]\n\nresponses\ndelayeds = [I.dask.delayed(\n    simulator.run)(p, 'BAC') for _, p in explored_models[biophysical_parameter_names].iterrows()]\nf = I.get_client().compute(delayeds)\nresponses = [f_.result() for f_ in f]\n\nresponses\nresponses = [f_.result() for f_ in f]\nBAC_responses = [response['BAC.hay_measure'] for response in responses]\nBAC_responses\nI.plt.plot(BAC_responses)\nBAC_responses\nBAC_responses\nI.plt.plot(BAC_responses['tVec'], BAC_responses['VList'])\nBAC_responses.keys()\nBAC_responses[0].keys()\nI.plt.plot(BAC_responses[:]['tVec'], BAC_responses[:]['VList'])\nvoltage_traces = [r['VList'] for r in BAC_responses]\ntime = [r['tVec'] for r in BAC_responses]\nvoltage_traces = [r['vList'] for r in BAC_responses]\ntime = [r['tVec'] for r in BAC_responses]\nI.plt.plot([r['tVec'], BAC_responses[:]['VList'])\nI.plt.plot(time, voltage_traces)\nfor t, v in zip(time, voltage_traces):\n    I.plt.plot(t, v)\nfor t, v in zip(time, voltage_traces):\n    I.plt.plot(t, v[0])\nfor t, v in zip(time, voltage_traces):\n    I.plt.plot(t, v[0], c='grey')\nfor t, v in zip(time, voltage_traces):\n    I.plt.plot(t, v[0], c='grey', lw=1)\nfor t, v in zip(time, voltage_traces):\n    I.plt.plot(t, m, c='grey', lw=1)\nvoltage_traces = [r['vList'] for r in BAC_responses]\ntime = [r['tVec'] for r in BAC_responses]\n\nm, s = I.np.mean(voltage_traces), I.np.std(voltage_traces)\nfor t, v in zip(time, voltage_traces):\n    I.plt.plot(t, m, c='grey', lw=1)\nvoltage_traces = [r['vList'] for r in BAC_responses]\ntime = [r['tVec'] for r in BAC_responses]\n\nm= I.np.mean(voltage_traces)\nvoltage_traces = [r['vList'] for r in BAC_responses]\ntime = [r['tVec'] for r in BAC_responses]\n\nm= I.np.mean(voltage_traces[0])\nvoltage_traces = [r['vList'] for r in BAC_responses]\ntime = [r['tVec'] for r in BAC_responses]\n\nm= I.np.mean(voltage_traces[0])\ns = I.np.std(voltage(traces[0]))\nvoltage_traces = [r['vList'] for r in BAC_responses]\ntime = [r['tVec'] for r in BAC_responses]\n\nm= I.np.mean(voltage_traces[0])\ns = I.np.std(voltage_traces[0])\nfor t, v in zip(time, voltage_traces):\n    I.plt.plot(t, m, c='grey', lw=1)\nm\nvoltage_traces\nvoltage_traces.shape\nvoltage_traces[0].shape\nvoltage_traces[0]\nvoltage_traces = [r['vList'] for r in BAC_responses]\ntime = [r['tVec'] for r in BAC_responses]\n\nm = I.np.mean(voltage_traces[0], axis=1)\ns = I.np.std(voltage_traces[0])\nfor t, v in zip(time, voltage_traces):\n    I.plt.plot(t, m, c='grey', lw=1)\nm\nvoltage_traces = [r['vList'] for r in BAC_responses]\ntime = [r['tVec'] for r in BAC_responses]\n\nm = I.np.mean(voltage_traces[0], axis=2)\ns = I.np.std(voltage_traces[0])\nvoltage_traces[0]\nlen(voltage_traces[0])\nvoltage_traces = [r['vList'] for r in BAC_responses]\ntime = [r['tVec'] for r in BAC_responses]\n\nm = I.np.mean(voltage_traces[:][0], axis=2)\ns = I.np.std(voltage_traces[0])\nvoltage_traces = [r['vList'] for r in BAC_responses]\ntime = [r['tVec'] for r in BAC_responses]\n\nm = I.np.mean(voltage_traces[:][0], axis=1)\ns = I.np.std(voltage_traces[0])\nfor t, v in zip(time, voltage_traces):\n    I.plt.plot(t, m, c='grey', lw=1)\nm\nvoltage_traces = [r['vList'] for r in BAC_responses]\ntime = [r['tVec'] for r in BAC_responses]\n\nm = I.np.mean(voltage_traces[:][0], axis=0)\ns = I.np.std(voltage_traces[0])\nm\nfor t, v in zip(time, voltage_traces):\n    I.plt.plot(t, m, c='grey', lw=1)\nI.plt.plot(t, m, c='grey', lw=1)\nI.plt.plot(t[0], m, c='grey', lw=1)\nI.plt.plot(t, m, c='grey', lw=1)\ntime\ntime[0]\ntime[1]\nvoltage_traces = [r['vList'] for r in BAC_responses]\ntime = [r['tVec'] for r in BAC_responses]\n\nm_t=[]\ntime_series = np.arange(np.stack(t).max())\nfor i in range(len(time)):\n  time_diff = time_series-time[i][:,None]\n  m_t.append(voltage_traces[:][0][i][np.where(time_diff > 0, time_diff, np.inf).argmin(axis=0)])\naverage = np.mean(m_t, axis=0)\nvoltage_traces = [r['vList'] for r in BAC_responses]\ntime = [r['tVec'] for r in BAC_responses]\n\nm_t=[]\ntime_series = I.np.arange(np.stack(t).max())\nfor i in range(len(time)):\n  time_diff = time_series-time[i][:,None]\n  m_t.append(voltage_traces[:][0][i][I.np.where(time_diff > 0, time_diff, np.inf).argmin(axis=0)])\naverage = np.mean(m_t, axis=0)\nvoltage_traces = [r['vList'] for r in BAC_responses]\ntime = [r['tVec'] for r in BAC_responses]\n\nm_t=[]\ntime_series = I.np.arange(np.stack(t).max())\nfor i in range(len(time)):\n  time_diff = time_series-time[i][:,None]\n  m_t.append(voltage_traces[:][0][i][I.np.where(time_diff > 0, time_diff, I.np.inf).argmin(axis=0)])\naverage = np.mean(m_t, axis=0)\nvoltage_traces = [r['vList'] for r in BAC_responses]\ntime = [r['tVec'] for r in BAC_responses]\n\nm_t=[]\ntime_series = I.np.arange(I.np.stack(time).max())\nfor i in range(len(time)):\n  time_diff = time_series-time[i][:,None]\n  m_t.append(voltage_traces[:][0][i][I.np.where(time_diff > 0, time_diff, I.np.inf).argmin(axis=0)])\naverage = np.mean(m_t, axis=0)\ntime\n(len[e] for e in time]\n[len[e] for e in time]\n[len(e) for e in time]\nmin([len(e) for e in time])\nmax([max(e) for e in time])\nmin([max(e) for e in time])\nmin([min(e) for e in time])\nmax([min(e) for e in time])\nmin([max(e) for e in time])\ndef bin_voltage_trace(t, v, t_end=600, n_bins=100):\n    time_bins=I.np.linspace(0, t_end, n_bins)\n    binsize = t_end/n_bins\n    return_voltage = []\n    for t in time_bins:\n        bin_indices = I.np.where([e <= t < e + binsize])\n        v = I.np.mean([v[i] for i in bin_indices])\n        return_voltage.append(v)\n    return return_voltage\n\nbin_voltage_trace(t[0], voltage_traces[0][:][0])\n    \ndef bin_voltage_trace(t, v, t_end=600, n_bins=100):\n    time_bins=I.np.linspace(0, t_end, n_bins)\n    binsize = t_end/n_bins\n    return_voltage = []\n    for t_bin in time_bins:\n        bin_indices = I.np.where([e <= t_bin < e + binsize for e in t])\n        v = I.np.mean([v[i] for i in bin_indices])\n        return_voltage.append(v)\n    return return_voltage\n\nbin_voltage_trace(t[0], voltage_traces[0][:][0])\n    \ndef bin_voltage_trace(t, v, t_end=600, n_bins=100):\n    time_bins=I.np.linspace(0, t_end, n_bins)\n    binsize = t_end/n_bins\n    return_voltage = []\n    for t_bin in time_bins:\n        bin_indices = I.np.where([e <= t_bin < e + binsize for e in t])\n        v = I.np.mean([v[i] for i in bin_indices])\n        return_voltage.append(v)\n    return return_voltage\n\nbin_voltage_trace(time[0], voltage_traces[0][:][0])\n    \ndef bin_voltage_trace(t, v, t_end=600, n_bins=100):\n    time_bins=I.np.linspace(0, t_end, n_bins)\n    binsize = t_end/n_bins\n    return_voltage = []\n    for t_bin in time_bins:\n        bin_indices = I.np.where([e <= t_bin < e + binsize for e in t])\n        print(bin_indices)\n        v = I.np.mean([v[i] for i in bin_indices])\n        return_voltage.append(v)\n    return return_voltage\n\nbin_voltage_trace(time[0], voltage_traces[0][:][0])\n    \ndef bin_voltage_trace(t, v, t_end=600, n_bins=100):\n    time_bins=I.np.linspace(0, t_end, n_bins)\n    binsize = t_end/n_bins\n    return_voltage = []\n    for t_bin in time_bins:\n        bin_indices = I.np.where([e <= t_bin < e + binsize for e in t])[0]\n        print(bin_indices)\n        v = I.np.mean([v[i] for i in bin_indices])\n        return_voltage.append(v)\n    return return_voltage\n\nbin_voltage_trace(time[0], voltage_traces[0][:][0])\n    \ndef bin_voltage_trace(t, v, t_end=600, n_bins=100):\n    time_bins=I.np.linspace(0, t_end, n_bins)\n    binsize = t_end/n_bins\n    return_voltage = []\n    for t_bin in time_bins:\n        bin_indices = I.np.where([e <= t_bin < e + binsize for e in t])[0]\n        v = I.np.mean(v[bin_indices])\n        return_voltage.append(v)\n    return return_voltage\n\nbin_voltage_trace(time[0], voltage_traces[0][:][0])\n    \ndef bin_voltage_trace(t, v, t_end=600, n_bins=100):\n    time_bins=I.np.linspace(0, t_end, n_bins)\n    binsize = t_end/n_bins\n    return_voltage = []\n    for t_bin in time_bins:\n        bin_indices = I.np.where([e <= t_bin < e + binsize for e in t])[0]\n        v = I.np.mean([v[i] for i in bin_indices])\n        return_voltage.append(v)\n    return return_voltage\n\nbin_voltage_trace(time[0], voltage_traces[0][:][0])\n    \ndef bin_voltage_trace(t, v, t_end=600, n_bins=100):\n    time_bins=I.np.linspace(0, t_end, n_bins)\n    binsize = t_end/n_bins\n    return_voltage = []\n    for t_bin in time_bins:\n        bin_indices = I.np.where([e <= t_bin < e + binsize for e in t])[0]\n        print(v)\n        v = I.np.mean([v[i] for i in bin_indices])\n        return_voltage.append(v)\n    return return_voltage\n\nbin_voltage_trace(time[0], voltage_traces[0][:][0])\n    \ndef bin_voltage_trace(t, v, t_end=600, n_bins=100):\n    time_bins=I.np.linspace(0, t_end, n_bins)\n    binsize = t_end/n_bins\n    return_voltage = []\n    for t_bin in time_bins:\n        bin_indices = I.np.where([e <= t_bin < e + binsize for e in t])[0]\n        print(bin_indices)\n        v = I.np.mean([v[i] for i in bin_indices])\n        return_voltage.append(v)\n    return return_voltage\n\nbin_voltage_trace(time[0], voltage_traces[0][:][0])\n    \ndef bin_voltage_trace(t, v, t_end=600, n_bins=100):\n    time_bins=I.np.linspace(0, t_end, n_bins)\n    binsize = t_end/n_bins\n    return_voltage = []\n    for t_bin in time_bins:\n        bin_indices = I.np.where([e <= t_bin < e + binsize for e in t])[0]\n        print(bin_indices)\n        print(v)\n        v = I.np.mean([v[i] for i in bin_indices])\n        return_voltage.append(v)\n    return return_voltage\n\nbin_voltage_trace(time[0], voltage_traces[0][:][0])\n    \ndef bin_voltage_trace(t, v, t_end=600, n_bins=100):\n    time_bins=I.np.linspace(0, t_end, n_bins)\n    binsize = t_end/n_bins\n    return_voltage = []\n    for t_bin in time_bins:\n        bin_indices = I.np.where([e <= t_bin < e + binsize for e in t])[0]\n        v_this_bin = I.np.mean([v[i] for i in bin_indices])\n        return_voltage.append(v_this_bin)\n    return return_voltage\n\nbin_voltage_trace(time[0], voltage_traces[0][:][0])\n    \ndef bin_voltage_trace(t, v, t_end=600, n_bins=100, voltage_index=0):\n    \"\"\"\n    Voltage traces have a variable time step, so this method bins them by predefined time intervals\n    Can be used to effectively calculate an average voltage trace of multiple responses later on.\n    \"\"\"\n    time_bins=I.np.linspace(0, t_end, n_bins)\n    binsize = t_end/n_bins\n    return_voltage = []\n    for t_bin in time_bins:\n        bin_indices = I.np.where([e <= t_bin < e + binsize for e in t])[0]\n        v_this_bin = I.np.mean([v[i] for i in bin_indices])\n        return_voltage.append(v_this_bin)\n    return return_voltage\n\ndef average_voltage_trace(times, voltages, t_end=600, n_bins=100, voltage_index=0):\n    binned_voltages = [\n        bin_voltage_trace(t, v, t_end=t_end, n_bins=n_bins) for t, v in zip(times, voltages)\n    ]\n    average_voltage = I.np.mean(binned_voltages, axis=1)\n    return average_voltage\n\naverage_voltage_trace(time, voltage_traces)\nvoltage_traces\nvoltage_traces.shape\nlen(voltage_traces)\nvoltage_traces[0]\nlen(voltage_traces[0])\ndef bin_voltage_trace(t, v, t_end=600, n_bins=100, voltage_index=0):\n    \"\"\"\n    Voltage traces have a variable time step, so this method bins them by predefined time intervals\n    Can be used to effectively calculate an average voltage trace of multiple responses later on.\n    \"\"\"\n    time_bins=I.np.linspace(0, t_end, n_bins)\n    binsize = t_end/n_bins\n    return_voltage = []\n    for t_bin in time_bins:\n        bin_indices = I.np.where([e <= t_bin < e + binsize for e in t])[0]\n        v_this_bin = I.np.mean([v[i] for i in bin_indices])\n        return_voltage.append(v_this_bin)\n    return return_voltage\n\ndef average_voltage_trace(times, voltages, t_end=600, n_bins=100, voltage_index=0):\n    binned_voltages = [\n        bin_voltage_trace(t, v, t_end=t_end, n_bins=n_bins, voltage_index=voltage_index) for t, v in zip(times, voltages)\n    ]\n    average_voltage = I.np.mean(binned_voltages, axis=1)\n    return average_voltage\n\naverage_voltage_trace(time, voltage_traces)\ndef bin_voltage_trace(t, v, t_end=600, n_bins=100, voltage_index=0):\n    \"\"\"\n    Voltage traces have a variable time step, so this method bins them by predefined time intervals\n    Can be used to effectively calculate an average voltage trace of multiple responses later on.\n    \"\"\"\n    time_bins=I.np.linspace(0, t_end, n_bins)\n    binsize = t_end/n_bins\n    return_voltage = []\n    for t_bin in time_bins:\n        bin_indices = I.np.where([e <= t_bin < e + binsize for e in t])[0]\n        print(max(bin_indices))\n        print(v)\n        v_this_bin = I.np.mean([v[i] for i in bin_indices])\n        return_voltage.append(v_this_bin)\n    return return_voltage\n\ndef average_voltage_trace(times, voltages, t_end=600, n_bins=100, voltage_index=0):\n    binned_voltages = [\n        bin_voltage_trace(t, v, t_end=t_end, n_bins=n_bins, voltage_index=voltage_index) for t, v in zip(times, voltages)\n    ]\n    average_voltage = I.np.mean(binned_voltages, axis=1)\n    return average_voltage\n\naverage_voltage_trace(time, voltage_traces)\ndef bin_voltage_trace(t, v, t_end=600, n_bins=100, voltage_index=0):\n    \"\"\"\n    Voltage traces have a variable time step, so this method bins them by predefined time intervals\n    Can be used to effectively calculate an average voltage trace of multiple responses later on.\n    \"\"\"\n    time_bins=I.np.linspace(0, t_end, n_bins)\n    binsize = t_end/n_bins\n    return_voltage = []\n    for t_bin in time_bins:\n        bin_indices = I.np.where([e <= t_bin < e + binsize for e in t])[0]\n        print(max(bin_indices))\n        print(len(v))\n        v_this_bin = I.np.mean([v[i] for i in bin_indices])\n        return_voltage.append(v_this_bin)\n    return return_voltage\n\ndef average_voltage_trace(times, voltages, t_end=600, n_bins=100, voltage_index=0):\n    binned_voltages = [\n        bin_voltage_trace(t, v, t_end=t_end, n_bins=n_bins, voltage_index=voltage_index) for t, v in zip(times, voltages)\n    ]\n    average_voltage = I.np.mean(binned_voltages, axis=1)\n    return average_voltage\n\naverage_voltage_trace(time, voltage_traces)\ndef bin_voltage_trace(t, v, t_end=600, n_bins=100, voltage_index=0):\n    \"\"\"\n    Voltage traces have a variable time step, so this method bins them by predefined time intervals\n    Can be used to effectively calculate an average voltage trace of multiple responses later on.\n    \"\"\"\n    time_bins=I.np.linspace(0, t_end, n_bins)\n    binsize = t_end/n_bins\n    return_voltage = []\n    for t_bin in time_bins:\n        bin_indices = I.np.where([e <= t_bin < e + binsize for e in t])[0]\n        v_this_bin = I.np.mean([v[voltage_index][i] for i in bin_indices])\n        return_voltage.append(v_this_bin)\n    return return_voltage\n\ndef average_voltage_trace(times, voltages, t_end=600, n_bins=100, voltage_index=0):\n    binned_voltages = [\n        bin_voltage_trace(t, v, t_end=t_end, n_bins=n_bins, voltage_index=voltage_index) for t, v in zip(times, voltages)\n    ]\n    average_voltage = I.np.mean(binned_voltages, axis=1)\n    return average_voltage\n\naverage_voltage_trace(time, voltage_traces)\ndef bin_voltage_trace(t, v, t_end=600, n_bins=100, voltage_index=0):\n    \"\"\"\n    Voltage traces have a variable time step, so this method bins them by predefined time intervals\n    Can be used to effectively calculate an average voltage trace of multiple responses later on.\n    \"\"\"\n    time_bins=I.np.linspace(0, t_end, n_bins)\n    binsize = t_end/n_bins\n    return_voltage = []\n    for t_bin in time_bins:\n        bin_indices = I.np.where([e <= t_bin < e + binsize for e in t])[0]\n        v_this_bin = I.np.mean([v[voltage_index][i] for i in bin_indices])\n        return_voltage.append(v_this_bin)\n    return return_voltage\n\ndef average_voltage_trace(times, voltages, t_end=600, n_bins=100, voltage_index=0):\n    binned_voltages = [\n        bin_voltage_trace(t, v, t_end=t_end, n_bins=n_bins, voltage_index=voltage_index) for t, v in zip(times, voltages)\n    ]\n    average_voltage = I.np.nanmean(binned_voltages, axis=0)\n    return average_voltage\n\naverage_voltage_trace(time, voltage_traces)\ndef bin_voltage_trace(t, v, t_end=600, n_bins=100, voltage_index=0):\n    \"\"\"\n    Voltage traces have a variable time step, so this method bins them by predefined time intervals\n    Can be used to effectively calculate an average voltage trace of multiple responses later on.\n    \"\"\"\n    time_bins=I.np.linspace(0, t_end, n_bins)\n    binsize = t_end/n_bins\n    return_voltage = []\n    for t_bin in time_bins:\n        bin_indices = I.np.where([e <= t_bin < e + binsize for e in t])[0]\n        v_this_bin = I.np.mean([v[voltage_index][i] for i in bin_indices])\n        return_voltage.append(v_this_bin)\n    return return_voltage\n\ndef calc_average_voltage_trace(times, voltages, t_end=600, n_bins=100, voltage_index=0):\n    binned_voltages = [\n        bin_voltage_trace(t, v, t_end=t_end, n_bins=n_bins, voltage_index=voltage_index) for t, v in zip(times, voltages)\n    ]\n    average_voltage = I.np.nanmean(binned_voltages, axis=0)\n    return average_voltage\n\naverage_voltage = calc_average_voltage_trace(time, voltage_traces)\nt_end = 600\nn_bins = 100\nvoltage_index = 0  # 0 for somatic voltage, 1 for voltage at apical dendrite\naverage_voltage = calc_average_voltage_trace(time, voltage_traces, t_end=t_end, n_bins=n_bins, voltage_index=voltage_index)\nI.plt.plot(t, average_voltage, c='grey', lw=1)\nI.plt.plot(binned_time, average_voltage, c='grey', lw=1)\nt_end = 600\nn_bins = 100\nbinned_time = I.np.linspace(0, t_end, n_bins)\nvoltage_index = 0  # 0 for somatic voltage, 1 for voltage at apical dendrite\naverage_voltage = calc_average_voltage_trace(time, voltage_traces, t_end=t_end, n_bins=n_bins, voltage_index=voltage_index)\nI.plt.plot(binned_time, average_voltage, c='grey', lw=1)\nt_end = 600\nn_bins = 1200\nbinned_time = I.np.linspace(0, t_end, n_bins)\nvoltage_index = 0  # 0 for somatic voltage, 1 for voltage at apical dendrite\naverage_voltage = calc_average_voltage_trace(time, voltage_traces, t_end=t_end, n_bins=n_bins, voltage_index=voltage_index)\nI.plt.plot(binned_time, average_voltage, c='grey', lw=1)\nsoma_voltages = [\n    BAC_responses['VList'][:][0]\n]\nsoma_voltages\nBAC_responses\nsoma_voltages = [\n    BAC_responses[:]['VList'][0]\n]\nsoma_voltages\nBAC_responses[0]\nBAC_responses[0]['VList']\nBAC_responses[0]['vList']\nsoma_voltages = [\n    BAC_responses[:]['vList'][0]\n]\nsoma_voltages\nsoma_voltages = [\n    e['vList'][0] for e in BAC_responses\n]\nsoma_voltages\nsoma_voltages = [\n    e['vList'][0] for e in BAC_responses\n]\ndend_voltages = [\n    e['vList'][1] for e in BAC_responses\n]\nsoma_voltages = [\n    e['vList'][0] for e in BAC_responses\n]\ndend_voltages = [\n    e['vList'][1] for e in BAC_responses\n]\ntime_points = [\n    e['tVec'] for e in BAC_responses\n]\nI.plt.plot(time_points, soma_voltages, c='grey', lw=1)\nfor t, v in zip(soma_voltages, time_points):\n    I.plt.plot(t, v, c='grey', lw=1)\nfor t, v in zip(time_points, soma_voltages):\n    I.plt.plot(t, v, c='grey', lw=1)\nfor t, v in zip(time_points, soma_voltages):\n    I.plt.plot(t, v, c='grey', lw=1)\nI.plt.plot(t, v)\nfor t, v in zip(time_points, soma_voltages):\n    I.plt.plot(t, v, c='grey', lw=2)\nI.plt.plot(t, v, lw=1)\nfor t, v in zip(time_points, soma_voltages):\n    I.plt.plot(t, v, c='grey', lw=2)\nI.plt.plot(t, v, lw=1)\n\nfor t, v in zip(time_points, dend_voltages = [):\n    I.plt.plot(t, v, c='grey', lw=2)\nI.plt.plot(t, v, lw=1)\nfor t, v in zip(time_points, soma_voltages):\n    I.plt.plot(t, v, c='grey', lw=2)\nI.plt.plot(t, v, lw=1)\n\nfor t, v in zip(time_points, dend_voltages ):\n    I.plt.plot(t, v, c='grey', lw=2)\nI.plt.plot(t, v, lw=1)\nfor t, v in zip(time_points, soma_voltages):\n    I.plt.plot(t, v, c='grey', lw=2)\nI.plt.plot(t, v, lw=1)\nI.plt.show()\n\nfor t, v in zip(time_points, dend_voltages ):\n    I.plt.plot(t, v, c='grey', lw=2)\nI.plt.plot(t, v, lw=1)\nI.plt.show()\nfor t, v in zip(time_points, soma_voltages):\n    I.plt.plot(t, v, c='grey', lw=2)\nI.plt.plot(t, v)\nI.plt.show()\n\nfor t, v in zip(time_points, dend_voltages ):\n    I.plt.plot(t, v, c='grey', lw=2)\nI.plt.plot(t, v)\nI.plt.show()\nfig, axes = I.plt.subplots(2, ncols=2)\n\nfor t, v in zip(time_points, soma_voltages):\n    I.plt.plot(t, v, c='grey', lw=2)\nI.plt.plot(t, v)\nI.plt.show()\n\nfor t, v in zip(time_points, dend_voltages ):\n    I.plt.plot(t, v, c='grey', lw=2)\nI.plt.plot(t, v)\nI.plt.show()\nfig, axes = I.plt.subplots(1, 2)\n\nfor t, v in zip(time_points, soma_voltages):\n    I.plt.plot(t, v, c='grey', lw=2)\nI.plt.plot(t, v)\nI.plt.show()\n\nfor t, v in zip(time_points, dend_voltages ):\n    I.plt.plot(t, v, c='grey', lw=2)\nI.plt.plot(t, v)\nI.plt.show()\nfig, (ax1, ax2) = I.plt.subplots(1, 2)\n\nfor t, v in zip(time_points, soma_voltages):\n    ax1.plot(t, v, c='grey', lw=2)\nax1.plot(t, v)\n\nfor t, v in zip(time_points, dend_voltages ):\n    ax2.plot(t, v, c='grey', lw=2)\nax2.plot(t, v)\nI.plt.show()\nfig, (ax1, ax2) = I.plt.subplots(1, 2, figsize=(5, 10))\n\nfor t, v in zip(time_points, soma_voltages):\n    ax1.plot(t, v, c='grey', lw=2)\nax1.plot(t, v)\n\nfor t, v in zip(time_points, dend_voltages ):\n    ax2.plot(t, v, c='grey', lw=2)\nax2.plot(t, v)\nI.plt.show()\nfig, (ax1, ax2) = I.plt.subplots(1, 2, figsize=(10, 5))\n\nfor t, v in zip(time_points, soma_voltages):\n    ax1.plot(t, v, c='grey', lw=2)\nax1.plot(t, v)\n\nfor t, v in zip(time_points, dend_voltages ):\n    ax2.plot(t, v, c='grey', lw=2)\nax2.plot(t, v)\nI.plt.show()\nfig, (ax1, ax2) = I.plt.subplots(1, 2, figsize=(15, 5))\n\nfor t, v in zip(time_points, soma_voltages):\n    ax1.plot(t, v, c='grey', lw=2)\nax1.plot(t, v)\n\nfor t, v in zip(time_points, dend_voltages ):\n    ax2.plot(t, v, c='grey', lw=2)\nax2.plot(t, v)\nI.plt.show()\nfig, (ax1, ax2) = I.plt.subplots(1, 2, figsize=(15, 5))\ncolors = I.plt.rcParams['axes.prop_cycle'].by_key()['color']                       \n\n\nfor t, v in zip(time_points, soma_voltages):\n    ax1.plot(t, v, c='grey', lw=2)\nax1.plot(t, v)\n\nfor t, v in zip(time_points, dend_voltages ):\n    ax2.plot(t, v, c='grey', lw=2)\nax2.plot(t, v, c=colors[1])\nI.plt.show()\nfig, (ax1, ax2) = I.plt.subplots(1, 2, figsize=(15, 5))\ncolors = I.plt.rcParams['axes.prop_cycle'].by_key()['color']                       \n\n\nfor t, v in zip(time_points, soma_voltages):\n    ax1.plot(t, v, c='grey', lw=2)\nax1.plot(t, v)\nax1.set_title(\"Soma voltage\")\n\nfor t, v in zip(time_points, dend_voltages ):\n    ax2.plot(t, v, c='grey', lw=2)\nax2.plot(t, v, c=colors[1])\nax2.set_title(\"Dendritic voltage\")\nI.plt.show()\nfig, (ax1, ax2) = I.plt.subplots(1, 2, figsize=(15, 5))\ncolors = I.plt.rcParams['axes.prop_cycle'].by_key()['color']                       \n\n\nfor t, v in zip(time_points, soma_voltages):\n    ax1.plot(t, v, c='grey', lw=2)\nax1.plot(t[-1], v[-1])\nax1.set_title(\"Soma voltage\")\n\nfor t, v in zip(time_points, dend_voltages ):\n    ax2.plot(t, v, c='grey', lw=2)\nax2.plot(t, v, c=colors[1])\nax2.set_title(\"Dendritic voltage\")\nI.plt.show()\nfig, (ax1, ax2) = I.plt.subplots(1, 2, figsize=(15, 5))\ncolors = I.plt.rcParams['axes.prop_cycle'].by_key()['color']                       \n\n\nfor t, v in zip(time_points, soma_voltages):\n    ax1.plot(t, v, c='grey', lw=2)\nax1.plot(t[-1], v[-1], c=colors[0])\nax1.set_title(\"Soma voltage\")\n\nfor t, v in zip(time_points, dend_voltages ):\n    ax2.plot(t, v, c='grey', lw=2)\nax2.plot(t, v, c=colors[1])\nax2.set_title(\"Dendritic voltage\")\nI.plt.show()\nfig, (ax1, ax2) = I.plt.subplots(1, 2, figsize=(15, 5))\ncolors = I.plt.rcParams['axes.prop_cycle'].by_key()['color']                       \nrandom_model = I.np.randint(0, len(BAC_responses))\n\nfor t, v in zip(time_points, soma_voltages):\n    ax1.plot(t, v, c='grey', lw=2)\nax1.plot(t[random_model], v[random_model], c=colors[0])\nax1.set_title(\"Soma voltage\")\n\nfor t, v in zip(time_points, dend_voltages ):\n    ax2.plot(t, v, c='grey', lw=2)\nax2.plot(t, v, c=colors[1])\nax2.set_title(\"Dendritic voltage\")\nI.plt.show()\nfig, (ax1, ax2) = I.plt.subplots(1, 2, figsize=(15, 5))\ncolors = I.plt.rcParams['axes.prop_cycle'].by_key()['color']                       \nrandom_model = I.np.random.randint(0, len(BAC_responses))\n\nfor t, v in zip(time_points, soma_voltages):\n    ax1.plot(t, v, c='grey', lw=2)\nax1.plot(t[random_model], v[random_model], c=colors[0])\nax1.set_title(\"Soma voltage\")\n\nfor t, v in zip(time_points, dend_voltages ):\n    ax2.plot(t, v, c='grey', lw=2)\nax2.plot(t, v, c=colors[1])\nax2.set_title(\"Dendritic voltage\")\nI.plt.show()\nfig, (ax1, ax2) = I.plt.subplots(1, 2, figsize=(15, 5))\ncolors = I.plt.rcParams['axes.prop_cycle'].by_key()['color']                       \nrandom_model = I.np.random.randint(0, len(BAC_responses))\n\nfor t, v in zip(time_points, soma_voltages):\n    ax1.plot(t, v, c='grey', lw=2)\nax1.plot(t[random_model], v[random_model], c=colors[0])\nax1.set_title(\"Soma voltage\")\n\nfor t, v in zip(time_points, dend_voltages ):\n    ax2.plot(t, v, c='grey', lw=2)\nax2.plot(t, v, c=colors[1])\nax2.set_title(\"Dendritic voltage\")\nI.plt.show()\nfig, (ax1, ax2) = I.plt.subplots(1, 2, figsize=(15, 5))\ncolors = I.plt.rcParams['axes.prop_cycle'].by_key()['color']                       \nrandom_model = I.np.random.randint(0, len(BAC_responses))\n\nfor t, v in zip(time_points, soma_voltages):\n    ax1.plot(t, v, c='grey', lw=2)\nax1.plot(t[random_model], v[random_model], c=colors[0])\nax1.set_title(\"Soma voltage\")\n\nfor t, v in zip(time_points, dend_voltages ):\n    ax2.plot(t, v, c='grey', lw=2)\nax2.plot(t, v, c=colors[1])\nax2.set_title(\"Dendritic voltage\")\nI.plt.show()\nfig, (ax1, ax2) = I.plt.subplots(1, 2, figsize=(15, 5))\ncolors = I.plt.rcParams['axes.prop_cycle'].by_key()['color']                       \nrandom_model = I.np.random.randint(0, len(BAC_responses))\n\nfor t, v in zip(time_points, soma_voltages):\n    ax1.plot(t, v, c='grey', lw=2)\nax1.plot(t[random_model], v[random_model], c=colors[0])\nax1.set_title(\"Soma voltage\")\n\nfor t, v in zip(time_points, dend_voltages ):\n    ax2.plot(t, v, c='grey', lw=2)\nax2.plot(t, v, c=colors[1])\nax2.set_title(\"Dendritic voltage\")\nI.plt.show()\nfig, (ax1, ax2) = I.plt.subplots(1, 2, figsize=(15, 5))\ncolors = I.plt.rcParams['axes.prop_cycle'].by_key()['color']                       \nrandom_model = I.np.random.randint(0, len(BAC_responses))\n\nfor t, v in zip(time_points, soma_voltages):\n    ax1.plot(t, v, c='grey', lw=2)\nax1.plot(t[random_model], v[random_model], c=colors[0])\nax1.set_title(\"Soma voltage\")\n\nfor t, v in zip(time_points, dend_voltages ):\n    ax2.plot(t, v, c='grey', lw=2)\nax2.plot(t, v, c=colors[1])\nax2.set_title(\"Dendritic voltage\")\nI.plt.show()\nfig, (ax1, ax2) = I.plt.subplots(1, 2, figsize=(15, 5))\ncolors = I.plt.rcParams['axes.prop_cycle'].by_key()['color']                       \nrandom_model = I.np.random.randint(0, len(BAC_responses))\n\nfor t, v in zip(time_points, soma_voltages):\n    ax1.plot(t, v, c='grey', lw=2)\nax1.plot(t[random_model], v[random_model], c=colors[0])\nax1.set_title(\"Soma voltage\")\n\nfor t, v in zip(time_points, dend_voltages ):\n    ax2.plot(t, v, c='grey', lw=2)\nax2.plot(t, v, c=colors[1])\nax2.set_title(\"Dendritic voltage\")\nI.plt.show()\nfig, (ax1, ax2) = I.plt.subplots(1, 2, figsize=(15, 5))\ncolors = I.plt.rcParams['axes.prop_cycle'].by_key()['color']                       \nrandom_model = I.np.random.randint(0, len(BAC_responses))\nprint(\"Highlighting model nr. {}\".format(random_model))\n\nfor t, v in zip(time_points, soma_voltages):\n    ax1.plot(t, v, c='grey', lw=2)\nax1.plot(t[random_model], v[random_model], c=colors[0])\nax1.set_title(\"Soma voltage\")\n\nfor t, v in zip(time_points, dend_voltages ):\n    ax2.plot(t, v, c='grey', lw=2)\nax2.plot(t, v, c=colors[1])\nax2.set_title(\"Dendritic voltage\")\nI.plt.show()\nfig, (ax1, ax2) = I.plt.subplots(1, 2, figsize=(15, 5))\ncolors = I.plt.rcParams['axes.prop_cycle'].by_key()['color']                       \nrandom_model = I.np.random.randint(0, len(BAC_responses))\nprint(\"Highlighting model nr. {}\".format(random_model))\n\nfor t, v in zip(time_points, soma_voltages):\n    ax1.plot(t, v, c='grey', lw=2)\nax1.plot(t[random_model], v[random_model], c=colors[0])\nax1.set_title(\"Soma voltage\")\n\nfor t, v in zip(time_points, dend_voltages ):\n    ax2.plot(t, v, c='grey', lw=2)\nax2.plot(t, v, c=colors[1])\nax2.set_title(\"Dendritic voltage\")\nI.plt.show()\nfig, (ax1, ax2) = I.plt.subplots(1, 2, figsize=(15, 5))\ncolors = I.plt.rcParams['axes.prop_cycle'].by_key()['color']                       \nrandom_model = I.np.random.randint(0, len(BAC_responses))\nprint(\"Highlighting model nr. {}\".format(random_model))\n\nfor t, v in zip(time_points, soma_voltages):\n    ax1.plot(t, v, c='grey', lw=2)\nax1.plot(time_points[random_model], soma_voltages[random_model], c=colors[0])\nax1.set_title(\"Soma voltage\")\n\nfor t, v in zip(time_points, dend_voltages ):\n    ax2.plot(t, v, c='grey', lw=2)\nax2.plot(t, v, c=colors[1])\nax2.set_title(\"Dendritic voltage\")\nI.plt.show()\nfig, (ax1, ax2) = I.plt.subplots(1, 2, figsize=(15, 5))\ncolors = I.plt.rcParams['axes.prop_cycle'].by_key()['color']                       \nrandom_model = I.np.random.randint(0, len(BAC_responses))\nprint(\"Highlighting model nr. {}\".format(random_model))\n\nfor t, v in zip(time_points, soma_voltages):\n    ax1.plot(t, v, c='grey', lw=2)\nax1.plot(time_points[random_model], soma_voltages[random_model], c=colors[0])\nax1.set_title(\"Soma voltage\")\n\nfor t, v in zip(time_points, dend_voltages ):\n    ax2.plot(t, v, c='grey', lw=2)\nax2.plot(t, v, c=colors[1])\nax2.set_title(\"Dendritic voltage\")\nI.plt.show()\nfig, (ax1, ax2) = I.plt.subplots(1, 2, figsize=(15, 5))\ncolors = I.plt.rcParams['axes.prop_cycle'].by_key()['color']                       \nrandom_model = I.np.random.randint(0, len(BAC_responses))\nprint(\"Highlighting model nr. {}\".format(random_model))\n\nfor t, v in zip(time_points, soma_voltages):\n    ax1.plot(t, v, c='grey', lw=2)\nax1.plot(time_points[random_model], soma_voltages[random_model], c=colors[0])\nax1.set_title(\"Soma voltage\")\n\nfor t, v in zip(time_points, dend_voltages ):\n    ax2.plot(t, v, c='grey', lw=2)\nax2.plot(t, v, c=colors[1])\nax2.set_title(\"Dendritic voltage\")\nI.plt.show()\nfig, (ax1, ax2) = I.plt.subplots(1, 2, figsize=(15, 5))\ncolors = I.plt.rcParams['axes.prop_cycle'].by_key()['color']                       \nrandom_model = I.np.random.randint(0, len(BAC_responses))\nprint(\"Highlighting model nr. {}\".format(random_model))\n\nfor t, v in zip(time_points, soma_voltages):\n    ax1.plot(t, v, c='grey', lw=2)\nax1.plot(time_points[random_model], soma_voltages[random_model], c=colors[0])\nax1.set_title(\"Soma voltage\")\n\nfor t, v in zip(time_points, dend_voltages ):\n    ax2.plot(t, v, c='grey', lw=2)\nax2.plot(t, v, c=colors[1])\nax2.set_title(\"Dendritic voltage\")\nI.plt.show()\nfig, (ax1, ax2) = I.plt.subplots(1, 2, figsize=(15, 5))\ncolors = I.plt.rcParams['axes.prop_cycle'].by_key()['color']                       \nrandom_model = I.np.random.randint(0, len(BAC_responses))\nprint(\"Highlighting model nr. {}\".format(random_model))\n\nfor t, v in zip(time_points, soma_voltages):\n    ax1.plot(t, v, c='grey', lw=2)\nax1.plot(time_points[random_model], soma_voltages[random_model], c=colors[0])\nax1.set_title(\"Soma voltage\")\n\nfor t, v in zip(time_points, dend_voltages ):\n    ax2.plot(t, v, c='grey', lw=2)\nax2.plot(t, v, c=colors[1])\nax2.set_title(\"Dendritic voltage\")\nI.plt.show()\nfig, (ax1, ax2) = I.plt.subplots(1, 2, figsize=(15, 5))\ncolors = I.plt.rcParams['axes.prop_cycle'].by_key()['color']                       \nrandom_model = I.np.random.randint(0, len(BAC_responses))\nprint(\"Highlighting model nr. {}\".format(random_model))\n\nfor t, v in zip(time_points, soma_voltages):\n    ax1.plot(t, v, c='grey', lw=2)\nax1.plot(time_points[random_model], soma_voltages[random_model], c=colors[0])\nax1.set_title(\"Soma voltage\")\n\nfor t, v in zip(time_points, dend_voltages ):\n    ax2.plot(t, v, c='grey', lw=2)\nax2.plot(time_points[random_model], dend_voltages[random_model], c=colors[1])\nax2.set_title(\"Dendritic voltage\")\nI.plt.show()\nfig, (ax1, ax2) = I.plt.subplots(1, 2, figsize=(15, 5))\ncolors = I.plt.rcParams['axes.prop_cycle'].by_key()['color']                       \nrandom_model = I.np.random.randint(0, len(BAC_responses))\nprint(\"Highlighting model nr. {}\".format(random_model))\n\nfor t, v in zip(time_points, soma_voltages):\n    ax1.plot(t, v, c='grey', lw=2)\nax1.plot(time_points[random_model], soma_voltages[random_model], c=colors[0])\nax1.set_title(\"Soma voltage\")\nax1.set_xlabel(\"Time (ms)\")\nax1.set_ylabel(\"Membrane voltage (mV)\")\n\nfor t, v in zip(time_points, dend_voltages ):\n    ax2.plot(t, v, c='grey', lw=2)\nax2.plot(time_points[random_model], dend_voltages[random_model], c=colors[1])\nax2.set_title(\"Dendritic voltage\")\nax2.set_xlabel(\"Time (ms)\")\nI.plt.show()\nfrom biophysics_fitting.optimizer import start_run\n\npopulation = start_run(\n    db_mooa['89'], \n    n=42, # seed\n    client=I.get_client(), \n    offspring_size=10,  # Low amount of offspring just as an example \n    pop=None,  # adapt this to the output population of the previous run to continue where you left off\n    continue_cp=False,  # if it is a first run, this should equal False. If you want to continue a preivoius run, set to True\n    max_ngen=1  # run for just 1 generation\n    )\nfrom biophysics_fitting.optimizer import start_run\n\npopulation = start_run(\n    db_mooa['89'], \n    n=12, # seed\n    client=I.get_client(), \n    offspring_size=10,  # Low amount of offspring just as an example \n    pop=None,  # adapt this to the output population of the previous run to continue where you left off\n    continue_cp=False,  # if it is a first run, this should equal False. If you want to continue a preivoius run, set to True\n    max_ngen=1  # run for just 1 generation\n    )", "hostname": "somacpu201\n", "metadata_creation_time": "together_with_new_key", "version": "heads/publish+0.g7a21afd2.dirty", "full-revisionid": "7a21afd24aaf788fc96160fcbc55b27ab4972e4b", "dirty": true, "error": null}