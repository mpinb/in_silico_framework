'''
Created on Jan 28, 2013

ongoing activity L2 neuron model

@author: robert, arco
'''
from __future__ import absolute_import
from ._matplotlib_import import *
import sys
import time
import os, os.path
import glob
#for some reason, the neuron import works on the florida servers only works if tables was imported first
import tables 
import neuron
import single_cell_parser as scp
import single_cell_analyzer as sca
import numpy as np
h = neuron.h
import dask
from .seed_manager import get_seed
from .utils import *
from model_data_base.mdbopen import resolve_mdb_path

import socket
    
def _evoked_activity(cellParamName, evokedUpParamName, dirPrefix = '', \
                     seed = None, nSweeps = 1000, tStop = 345.0,
                     tStim = 245.0, scale_apical = scale_apical,
                     cell_generator = None):
    '''
    pre-stimulus ongoing activity
    and evoked activity
    
    sim name: str, describing the simulation
    cellParamName: str, Path to cell parameter file, containing information about:
        - info: autor, date, name
        - NMODL_mechanisms: path to NEURON mechanisms
        - neuron: 
            -path to hoc-file
            - per subcellular compartment (Soma, AIS, ...):
                - electrical properties
                - mechanisms
    evokedUpParamName: str, Path to network parameter file, containing information about:
                            - autor, name, date
                            - for each cell-type: 
                                synapse: release probability, path to distribution file, receptor and associated parameters
                                connectionFile: path to connection file
                                cell number
                                celltype: pointcell, spiketrain
    '''
    assert seed is not None
    np.random.seed(seed)
    print("seed: {}".format(seed))
    
    neuronParameters = load_param_file_if_path_is_provided(cellParamName)
    evokedUpNWParameters = load_param_file_if_path_is_provided(evokedUpParamName) ##sumatra function for reading in parameter file
    scp.load_NMODL_parameters(neuronParameters)
    scp.load_NMODL_parameters(evokedUpNWParameters)
    cellParam = neuronParameters.neuron
    paramEvokedUp = evokedUpNWParameters.network

    if cell_generator is None:
        cell = scp.create_cell(cellParam, scaleFunc=scale_apical)
    else:
        print("cell is generated by cell_generator. cell_param is ignored!")
        cell = cell_generator()
                    
    uniqueID = 'seed' + str(seed) + '_pid' + str(os.getpid())
    dirName = os.path.join(resolve_mdb_path(dirPrefix), 'results', \
                           time.strftime('%Y%m%d-%H%M') + '_' + str(uniqueID))
    if not os.path.exists(dirName):
        os.makedirs(dirName)
    with open(os.path.join(dirName, 'hostname_' + socket.gethostname()), 'w') as f:
        pass        
    
    vTraces = []
    tTraces = []
    recordingSiteFiles = neuronParameters.sim.recordingSites
    recSiteManagers = []
    for recFile in recordingSiteFiles:
        recSiteManagers.append(sca.RecordingSiteManager(recFile, cell))
    
    tOffset = 0.0 # avoid numerical transients
    neuronParameters.sim.tStop = tStop
    dt = neuronParameters.sim.dt
    offsetBin = int(tOffset/dt + 0.5)
    
    nRun = 0
    while nRun < nSweeps:
        synParametersEvoked = paramEvokedUp
        
        startTime = time.time()
        evokedNW = scp.NetworkMapper(cell, synParametersEvoked, neuronParameters.sim)
        evokedNW.create_saved_network2()
        stopTime = time.time()
        setupdt = stopTime - startTime
        print('Network setup time: {:.2f} s'.format(setupdt))
                
        synTypes = list(cell.synapses.keys())
        synTypes.sort()
        
        print('Testing evoked response properties run {:d}  of {:d}'.format(nRun+1, nSweeps))
        tVec = h.Vector()
        tVec.record(h._ref_t)
        startTime = time.time()
        scp.init_neuron_run(neuronParameters.sim, vardt=False) #trigger the actual simulation
        stopTime = time.time()
        simdt = stopTime - startTime
        print('NEURON runtime: {:.2f} s'.format(simdt))
        
        vmSoma = np.array(cell.soma.recVList[0])
        t = np.array(tVec)
        vTraces.append(np.array(vmSoma[offsetBin:])), tTraces.append(np.array(t[offsetBin:]))
        for RSManager in recSiteManagers:
            RSManager.update_recordings()
        
        print('writing simulation results')
        fname = 'simulation'
        fname += '_run%04d' % nRun
        
        synName = dirName + '/' + fname + '_synapses.csv'
        print('computing active synapse properties')
        sca.compute_synapse_distances_times(synName, cell, t, synTypes) #calls scp.write_synapse_activation_file
        preSynCellsName = dirName + '/' + fname + '_presynaptic_cells.csv'
        scp.write_presynaptic_spike_times(preSynCellsName, evokedNW.cells)
        
        nRun += 1
        
        cell.re_init_cell()
        evokedNW.re_init_network()

        print('-------------------------------')
    
    vTraces = np.array(vTraces)
    dendTraces = []

    scp.write_all_traces(dirName+'/'+uniqueID+'_vm_all_traces.csv', t[offsetBin:], vTraces)
    for RSManager in recSiteManagers:
        for recSite in RSManager.recordingSites:
            tmpTraces = []
            for vTrace in recSite.vRecordings:
                tmpTraces.append(vTrace[offsetBin:])
            recSiteName = dirName +'/' + uniqueID + '_' + recSite.label + '_vm_dend_traces.csv'
            scp.write_all_traces(recSiteName, t[offsetBin:], tmpTraces)
            dendTraces.append(tmpTraces)
    dendTraces = np.array(dendTraces)
    
    print('writing simulation parameter files')
    neuronParameters.save(os.path.join(dirName, uniqueID + '_neuron_model.param'))
    evokedUpNWParameters.save(os.path.join(dirName, uniqueID+ '_network_model.param'))
    return dirName
    
def run_new_simulations(cellParamName, evokedUpParamName, dirPrefix = '', \
                                 nSweeps = 1000, nprocs = 40, tStop = 345, silent = True, \
                                 scale_apical = scale_apical,
                                 cell_generator = None):
    '''Generates nSweeps*nprocs synapse activation files and puts them in
    the folder dirPrefix/results/[unique_identifier]. Returns delayed object, which can
    be computed with an arbitrary dask scheduler. For each process, a new
    seed is generated using the seed generator.
    
    Parameters:
        cellParamName: str, Path to cell parameter file, containing information about:
            - info: autor, date, name
            - NMODL_mechanisms: path to NEURON mechanisms
            - neuron: 
                -path to hoc-file
                - per subcellular compartment (Soma, AIS, ...):
                    - electrical properties
                    - mechanisms
        evokedUpParamName: str, Path to network parameter file, containing information about:
                                - autor, name, date
                                - for each cell-type: 
                                    synapse: release probability, path to distribution file, receptor and associated parameters
                                    connectionFile: path to connection file
                                    cell number
                                    celltype: pointcell, spiketrain
        nSweeps: number of synapse activations per process
        nprocs: number of independent processes
        tStop: time in ms at which the synaptic input should stop.
        
    Returns: Delayed object. Can be computed with arbitrary scheduler.'''
    
    myfun = lambda seed: _evoked_activity(cellParamName, evokedUpParamName,
                                         dirPrefix = dirPrefix, seed = seed, nSweeps = nSweeps, \
                                         tStop = tStop, scale_apical = scale_apical,
                                         cell_generator = cell_generator)
    if silent:
        myfun = silence_stdout(myfun)
        
    d = [dask.delayed(myfun)(get_seed()) for i in range(nprocs)]
    return dask.delayed(lambda *args: args)(d) #return single delayed object, that computes everything    